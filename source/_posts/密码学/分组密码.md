---
title: 分组密码
date: 2025-03-29 15:34:00
tags: [密码学，笔记]
categories: [密码学]
excerpt: 分组密码基础知识，包括DES、AES等经典算法的原理、结构和安全性分析。
---

### 分组密码（每次加密固定长度的明文）
#### 原理
   输入：一个定长的明文分组
   输出：一个等长的密文分组

#### 例子:
   DES:   n= 64 bits,    k = 64 bits
   AES:   n=128 bits,    k = 128, 192, 256 bits
#### 设计分组密码的两种基本技术
   `混乱和扩散的思想由香农提出,目的是为了抵抗攻击者对密码系统的统计分析`
   - 混乱
     - 目的：使明文和密文之间、密钥和密文之间的相关统计特性极小化，从而使攻击者无法找到密钥
     - 方法：代换
   - 扩散
     - 目的：将明文及密钥的影响尽可能迅速地散布到较多个密文比特中
     - 方法：置换
#### 分组密码的迭代构造
   `目前，绝大多数的分组密码都是通过迭代技术构造的`

<img src="/chunk.github.io/images/ea5e5dd77984238841eaceb16d97fe76.jpg" alt="ea5e5dd77984238841eaceb16d97fe76" style="zoom:50%;" />

### 数据加密标准（DES）
#### 核心设计思想：Feistel 网络
   <img src="/chunk.github.io/images/d60eb10b673e58e10453bc6acff8501c.jpg" alt="d60eb10b673e58e10453bc6acff8501c" style="zoom:50%;" />
#### 为什么 Feistel 网络是可逆的？
   <img src="/chunk.github.io/images/88e264039f4441cb13b3056499faab0d.jpg" alt="88e264039f4441cb13b3056499faab0d" style="zoom:50%;" />
#### 求逆过程
   <img src="/chunk.github.io/images/7ed6f4067415d94d81bde354174efd9d.jpg" alt="7ed6f4067415d94d81bde354174efd9d" style="zoom:50%;" />
#### DES的结构
<img src="/chunk.github.io/images/b9a7c0ef023c76a013b46eb3f7f55737.jpg" alt="b9a7c0ef023c76a013b46eb3f7f55737" style="zoom:50%;" />

<img src="/chunk.github.io/images/1cce1c407b0f0f6ca72076e930c4bcd9.jpg" alt="1cce1c407b0f0f6ca72076e930c4bcd9" style="zoom:50%;" />

   乘积函数F有三个关键函数:

   - E-box
   - S-box(DES里唯一的非线性部分)
   - P-box
#### DES的安全性
   - DES的最大问题: 
     - 随着计算机技术的飞速发展，56 bits 的 有效密钥长度不足以抵抗穷举攻击
     - 因为密钥空间大小只有 2[^56] ≈ 1017
   - DES依靠S-box实现非线性变换，但NSA被指责在S-box设计上隐藏了“陷门”
     - 穷举密钥攻击可以攻破有效密钥长度的DES
### 抵抗穷举攻击
`穷举攻击（已知明文攻击）：给定明密文对  (mᵢ, cᵢ = E(k, mᵢ))   i=1, 2, 3……找到密钥 k`
`如何抵抗DES的穷举攻击->增加密钥长度`
#### 3DES
> 使用两个或三个密钥，执行三次DES算法
> 使用3个密钥，有效密钥长度可达 168 bits
> 使用2个密钥，有效密钥长度可达 112 bits
>
> <img src="/chunk.github.io/images/7f78f90f6c06b256b034c960441bea96.jpg" alt="7f78f90f6c06b256b034c960441bea96" style="zoom:50%;" />
>
> 例：DES-EDE3，是以三个不同的密钥，以加密-解密-加密的方式依次处理
#### 中间相遇攻击（Meet-in-the-middle attack）
> 当使用两重DES时，会遭受中间相遇攻击
    <img src="/chunk.github.io/images/5a899a21df281cd19450f5ab77525f1b.jpg" alt="5a899a21df281cd19450f5ab77525f1b" style="zoom:50%;" />
#### DESX
用3DES加密时，效率只有原DES的1/3。R.Rivest提出DESX作为DES的扩充版本。希望以更少的效率损失增加密钥的长度及穷举攻击的难度。
 <img src="/chunk.github.io/images/729ab86f90ad2888bb2282a71398077d.jpg" alt="729ab86f90ad2888bb2282a71398077d" style="zoom:50%;" />

#### 其他分组密码体制
- AES（高级加密标准）
  - DES的替代品
  - 比3DES快且至少一样安全, 分组128 bits, 密钥128/192/256 bits
- IDEA
  - 分组长度 64 bits,  密钥长度 128 bits, 用于 PGP
### PRF和PRP
`PRF和PRP是描述分组密码安全性的工具，是两种理想模型`
#### PRF（伪随机函数）
###### 定义
      存在高效的算法计算  F(k,x),   F:  K × X ->Y
###### 直觉上的安全
<img src="/chunk.github.io/images/bb03e26d2bf3581ac62fcc3bf0c511f8.jpg" alt="bb03e26d2bf3581ac62fcc3bf0c511f8" style="zoom:50%;" />

###### 安全模型

<img src="/chunk.github.io/images/39ace6d33edf532eccb77bf9a23b5f61.jpg" alt="39ace6d33edf532eccb77bf9a23b5f61" style="zoom:50%;" />

    如果对于所有高效的攻击者A，   
                    Adv  :=  |Pr[EXP(0)=1] – Pr[EXP(1)=1] |   
      是可忽略的，则F是安全的 PRF
#### PRP（伪随机置换）
`存在逆置换，可以用来做加解密`
###### 定义
      存在高效的算法计算置换 E(k, x)(对应的逆置换为D(k, x)),
       E:  K × X  ->X
###### 直觉上的安全
<img src="/chunk.github.io/images/3780d774e12cd81d8a1d1be30382acf5.jpg" alt="3780d774e12cd81d8a1d1be30382acf5" style="zoom:50%;" />

###### 安全模型

<img src="/chunk.github.io/images/7d89ebe4df2c4ef507f932413605293c.jpg" alt="7d89ebe4df2c4ef507f932413605293c" style="zoom:50%;" />

    如果对于所有高效的攻击者A， 
            Adv  :=  |Pr[EXP(0)=1] – Pr[EXP(1)=1] |  
       是可忽略的，则E是安全的 PRP
任何 PRP 也是 PRF，其中X = Y，并且是高效可逆的！
#### PRF Switching Lemma
**当|X|足够大时，安全的 PRP 才是安全的 PRF**
#### 实际应用
- 实际应用中，认为这些分组密码是安全的PRP：AES（｜X｜足够大）
- 绝大多数情况下，PRF可以用AES等分组密码进行代替
### CPA安全性
`密钥重复使用时，如何保证安全性？`
#### 攻击形式
- 密钥可以重复使用  ⇒  攻击者可以获得同一密钥加密的多个密文
- 攻击者攻击能力：
  - 选择明文攻击 (CPA, chosen-plaintext attack) (密钥可以重复使用)
  可以获得他选择的一个或多个明文对应的密文
  - 攻击者攻击目的：破坏语义安全性
#### 定义
选择明文攻击下的语义安全性 ，简称 CPA安全性。
#### 模型
<img src="/chunk.github.io/images/b8ec9efa2de2504127dceab92ef828a0.jpg" alt="b8ec9efa2de2504127dceab92ef828a0" style="zoom:50%;" />

```
如果一个对称加密体制是CPA安全的，它应满足以下条件：
在上述安全模型中，对于所有高效的攻击者A,
         Adv :=| Pr[EXP(0)=1] – Pr[EXP(1)=1] |
是可忽略的。
```

#### 确定性的加密对称体制不是CPA安全的
> 设 E 是确定性的（对相同的明文，总是输出相同的密文）
<img src="/chunk.github.io/images/4fab9fde4933816371ac5acea434eb01.jpg" alt="4fab9fde4933816371ac5acea434eb01" style="zoom:50%;" />

#### 实现方式
- 如何实现密钥的重复使用 (即满足CPA安全性)？
  - 加密体制必须是概率的 (对于相同密钥和明文，密文可以不相同)
  - 加密相同的明文，得到相同密文的概率是可忽略的
##### 随机加密
<img src="/chunk.github.io/images/b1c0545ee707e20fee0fff3430185837.jpg" alt="b1c0545ee707e20fee0fff3430185837" style="zoom:50%;" />

##### nonce-based加密
<img src="/chunk.github.io/images/e1486df16d02f49dbc7b9a0ebc543deb.jpg" alt="e1486df16d02f49dbc7b9a0ebc543deb" style="zoom:50%;" />

### 工作模式 
```
为什么需要工作模式？
分组密码的输入是定长的。
要加密的明文长度往往大于一个明文分组。
需要采用适当的工作模式以保证明文整体的安全性
```
<img src="/chunk.github.io/images/712d604256a9614a8e6534249c0d13de.jpg" alt="712d604256a9614a8e6534249c0d13de" style="zoom:50%;" />

#### ECB模式
`不是语义安全的，不推荐使用`
##### 工作原理
<img src="/chunk.github.io/images/489a252a576184f098ebc6fae5b9119c.jpg" alt="489a252a576184f098ebc6fae5b9119c" style="zoom:50%;" />

##### 安全性
> 对于包含两个或两个以上分组的明文，ECB不是语义安全的
<img src="/chunk.github.io/images/74323d13a12acddf17753785196895e4.jpg" alt="74323d13a12acddf17753785196895e4" style="zoom:50%;" />
##### 特性
- 优点
  - 简单、高速
  - 无差错传播：单个密文分组在传输或存储时出现错误，只会影响该分组的解密，不会影响到其他分组
- 缺点
  - 安全性差，暴露明文数据的格式和统计特征
- 适用于发送少量数据的场合，一般不推荐使用
#### CBC模式
`密钥可以重复使用，CPA安全的`
##### 加密过程
<img src="/chunk.github.io/images/8f6673e9814da69919d37bde300ad124.jpg" alt="8f6673e9814da69919d37bde300ad124" style="zoom:50%;" />

##### 解密过程
<img src="/chunk.github.io/images/9cb9cc2e82b01304f3765bc0a5fd3452.jpg" alt="9cb9cc2e82b01304f3765bc0a5fd3452" style="zoom:50%;" />

##### 特性
- 差错传播
  单个密文分组在传输或存储过程中发生错误，会影响该分组和后面一个分组的解密。
- 可自同步
  只要后面的分组没发生错误，便不会影响后续分组的解密
  <img src="/chunk.github.io/images/8fce40a89795c4cf13dfd79880574194.jpg" alt="8fce40a89795c4cf13dfd79880574194" style="zoom: 50%;" />
  如果IV是可预测的，则不是CPA安全的！！！
##### IV的选择
- CBC$：IV取随机数，与密文一起发送。
  用安全的PRG产生随机数，以保证不可预测性
- CBCC：IV取计数器（接收者不知道IV时，才需要发送）
  计数器按照固定步长增加，所以是可预测的。
  如果直接使用，会使CBC模式不安全。
  (可以使用 CBC-ESSIV，即先加密计数器，再使用）
- CBC-ESSIV:  先加密计数器，再使用。（k=k ₁时不安全）
  <img src="/chunk.github.io/images/af702f27cd94f31ad99090c07f22a862.jpg" alt="af702f27cd94f31ad99090c07f22a862" style="zoom:50%;" />
- 举例：Crypto API    (OpenSSL)
调用者提供IV
`当IV是计数器时，使用前需要先加密，否则不安全`
##### 填充（Padding）
> 明文长度是不固定的，按固定长度分组时，如果最后一个分组长度不足时进行填充。
<img src="/chunk.github.io/images/5ae4e8e9d12c618383f7b7de987bcda9.jpg" alt="5ae4e8e9d12c618383f7b7de987bcda9" style="zoom:50%;" />

#### CTR模式
`密钥可以重复使用，CPA安全的`
##### 加密过程
<img src="/chunk.github.io/images/37b53daccf291329065a6ce78e30eda9.jpg" alt="37b53daccf291329065a6ce78e30eda9" style="zoom:50%;" />

##### 特性
- 简单/速度快
  - 实现简单（只需要加密算法）， 效率高/ 可预计算, 可并行，吞吐量仅受可并行数量的限制
- 没有差错传播
  - 单个密文分组在传输或存储过程中发生错误，只影响该分组的解密，不影响其他分组。
##### IV的选择
- CTR$
IV取随机数，与密文一起发送。
使用安全的PRG产生随机数，以保证不可预测性
- CTRC
IV取计数器（接收者不知道IV时，才需要发送）
保证F(k, x)不会重复出现，例如可以计数器从0开始，每加密一个明文分组便加1
### 小结
|   | CBC | CTR |
| --- | --- | --- |
| 抽象工具 | PRP | PRF |
| 并行性 | （加密）不行 | 可以 |
| 填充 | **需要** | 不需要 |
| 密文有扩张 | 有 | 没有 |
使用密文窃取填充技术时，不需要 dummy block

|            | 密钥只能用一次 | 密钥可重复使用（CPA安全） |
| ---------- | -------------- | ------------------------- |
| 语义安全性 | 流密码         | CBC、CTR                  |

- 两个重要安全性概念: (抵抗窃听者) 
  - 语义安全性 (密钥只用一次时)

  - CPA安全性 (密钥重复使用时)
