---
title: 数据完整性技术
date: 2025-04-15 7:17:00
tags: [密码学，笔记]
categories: [密码学]
---
## 引例
1. 如果传输/存储的数据被篡改，怎么知道？
   - 使用“数据完整性技术”
   - 当消息发生改变时，可以检查出来
2. 若将 m 与 H(m) 一起发送，接收方用接受的 m' 计算 H(m') ，比较两个散列值是否可以知道消息是否被篡改
   - 不能
   - 攻击者可伪造 m₀ 与 H(m₀) 发送
   - 问题关键：Hash函数没有密钥(给定消息，任何人都可以计算)
3. 数据完整性技术
   - 当设计一个带密钥的算法时可以抵抗伪造
   - 分类
     - 消息认证码(MAC/message authentication code)
       - 对称密码技术
     - 数字签名(digital signature)
       - 公钥密码技术
## 消息认证码MAC
### 定义
- MAC是实现数据完整性的重要工具
- MAC : K × M ->T ，其中， m ∈ M 称为消息， t ∈ T 称为“MAC”
- Alice与Bob知道密钥k，Bob收到Alice的消息 m 和 MAC值t 后，利用密钥算出 MAC(k,m) 与t比较，若相同则说明未被篡改
### MAC的安全性
1. 攻击者攻击能力
   - 选择消息攻击(CMA,chosen-message attack)
     * 攻击者选择消息，获得对应的MAC
   - 攻击者目的
     * 存在性伪造：伪造一对新的消息 MAC(m,t)(m,t) ∉ {(m₁,t₁),...,(mₚ,tₚ)}  
   - 直觉上的MAC安全性
     * 攻击者不能为一个新消息产生有效的 MAC
     * 给定 (m',t') ，攻击者甚至不能为 m' 产生另一个有效的MAC t，t != t'
2. 安全模型和定义
   <img src="/chunk.github.io/images/4abeee7a2ba97d5ad9a047cccc5095e1.jpg" alt="4abeee7a2ba97d5ad9a047cccc5095e1" style="zoom:50%;" />
   一个MAC算法是安全的，则对于任意高效的攻击者A，他在上述安全模型中伪造成功的概率      **Adv = Pr[A伪造成功]**       是可忽略的。
##### 例题
> 如果对于密钥空间 1/2 的密钥，攻击者都可以找到两个消息 m₀ != m₁ 使得MAC(k,m₀) = MAC(k,m₁) ，这个MAC安全吗？
<img src="/chunk.github.io/images/df6399e8d912125c6d75c10434666479.jpg" alt="df6399e8d912125c6d75c10434666479" style="zoom:50%;" />
==MAC本身必须抗碰撞==
> 如果MAC(k,m)的输出总是5比特，这个MAC安全吗？
<img src="/chunk.github.io/images/ca58aa4889c61b30d76ceab1a0c5e347.jpg" alt="ca58aa4889c61b30d76ceab1a0c5e347" style="zoom:50%;" />
     ==MAC的输出必须足够长==
### MAC的构造
1. PRF-based MACs
* 定义：设F: K × X  ⟶ Y 是安全的PRF，构造 MAC如下:
  MAC (k,m) = F(k, m)
  <img src="/chunk.github.io/images/e088d18c360497d7055d29940b9779c9.jpg" alt="e088d18c360497d7055d29940b9779c9" style="zoom:50%;" />
* 定理
  只要|Y|足够大，则安全的PRF⇒安全的MAC
* 截取问题
  从 PRF-based MACs 的输出中截取w-bit作为新的MAC，仍是安全的。
  w大于等于64时是可忽略的
* 缺点
  - 只能处理短消息
  - 如基于AES的MAC只能处理128比特的消息
  - 利用CBC-MAC与HMAC处理长消息
2. CBC-MAC(基于CBC模式)
   * CBC-MAC
     <img src="/chunk.github.io/images/09f4deb75dfc6368ef49d2e4e3df24b5.jpg" alt="09f4deb75dfc6368ef49d2e4e3df24b5" style="zoom:50%;" />
     
     <img src="/chunk.github.io/images/232aae079d92fa46c5e2433e07b00d5d.jpg" alt="232aae079d92fa46c5e2433e07b00d5d" style="zoom:50%;" />
     
   * ECBC-MAC
     <img src="/chunk.github.io/images/60626a899321c8ec8e8495dae949e240.jpg" alt="60626a899321c8ec8e8495dae949e240" style="zoom:50%;" />
     
     * 填充 
       - 如果消息不是分组的整数倍，需要进行填充
       - 若追加一串0作为填充，会导致m的MAC与新消息mll0的MAC相等
         - 原因：pad(m)=pad(mll0)
       - 为保证安全性
         - 填充方法必须可逆！
         - m₀ ≠ m₁   ⇒  pad(m₀) ≠ pad(m₁)
       - ISO填充方法：==用“100...00”填充，需要的话可追加一个dummy block==
         - 1表示这串是填充的开始
         - ISO标准的CBC-MAC
         <img src="/chunk.github.io/images/f891c3003bb0e6ff215b4099fae4fc45.jpg" alt="f891c3003bb0e6ff215b4099fae4fc45" style="zoom:50%;" />
   
3. HMAC（基于抗碰撞Hash函数）
   * 为什么基于Hash函数构造？
     - Hash函数的软件实现快于分组密码
     - Hash函数没有出口限制
   * 模型
     <img src="/chunk.github.io/images/70434232a677748c370395b4641a0640.jpg" alt="70434232a677748c370395b4641a0640" style="zoom:50%;" />
## 数字签名
### 数字签名概述
> 基于公钥思想的数据完整性技术
#### 手写签名
   * 目的：绑定签名者信息与文件
   * 问题：任何人都可使用
   
#### 数字签名
   <img src="/chunk.github.io/images/084d1d5b612ff6c1b290740811673717.jpg" alt="084d1d5b612ff6c1b290740811673717" style="zoom:50%;" />
   
#### 数字签名体制定义

   <img src="/chunk.github.io/images/11c1e9b12e95cbc656d5dbbcdcacbfb6.jpg" alt="11c1e9b12e95cbc656d5dbbcdcacbfb6" style="zoom:50%;" />

#### 数字签名体制的安全性
   * ##### 攻击形式
     - 攻击者攻击能力：选择消息攻击攻击者
     选择消息 m₁, …, mₚ ∈M, 他可以获得相应的签名        σᵢ <- Sign (sk, mᵢ)
     - 攻击者攻击目的：存在性伪造
     伪造一对新的消息/签名  (m, σ)，m  ∉  { m₁, … , mₚ }
   * ##### 直觉上的安全性
     攻击者不能为一个新消息产生有效的签名
   * ##### 安全模型和定义
     <img src="/chunk.github.io/images/897ad1fc3d94d63cfc08e46bfc8b6150.jpg" alt="897ad1fc3d94d63cfc08e46bfc8b6150" style="zoom:50%;" />
     一个数字签名体制是安全的，则对于任意高效的攻击者  A，在上述安全模型中伪造成功的概率         
     Adv := Pr[ A伪造成功 ]    是可忽略的
* ##### 例题
  <img src="/chunk.github.io/images/65963870d49fe4d8af10fddad2221f4f.jpg" alt="65963870d49fe4d8af10fddad2221f4f" style="zoom:50%;" />
#### 利用抗碰撞hash函数签署长消息
* 构造工具
  * 数字签名体制SIG=(Setup, Sign, Verify),消息空间为 M
  
  * 函数：Hash函数
    <img src="/chunk.github.io/images/ecca3b66634a18ee9cf7b74633d56e3f.jpg" alt="ecca3b66634a18ee9cf7b74633d56e3f" style="zoom:50%;" />
    
  * 安全性
    如果 SIG 是安全的数字签名体制 (消息空间为 M)、H是抗碰撞Hash函数，则这个数字签名体制也是安全的
    
  * 例题 
  
    <img src="/chunk.github.io/images/124cc8994a5500707a2e98fc1ce91274.jpg" alt="124cc8994a5500707a2e98fc1ce91274" style="zoom:50%;" />
### RSA数字签名体制
#### 全域Hash (FDH)
   * ##### 构造工具
     - (G, F, F⁻¹):  定义在 X 上的 TDP
     - H: M -> X，全域Hash函数
       `全域Hash不等同于全域Hash函数`
   * ##### 过程
     <img src="/chunk.github.io/images/b9cb4fd0406baed001438220b929582f.jpg" alt="b9cb4fd0406baed001438220b929582f" style="zoom:50%;" />
   * ##### 例题
     <img src="/chunk.github.io/images/5d478b0565f4229d8dd0b78fc4bd109b.jpg" alt="5d478b0565f4229d8dd0b78fc4bd109b" style="zoom:50%;" />
#### RSA-FDH
   <img src="/chunk.github.io/images/d406e001bbcd7e8bebad8aaf5da76dec.jpg" alt="d406e001bbcd7e8bebad8aaf5da76dec" style="zoom:50%;" />
### PKI(公钥基础设施)
`校验者如何确定收到的是签名者的公钥？     依赖认证的信道 `
##### 公钥证书
   * 使用过程
   <img src="/chunk.github.io/images/dd61fdd42360fbdcbe07a784d43c85ce.jpg" alt="dd61fdd42360fbdcbe07a784d43c85ce" style="zoom:50%;" />
   * 逻辑形式：用户身份信息+用户公钥+CA的签名
##### PKI
   * 定义:一个使用公钥概念和密码技术实施和提供安全服务的具有普适性的安全基础设施的总称。
   * 提醒：PKI不是特指某一个密码设备和管理设施，它是
     - 生成、管理、存储、颁发和撤销公钥证书所需要的软硬件、人员、策略和规程的总和
     - 提供密钥管理和数字签名服务的平台
   * 密钥生命周期
     <img src="/chunk.github.io/images/2de7feff00e391f50dceb7047ed245c7.jpg" alt="2de7feff00e391f50dceb7047ed245c7" style="zoom:50%;" />
   * **X.509**公钥证书格式
   * 相关产品
     - VeriSign——最大的CA
     - Entrust 公司——世界一流
