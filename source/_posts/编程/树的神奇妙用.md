---
title: 树的神奇妙用
date: 2025-08-27 21:07:00
tags: [编程，竞赛]
categories: [编程，《算法竞赛入门经典》]
excerpt: 树数据结构的各种应用技巧，包括存储结构、遍历算法和经典问题解法。
---

本文例题均来自于刘汝佳老师的《算法竞赛入门经典》，均可在 [UVa](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=827) 提交

## 存储结构

### 树

#### 邻接表（万能的）

```c++
const int N=1e5+5;
vector<int> g[N];

void add_edge(int u,in v){
	g[u].push_back(v);
	g[v].push_back(u);
}
```

```c++
//dfs示例
void dfs(int u,int fa){
	for(v:g[u]){
		if(v==fa) continue;
		dfs(v,u);
	}
}

//bfs示例
void bfs(int s){
	queue<int> q;
    vector<int> dist(N, -1);
    q.push(s);
    dist[s] = 0;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) {
            if (dist[v] == -1) {
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
}
```

#### 父节点数组 + 倍增表

```c++
int parent[N][LOG], depth[N];
```

#### 欧拉序

```c++
vector<int> euler; 
int first[N]; // first[u] = u 在欧拉序的出现位置
```

### 二叉树

#### 链式结构

```c++
struct Node{
	int val;
	Node *lchild,*rchild;
    Node(int x):val(x),lchild(NULL),rchild(NULL){}
};
```

```c++
Node* bulid_tree(){
	int val;
	cin >> val;
	if(val==-1) return NULL;
	Node* root=new Node(val);
	root->lchild=build_tree();
	root->rchild=build_tree();
	return root;
}
```

#### 数组存储——完全二叉树/堆

下标从`1（root）`开始，`i`的左孩子是`2*i`，右孩子是`2*i+1`

```c++
int tree[N],n=1;
tree[n++]=val; //层次遍历
```

## 树和二叉树基础

#### 二叉树的编号

[UVa 679 小球下落](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=620)

当第$i$个小球落到机关上时掉落方向与前$i-1$个小球中落到该机关的小球数量有关，假设此前有$k$个小球落到此机关：

- 若$k$为偶数，此时机关为$false$，第$i$个小球落向左边 → $i$为奇数
- 若$k$为奇数，第$i$个小球落向右边 →$i$为偶数

如果我们按掉落的层数来分析，可以看出：每个小球都需要下落$D-1$层，在每一层，只需要考虑当前小球是落到此处的第几个小球。

> 在完全二叉树中，对于结点k，其左、右孩子对应的编号为`2*k，2*k+1`。

```c++
#include<iostream>
using namespace std;

int main() {
	int t;
	cin >> t;
	while (t--) {
		int d, n;
		cin >> d >> n;
		int ans = 1;
		for (int i = 1; i < d; i++) {
			if (n % 2 == 0) {
				n /= 2;
				ans = ans*2+1;
			}
			else {
				n = n / 2 + 1;
				ans = ans * 2;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

#### 二叉树的层次遍历

[UVa 122 树的层次遍历](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=58)

难点：如何处理输入构建二叉树？

> 1. `sscanf(&str,"*",&path)`：读取字符串`str`格式为*的字串存入path
>    - 当要完整解析整个字符串，用`str.c_str()`
>    - 当想跳过前面若干字符时，用`&str[i]`，会从`str[i]`开始
>    - 格式：```%d，(%d, %s)，(%d,%[^ )])```
>      - `%[^)]`---读取连续字符直到读到`')'`结束
> 2. `str.c_str()`：返回一个指向该字符串内容的 `const char*`的指针

初始考虑用数组存二叉树，当为$'R'$时存储位置下标$*2$，为$'L'$时，存储位置下标$*2+1$，建树过程中检查是否有重复赋值的情况，建完树之后检查是否有父节点未赋值的情况，输出层次遍历即按序输出数组元素。

但树结点不超过256，若为单边链表数组空间太大无法存储。

于是还是考虑用链表建树，最后bfs输出树的层次遍历（或用哈希表存储二叉树）。

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <cstdio>
#include <string>
using namespace std;

struct Node {
    int val;
    Node* lchild;
    Node* rchild;
    Node() : val(-1), lchild(NULL), rchild(NULL) {}
};

bool build(Node*& root, int val, const string& s) {
    if (!root) root = new Node();
    Node* cur = root;
    for (char ch : s) {
        if (ch == 'L') {
            if (!cur->lchild) cur->lchild = new Node();
            cur = cur->lchild;
        }
        else if (ch == 'R') {
            if (!cur->rchild) cur->rchild = new Node();
            cur = cur->rchild;
        }
    }
    if (cur->val != -1) return false; 
    cur->val = val;
    return true;
}

bool bfs(Node* root) {
    queue<Node*> q;
    q.push(root);
    vector<int> res;
    while (!q.empty()) {
        Node* cur = q.front(); q.pop();
        if (cur->val == -1) return false; 
        res.push_back(cur->val);
        if (cur->lchild) q.push(cur->lchild);
        if (cur->rchild) q.push(cur->rchild);
    }
    for (int i = 0; i < res.size(); i++) {
        if (i) cout << " ";
        cout << res[i];
    }
    cout << "\n";
    return true;
}
void remove(Node*& root) {
    if (!root) return;
    remove(root->lchild);
    remove(root->rchild);
    delete root;
}
int main() {
    string s;
    while (true) {
        vector<string> node;
        if (!(cin >> s)) break; 
        if (s == "()") continue;
        node.push_back(s);
        while (cin >> s && s != "()") {
            node.push_back(s);
        }

        Node* root = NULL;
        bool ok = true;
        for (auto& str : node) {
            char cpath[256] = { 0 };
            int val;
            sscanf(str.c_str(), "(%d,%[^)])", &val, cpath); 
            string path = cpath;
            if (!build(root, val, path)) ok = false;
        }

        if (!ok || !bfs(root)) {
            cout << "not complete\n";
        }
        remove(root);
    }
    return 0;
}

```

#### 二叉树的递归遍历

[UVa 548 树](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=489)

按照中序、后序遍历建树，最后对树dfs求最小路径。

> 如何由中序、后序遍历构建二叉树？
>
> 1. 从后序序列中取出最后一位即为根节点；
> 2. 在中序序列中找到根节点位置，其左边即为左子树，右边即为右子树
>
> 递归建树。

主要是在递归建树时中后序序列的范围容易写错。

```c++
Node* build(int in_start,int in_end,int post_start,int post_end) {
	if (in_start > in_end) return NULL;
	Node* cur = new Node();
	int root = post_order[post_end];
	cur->val = root;
	int k = in_start;
	while (in_order[k] != root) k++;
	int left_len = k - in_start;
	cur->lchild = build(in_start, k - 1, post_start, post_start + left_len - 1);
	cur->rchild = build(k + 1, in_end, post_start + left_len, post_end - 1);
	return cur;
}
```

对该树dfs，在递归的过程中不断更新最小路径及最小树叶权重。

```c++
#include<iostream>
using namespace std;
int in_order[10001], post_order[10001];
#include<string>
#include<sstream>
#include<climits>
int n = 0;
int min_sum = INT_MAX, ans = INT_MAX;
struct Node {
	int val=-1;
	Node *lchild = NULL, *rchild = NULL;
};
void dfs(Node* root, int sum) {
	if (!root) return;
	sum += root->val;
	if (!root->lchild && !root->rchild) {
		if (min_sum > sum || (min_sum == sum && root->val < ans)) {
			min_sum=sum;
			ans=root->val;
		}
	}
	if(root->lchild) dfs(root->lchild, sum);
	if(root->rchild) dfs(root->rchild, sum);
}
int main() {
	string inorder, postorder;
	while (getline(cin, inorder)) {
		if (inorder.empty()) break;
		getline(cin, postorder);
		int x;
		n = 0;
		stringstream ss(inorder);
		while (ss >> x) in_order[n++] = x;
		stringstream ss1(postorder);
		for (int i = 0; i < n; i++) {
			ss1 >> x;
			post_order[i] = x;
		}
		min_sum = INT_MAX, ans = INT_MAX;
		int sum = 0;
		Node* root=build(0, n - 1, 0, n - 1);  //见上
		dfs(root, sum);
		cout << ans << endl;
	}

	return 0;
}
```

---

[UVa 839 天平](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=780)

难点在于对子天平的处理，子天平需要考虑以下两个方面：

- 子天平是否平衡
- 子天平的重量对整个天平的影响

即，我们需要做的是：

- 判断子天平是否平衡
- 计算出天平左右的总重量，再判断是否平衡

```c++
#include<iostream>
using namespace std;
bool solve(int& w) {   //输入天平，判断其子天平是否平衡，同时更新w为子天平的总质量
	int w1, d1, w2, d2;
	int flag1 = true, flag2 = true;
	cin >> w1 >> d1 >> w2 >> d2;
	if (!w1) flag1=solve(w1);
	if (!w2) flag2=solve(w2);
	w = w1 + w2;
	return flag1 && flag2 && (w1 * d1 == w2 * d2);
}
int main() {
	int t;
	cin >> t;
	while (t--) {
		int w = 0;
		if (solve(w)) cout << "YES" << endl;
		else cout << "NO" << endl;
		if(t) cout << endl;
	}

	return 0;
}
```

[UVa 699 下落的树叶](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=640)

此题二叉树选择用数组存储，将根节点存在下标为0处，然后分别递归存储左右子树，因为出现了负下标，因此我们选择使用哈希表存储树。

通过`build(pos - 1); build(pos + 1);`不断递归建树。

```c++
#include<iostream>
using namespace std;
#include<unordered_map>
unordered_map<int, int> tree;
int min_pos = 0, max_pos = 0;
void build(int pos) {
	int x;
	cin >> x;
	if (x == -1) return;
	tree[pos] += x;
	if (pos < min_pos) min_pos = pos;
	if (pos > max_pos) max_pos = pos;
	build(pos - 1);
	build(pos + 1);
}
int main() {

	int index = 1;
	while (true) {
		tree.clear();
		int x;
		cin >> x;
		if (x == -1) break;
		tree[0] += x;
		min_pos = 0;
		max_pos = 0;
		build(-1);
		build(1);
		cout << "Case " << index++ << ":" << endl;

		for (int i = min_pos; i <= max_pos; i++){
			if (i > min_pos) cout << " ";
			cout << tree[i];
		}
		cout << endl << endl;
	}
	return 0;
}
```

#### 练习题

[UVa 10562 看图写树](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=1503)

难点：如何处理输入的画——利用二维数组存储，之后递归处理打印字符即可

```

```

[UVa 536 二叉树重建](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=477)

由前序+中序输出后序，与前面那题相似。

```c++
#include<iostream>
using namespace std;
string pre_order, in_order;
int n;
struct Node {
	char val = ' ';
	Node* lchild = NULL, * rchild = NULL;
};
Node* build(int l1, int r1, int l2, int r2) {
	if (l1 > r1) return NULL;
	Node* cur = new Node();
	cur->val = pre_order[l1];
	int k = l2;
	while (k <= r2 && in_order[k] != pre_order[l1]) k++;
	cur->lchild = build(l1 + 1, l1 + k - l2, l2, k - 1);
	cur->rchild = build(l1 + 1 + k - l2 , r1, k + 1, r2);
	return cur;
}
void post_order(Node* root) {
	if (!root) return;
	if (root->lchild) post_order(root->lchild);
	if (root->rchild) post_order(root->rchild);
	cout << root->val;
}
int main() {
	while (cin >> pre_order >> in_order) {
		if (!pre_order.size()) break;
		n = pre_order.size();
		Node* root=build(0, n - 1, 0, n - 1);
		post_order(root);
		cout << endl;
	}

	return 0;
}
```

[UVa 12166 修改天平](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=839&page=show_problem&problem=3318)

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <string>
#include <map>
using namespace std;
typedef long long LL;

int cnt, sum;
char exp[1500000];
map<LL, int> ID;

void dfs(int l, int r, int depth) {
    if (exp[l] == '[') {
        int p = 0;
        for (int i = l + 1; i <= r; i++) {
            if (exp[i] == '[') p++;
            else if (exp[i] == ']') p--;
            if (p == 0 && exp[i] == ',') {
                dfs(l + 1, i - 1, depth + 1);
                dfs(i + 1, r - 1, depth + 1);
            }
        }
    }
    else {
        int weight;
        sscanf(exp + l, "%d", &weight);
        ID[(LL)weight * (1 << depth)]++;
        sum++;
    }
}

int main()
{

    int iCase;
    scanf("%d", &iCase);
    while (iCase--) {
        ID.clear();
        cnt = 1, sum = 0;
        scanf("%s", exp);
        dfs(0, strlen(exp) - 1, 0);
        map<LL, int>::iterator iter;
        int Max = 0;
        for (iter = ID.begin(); iter != ID.end(); iter++) {
            Max = Max > iter->second ? Max : iter->second;
        }
        printf("%d\n", sum - Max);
    }
    return 0;
}
```

[UVa 10410 树重建](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1351)

```c++
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
using namespace std;

int main() {
    int n;
    while (scanf("%d", &n) == 1) {
        vector<vector<int>> children(n + 1);
        vector<int> pos(n + 1);

        // 读 BFS 序列，记录位置
        for (int i = 1, x; i <= n; i++) {
            scanf("%d", &x);
            pos[x] = i;
        }

        stack<int> stk;
        int root;
        scanf("%d", &root);
        stk.push(root);

        // 遍历剩余 n-1 个 DFS 序列元素
        for (int i = 1, x; i < n; i++) {
            scanf("%d", &x);
            while (!stk.empty()) {
                int t = stk.top();
                // 判断 x 是否是 t 的子节点
                if (t == root || pos[x] > pos[t] + 1) {
                    // 是 child
                    children[t].push_back(x);
                    stk.push(x);
                    break;
                } else {
                    // 不是，说明应当回溯
                    stk.pop();
                }
            }
        }

        // 输出结果
        for (int i = 1; i <= n; i++) {
            printf("%d:", i);
            for (int c : children[i]) {
                printf(" %d", c);
            }
            printf("\n");
        }
    }
    return 0;
}
```



## 表达树

如何建表达树？

1. 树的结构体定义

   表达树的的结点应该包含以下信息：当前结点的类型（运算符、变量、常数），左右孩子，值

   ```c++
   struct tree{
   	int type; // 1=运算符, 2=变量, 3=常数
       long long val;  //根据type定义
       				// - 如果 type=1 → val=1(+),2(-),3(*)
                       // - 如果 type=2 → val=变量编号（比如 x3 就是 3）
                       // - 如果 type=3 → val=常数值
       tree *l,*r;
       tree(int _type=0,long long _val=0):type(_type),val(_val),l(NULL),r(NULL){}
   };
   ```

2. 建树

   使用栈——读到常数、变量就建叶子，压栈，读到运算符就弹栈（栈顶两元素分别为这个运算符的左右子树，再新建节点并压入栈）

   ```c++
   while (ss >> s) {
   	if (s == "*" || s == "+" || s == "-") {
   		Node* r = st.back(); st.pop_back();
   		Node* l = st.back(); st.pop_back();
   		int op = (s == "+") ? 1 : (s == "-") ? 2 : 3;
   		Node* u = new Node(1, op);
   		u->l = l;
   		u->r = r;
   		st.push_back(u);
   	}
   	else if (s[0] == 'x') {
   		int idx = stoi(s.substr(1));
   		st.push_back(new Node(2, idx));
   	}
   	else {
   		ll c = stoll(s);
   		st.push_back(new Node(3, c));
   	}
   }
   Node* root = st.back();
   ```

[梯度求解](https://www.acwing.com/problem/content/description/5302/)

```c++
#include<iostream>
#include<cstring>
#include<vector>
#include<sstream>
#include<string>
using namespace std;
using ll = long long;
const ll N = 1e9 + 7;
struct Node {
	int type;
	ll val;
	Node* l, * r;
	Node(int _type = 0, ll _val = 0) :type(_type), val(_val), l(NULL), r(NULL) {}
};
vector<ll> pot( 105, 0);
ll get_val(Node* root) {
	if (root->type == 1) {
		ll x = get_val(root->l), y = get_val(root->r);
		if (root->val == 1) return (x + y) % N;
		if (root->val == 2) return (x - y + N) % N;
		return x%N*y% N;
	}
	else if (root->type == 2) {
		return pot[root->val] % N;
	}
	else return root->val % N;
}
ll qiudao(Node* root, int k) {
	if (root->type == 1) {
		ll x = qiudao(root->l,k), y = qiudao(root->r,k);
		if (root->val == 1) return (x + y) % N;
		if (root->val == 2) return (x - y + N) % N;
		long long fl = get_val(root->l), fr = get_val(root->r);
		return (x * fr % N + y * fl % N) % N;
	}
	else if (root->type == 2) {
		return (root->val == k ? 1 : 0);
	}
	else return 0;
}
int main() {
	int m, n;
	cin >> n >> m;
	getchar();
	string s;
	getline(cin, s);

	stringstream ss(s);
	vector<Node*> st;
	while (ss >> s) {
		if (s == "*" || s == "+" || s == "-") {
			Node* r = st.back(); st.pop_back();
			Node* l = st.back(); st.pop_back();
			int op = (s == "+") ? 1 : (s == "-") ? 2 : 3;
			Node* u = new Node(1, op);
			u->l = l;
			u->r = r;
			st.push_back(u);
		}
		else if (s[0] == 'x') {
			int idx = stoi(s.substr(1));
			st.push_back(new Node(2, idx));
		}
		else {
			ll c = stoll(s);
			st.push_back(new Node(3, c));
		}
	}
	Node* root = st.back();

	while (m--) {
		int k;
		cin >> k;
		for (int i = 1; i <= n; i++) cin >> pot[i];
		cout << (qiudao(root, k) % N + N) % N << "\n";
	}

	return 0;
}
```





