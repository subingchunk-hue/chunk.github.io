---
title: 数组操作几兄弟
date: 2025-09-18 7:17:00
tags: [编程，竞赛]
categories: [编程]
excerpt: 数组操作核心技巧总结，包括前缀和、差分数组、双指针等常用算法技术。
---

# 数组操作几兄弟

## 核心三兄弟

#### 前缀和

```c++
vector<long long> pre(n+1,0);
for(int i=1;i<=n;i++) pre[i]=pre[i-1]+a[i];
// sum l..r:
long long sum = pre[r]-pre[l-1];
```

#### 后缀和

```c++
vector<long long> suf(n+1,0);
suf[n]=a[n];
for(int i=n-1;i>=1;i--) suf[i]=pre[i+1]+a[i];
// sum l..r:
long long sum = pre[r]-pre[l-1];
```

#### 差分

构造数组使得数组a是构造数组的前缀和数组，即$a[i]=b[1]+b[2]+...+b[i]$

核心操作：将$a[l,r]$全部加上C

```c++
b[l]+=c;
b[r+1]-=c;
```

#### 二维扩展

矩阵版，用于子矩阵求和或子矩阵批量加值（地毯/染色类问题）

差分：给以$(x_1,y_1)$为左上角，$(x_2,y_2)$为右上角的子矩阵中的所有数都加C

```c++
a[x1][y1]+=c; 
a[x1][y2+1]-=c;
a[x2+1][y1]-=c; 
a[x2+1][y2+1]+=c;
// 最后做二维前缀和还原
for(i) for(j) b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
```

#### 前缀积

```c++
p[i]=p[i-1]*a[i];
```

#### 练习题

[模板题](https://www.luogu.com.cn/problem/U97755?utm_source=chatgpt.com#ide)

前缀异或和数组与前缀和数组类似。（卡了一个endl的复杂度，要改成'\n'才能过）

```c++
#include<iostream>
#include<vector>
using namespace std;

int main() {
	using ll = long long;
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int n, m;
	cin >> n >> m;
	vector<int> a(n+1);
	vector<ll> pre(n + 2, 0);
	vector<int> res(n + 2, 0);
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		pre[i] = pre[i-1] + a[i];
		res[i] = res[i-1] ^ a[i];
	}
	for (int i = 1; i <= m; i++) {
		int x, y, z;
		cin >> x >> y >> z;
		if (x == 1) cout << (pre[z] - pre[y - 1]) << '\n';
		if (x == 2) cout << (res[z] ^ res[y - 1]) << '\n';
	}

	return 0;
}
```

[差分](https://www.acwing.com/problem/content/description/799/)

```c++
#include<iostream>
#include<vector>
using namespace std;

int main() {

	int n, m;
	cin >> n >> m;
	vector<int> a(n + 1, 0), b(n + 1, 0);
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		b[i] = a[i] - a[i - 1];
	}
	while (m--) {
		int l, r, c;
		cin >> l >> r >> c;
		b[l] += c;
		b[r + 1] -= c;
	}
	for (int i = 1; i <= n; i++) a[i] = a[i - 1] + b[i];
	for (int i = 1; i <= n; i++) cout << a[i] << " ";
	return 0;
}
```

[差分矩阵](https://www.acwing.com/problem/content/description/800/)

```c++
#include<iostream>
#include<vector>
using namespace std;

int main() {
	ios::sync_with_stdio(0); cin.tie(0);
	int n, m, q;
	cin >> n >> m >> q;
	vector<vector<int>> a(n + 5, vector<int>(m + 5, 0));
	vector<vector<int>> b(n + 5, vector<int>(m + 5, 0));
	for(int i=1;i<=n;i++)
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
			b[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
		}
	while (q--) {
		int x1, y1, x2, y2, c;
		cin >> x1 >> y1 >> x2 >> y2 >> c;
		b[x1][y1] += c;
		b[x2 + 1][y1] -= c;
		b[x1][y2 + 1] -= c;
		b[x2 + 1][y2 + 1] += c;
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + b[i][j];
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++)
			cout << a[i][j] << " ";
		cout << endl;
	}
	return 0;
}
```

[k倍区间](https://www.acwing.com/problem/content/description/1232/)

如果只用前缀和数组判断倍数，会TLE。

若存在某连续区间$[i,j]$的和为k的倍数，则有$pre[j]-pre[i-1]≡0(mod$ $ m)$ ，

变形可得$pre[i]≡pre[i-1]$(mod $ m)$，即在前缀和数组里模m相同的两点之间区间满足题意。

---

！！！若存在$pre[i]≡0$$(mod $ m)，则我们可以取$[1,i]$，前面所有的相加模m是为0的，考虑到这种情况，我们设定res[0]=1。

---

```c++
#include<iostream>
#include<vector>
using namespace std;

int main(){
    using ll=long long ;
    int n,k;
    cin >> n >> k;
    vector<int> arr(n+1,0);
    vector<int> pre(n+1,0);
    vector<ll> res(k+1,0);
    res[0]=1;
    for(int i=1;i<=n;i++) {
        cin >> arr[i];
        pre[i]=(pre[i-1]+arr[i])%k;
        res[pre[i]]++;
    }
    ll ans=0;
    for(int i=0;i<k;i++){
        ans+=(res[i]-1)*res[i]/2;
    }
    cout << ans;
    return 0;
}
```

[Subsequences Summing to Sevens S](https://www.luogu.com.cn/problem/P3131#ide)

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
using pii = pair<int, int>;
int main() {
    int n;
    cin >> n;
    vector<int> arr(n + 1, 0);
    vector<int> pre(n + 1, 0);
    vector<pii> p(7);
    pre[0] = 1;
    for (int i = 0; i < 7; i++)p[i] = { n+1,0 };
    p[1] = { 0 ,0 };   //相当于上面的res[0]=1
    for (int i = 1; i <= n; i++) {
        cin >> arr[i];
        pre[i] = (pre[i - 1] + arr[i]) % 7;
        p[pre[i]].first = min(p[pre[i]].first, i);
        p[pre[i]].second = max(p[pre[i]].second, i);
    }
    int ans = 0;
    for (int i = 0; i < 7; i++) {
        ans = max(ans, p[i].second - p[i].first);
    }
    cout << ans;
    return 0;
}
```

[统计子矩阵](https://www.acwing.com/problem/content/description/4408/)

不能单纯的用二维前缀和数组，子矩阵的位置至少要四个变量才能确定——矩阵的大小以及右下角位置。

考虑用双指针，矩阵的宽度由枚举i、j决定，而高度用p、q指针滑动。

```c++
#include<iostream>
#include<vector>
using namespace std;
using ll = long long;

int main() {

    int n, m;
    ll k;
    cin >> n >> m >> k;
    vector<vector<int>> arr(n + 1, vector<int>(m + 1, 0));
    vector<vector<ll>> pre(n + 1, vector<ll>(m + 1));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> arr[i][j];
            pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + arr[i][j];
        }
    }
    ll ans = 0;
    for (int i = 1; i <= m; i++)
        for (int j = i; j <= m; j++) {
            for (int p = 1, q = 1; p <= q && q <= n; q++) {
                while (p <= q && (pre[q][j] - pre[q][i - 1] - pre[p - 1][j] + pre[p - 1][i - 1]) > k) p++;
                if (p <= q) ans += (q - p + 1);
            }
        }
    cout << ans;

    return 0;
}
```

#### 综合算法题

[最大加权矩形](https://www.luogu.com.cn/problem/P1719#ide)

前提知识：如果求一维数组中连续和的最大值——$dp[i]=max(dp[i-1]+a[i],a[i])$ 只需要考虑当前$a[i]$是否加入该连续和

此题将一维数组变为矩阵，我们考虑将二维前缀和数组转化为一维前缀和。

> 转化方法：固定子矩阵的上下边界（s、t），只需计算该边界内每一列的前缀和。

```c++
#include<iostream>
#include<vector>
#include<climits>
#include<algorithm>
using namespace std;

int main() {

	int n;
	cin >> n;
	vector<vector<int>> pre(n + 1, vector<int>(n + 1, 0));
	for(int i=1;i<=n;i++)
		for (int j = 1; j <= n; j++) {
			int num;
			cin >> num;
			pre[i][j] = num - pre[i - 1][j] - pre[i][j - 1] + pre[i - 1][j - 1];
		}

	int ans = INT_MIN;
############################################################################################################
	for (int s = 1; s <= n; s++) {
		for (int t = s; t <= n; t++) {
			vector<int> col(n + 1, 0);
			for (int i = 1; i <= n; i++) col[i] = pre[t][i] - pre[s - 1][i] - pre[t][i - 1] + pre[s - 1][i - 1];
			vector<int> dp(n + 1, 0);
			dp[1] = col[1];
			ans = max(ans, col[1]);
			for (int i = 2; i <= n; i++) {
				dp[i] = max(dp[i - 1] + col[i], col[i]);
				ans = max(ans, dp[i]);
			}
		}
	}
###########################################################################################################
	cout << ans;

	return 0;
}
```

[棋盘](https://www.acwing.com/problem/content/5399/)

取反——模2的前缀和

```c++
#include<iostream>
#include<vector>
using namespace std;

int main() {
	int n, m;
	cin >> n >> m;
	vector<vector<int>> b(n + 5, vector<int>(n + 5, 0)); //初始时全为白子，a数组都是一样的，差分数组全为0
	while (m--) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		b[x1][y1] += 1;
		b[x1][y2 + 1] -=1;
		b[x2 + 1][y1] -=1;
		b[x2 + 1][y2 + 1]+= 1;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + b[i][j];
			cout << b[i][j]%2;
		}
		cout << endl;
	}
	return 0;
}
```

[重新排序](https://www.acwing.com/problem/content/description/4658/)

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
using ll = long long;
int main() {
	int n;
	cin >> n;
	vector<ll> a(n + 1, 0);
	vector<ll> b(n + 5, 0);
	for (int i = 1; i <= n; i++) cin >> a[i];
	int m;
	cin >> m;
	while (m--) {
		int l, r;
		cin >> l >> r;
		b[l] += 1;
		b[r + 1] -= 1;
	}
	ll sum1 = 0;
	for (int i = 1; i <= n; i++) b[i] += b[i - 1];
	for (int i = 1; i <= n; i++) sum1 += a[i] * b[i];
	sort(a.begin() + 1, a.end());
	sort(b.begin() + 1, b.begin()+n+1);
	ll sum2 = 0;
	for (int i = 1; i <= n; i++) sum2 += a[i] * b[i];
	cout << sum2 - sum1;
	return 0;
}
```

