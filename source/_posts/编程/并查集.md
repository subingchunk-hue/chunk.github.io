---
title: 并查集
date: 2025-09-25 8:49:00
tags: [编程，竞赛]
categories: [编程]
excerpt: 并查集数据结构详解，支持高效的合并和查询操作，常用于解决连通性问题。
---

### 基础入门

支持合并和查询。

```c++
class UnionFind {
public:
	vector<int> fa;
	UnionFind(int num) {
		for (int i = 0; i < num; i++) {
			fa.push_back(i);   
		}
	}
	int find(int n) {
		if (fa[n] == n) return n;
		return find(fa[n]);
	}
	void merge(int a, int b) {
		int fa1 = find(a), fa2 = find(b);
		fa[fa1] = fa2;
	}
    bool connected(int x, int y){
		return find(x)==find(y);
    }
};
```

#### [亲戚](https://www.luogu.com.cn/problem/P1551)

直接套模板

```c++
#include<iostream>
#include<vector>
using namespace std;
class UnionFind{
public:
    vector<int> fa;
    UnionFind(int num){
        for(int i=0;i<num;i++) fa.push_back(i);
    }
    int find(int a){
        if(fa[a]==a) return a;
        return find(fa[a]);
    }
    void merge(int a, int b){
        fa[find(a)]=find(b);
    }
    bool connected(int a, int b){
        return find(a)==find(b);
    }
};
int main(){
    int n,m,p;
    cin >> n >> m >> p;
    UnionFind t(n);
    for(int i=0;i<m;i++){
        int a,b;
        cin >> a >> b;
        t.merge(a-1,b-1);  //并查集里存储点的时候从0开始，要-1
    }
    while(p--){
        int a,b;
        cin >> a >> b;
        if(t.connected(a-1,b-1)) cout << "Yes" << endl;
        else cout << "No" << endl;
    }
    return 0;
}
```

### 优化

当数据量较大时，需要对并查集进行优化——路径压缩+按秩合并

```c++
class UnionFind{
public:
    vector<int> fa;
    vector<int> rank; //秩（树的高度）
    int count; //联通分量个数
    UnionFind(int num):count(num){
        rank.resize(n,0);
        for(int i=1;i<=num;i++) fa.push_back(i);
    }
    int find(int a){
        if(fa[a]!=a) fa[a]=find(fa[a]);
        return fa[a];
    }
    void merge(int a, int b){
        int root_a=find(a),root_b=find(b);
        if(root_a==root_b) return;
        //按秩合并，小树合并到大树——减少赋值操作
        if(rank[root_a]<rank[root_b]) fa[root_a]=root_b;
        else if(rank[root_a]>rank[root_b]) fa[root_b]=root_a;
        else {
            fa[root_b]=root_a;
            rank[root_a]++;
        }
        count--;
    }
    bool connected(int a, int b){
        return find(a)==find(b);
    }
    int getcount(){
        return count;
    }
};
```

[并查集](https://www.luogu.com.cn/problem/P3367#ide)

```c++
#include<iostream>
#include<vector>
using namespace std;
struct UnionFind{
public:
    vector<int> fa;
    vector<int> rank;
    int count;
    UnionFind(int num):count(num){
        for(int i=0;i<num;i++) fa.push_back(i);
        rank.resize(num,0);
    }
    int find(int a){
        if(fa[a]!=a) fa[a]=find(fa[a]);
        return fa[a];
    }
    void merge(int a, int b){
        int root_a=find(a),root_b=find(b);
        if(root_a==root_b) return;
        if(rank[root_a]<rank[root_b]) fa[root_a]=root_b;
        else if(rank[root_a]>rank[root_b]) fa[root_b]=root_a;
        else {
            fa[root_b]=root_a;
            rank[root_a]++;
        }
        count--;
    }
    bool connected(int a, int b){
        return find(a)==find(b);
    }
};
int main(){
    int n,m;
    cin >> n >> m;
    UnionFind a(n);
    while(m--){
        int z,x,y;
        cin >> z >> x >> y;
        if(z==1){
            a.merge(x-1,y-1);
        }
        else if(z==2){
            if(a.connected(x-1,y-1)) cout << "Y" << endl;
            else cout << "N" << endl;
        }
    }
    return 0;
}
```

### 实际应用

##### 统计连通分量

[村村通](https://www.luogu.com.cn/problem/P1536)

数据范围不大，不需要按秩优化

```c++
#include<iostream>
#include<vector>
using namespace std;
class UnionFind{
public:
    vector<int> fa;
    int count;
    UnionFind(int num):count(num){
        for(int i=0;i<num;i++) fa.push_back(i);
    }
    int find(int a){
        if(fa[a]==a) return a;
        return find(fa[a]);
    }
    void merge(int a, int b){
        if(find(a)!=find(b)) {
            fa[find(a)]=find(b);
            count--;
        }
    }
    bool connected(int a, int b){
        return find(a)==find(b);
    }
    int getcount(){
        return count;
    }
};
int main(){
    int n,m;
    while(cin >> n >> m){
        UnionFind a(n);
        for(int i=0;i<m;i++){
            int x,y;
            cin >> x >> y;
            a.merge(x-1,y-1);
        }
        cout << a.getcount()-1 << endl;
    }
    return 0;
}
```

##### 反向处理删除

正向删除困难，反向添加容易

1. 记录要删除的点
2. 从最终状态开始，逆向添加点
3. 统计每个阶段的连通分量

[星球大战](https://www.luogu.com.cn/problem/P1197#ide)

耶耶耶~写了半天总算过啦。

删除节点不好操作，我们先标记被删除的点，统计最终状态的连通块数目，然后逆序添加被删除的点，再分别统计连通块数目。

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct UnionFind{
public:
    vector<int> fa;
    vector<int> rank;
    int count;
    UnionFind(int num){
        for(int i=0;i<num;i++) fa.push_back(i);
        rank.resize(num,0);
        count=num;
    }
    int find(int a){
        if(fa[a]!=a) fa[a]=find(fa[a]);
        return fa[a];
    }
    void merge(int a, int b){
        int root_a=find(a),root_b=find(b);
        if(root_a==root_b) return;

        if(rank[root_a]<rank[root_b]) fa[root_a]=root_b;
        else if(rank[root_a]>rank[root_b]) fa[root_b]=root_a;
        else{
            fa[root_b]=root_a;
            rank[root_a]++;
        }
        count--;
    }
    bool connected(int a, int b){
        return find(a)==find(b);
    }
    int getcount(){
        return count;
    }
};
int main(){
    int n,m;
    cin >> n >> m;
    vector<vector<int>> adj(n);
    for(int i=0;i<m;i++){
        int x,y;
        cin >> x >> y;
        adj[x].push_back(y);
        adj[y].push_back(x);
    }
    int k;
    cin >> k;
    vector<int> de(k);
    vector<bool> flag(n,true);
    for(int i=0;i<k;i++){
        cin >> de[i];
        flag[de[i]] =false;
    }
    UnionFind a(n);
    for(int i=0;i<n;i++){
        if(!flag[i]) continue;
        for(int j:adj[i]) 
            if(flag[j]) a.merge(i,j);
    }
    vector<int> ans(k+1,0);
    ans[k]=a.getcount()-k;    //此时是最终状态的连通块数目，要减去k个删除的点
    for(int i=k-1;i>=0;i--){
        flag[de[i]]=true;
        for(int j:adj[de[i]]){
            if(flag[j])a.merge(de[i],j);
        }
        ans[i]=a.getcount()-i;  //减去i个删除的点
    }
    for(int i=0;i<=k;i++) cout << ans[i] << endl;
    return 0;
}
```

##### 种类并查集（扩展域并查集）

处理元素之间有多种关系，比方说A吃B，A打C这种。

核心思想：把每个元素拆分成多个点，每个点代表该元素处于不同的“角色”或者“状态”

例子：朋友or敌人，朋友的朋友是朋友，敌人的敌人是朋友。。。。

每个人都拆成两个点：

- $i$：朋友阵营
- $i+n$：敌人阵营

```c++

```

##### 带权并查集



##### 离散化+并查集



##### 环的检测



##### 隐藏连通关系