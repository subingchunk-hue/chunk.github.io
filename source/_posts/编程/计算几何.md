---
title: 计算几何
date: 2025-09-7 14:25:00
tags: [编程，竞赛]
categories: [编程]
excerpt: 二维计算几何基础知识总结，包括各种核心概念和算法实现。
---
计算几何

4.2 凸包
4.3 半平面交
4.4 最小圆覆盖

4.6 三维凸包
4.7 旋转卡壳
4.8 三角剖分
4.9 扫描线
4.10 自适应辛普森积分



## 二维计算几何基础

### 基础元素的代码表示

##### 点|向量

```c++
struct Point{
	int x,y;
};
```

##### 直线|射线

```c++
斜率式：y=kx+b;
点向式：p+tv  //p为直线上一点，v为方向向量，每一个t对应一个点
```

##### 线段

记录左右端点即可。

##### 多边形

使用数组按一定顺序记录多边形的每个顶点即可。

##### 曲线图形

一些特殊曲线，如函数图像等一般记录其解析式。对于圆，直接记录其圆心和半径即可。

##### 叉积

$\overrightarrow {a} × \overrightarrow {b}=x_1y_2-x_2y_1$

> - 小于0： b在a的右边
> - 大于0： b在a的左边
> - 等于0： a、b共线

```c++
//向量
struct Point{  
	double x,y;
};
double dot(Point a, Point b) { return a.x*b.x + a.y*b.y; }  //点积
double cross(Point a, Point b) { return a.x*b.y - a.y*b.x; } //叉积
double length(Point a) { return sqrt(dot(a,a)); } //长度
```

### 基本公式

1. 正弦定理         $ \begin{aligned} \frac{A}{sinA}=\frac{b}{sinB}+\frac{c}{sinC}\end{aligned} $
2. 余弦定理        

### 基本操作

##### 判断点与直线的位置

已知直线的方向向量$\mathbf{v}$，以及直线上一点P，判断点Q与直线的关系。

计算$\mathbf{v}×\overrightarrow {PQ}$，若向量积为（左右相对于方向向量而言）

- 负：Q在直线右侧
- 正：Q在直线左侧
- 0： Q在直线上

```c++
void on_line(Point p,Point a,Point b){
	Vector v = b - a,u = p - a;   //vector是向量的意思
	if(cross(v,u) == 0)  cout << "on";
	else if(cross(v,u) > 0)  cout << "left";
	else  cout << "left";
}
```

##### 判断两条线段是否相交

1. 斜率相等，两线段平行，则不可能相交；

2. 快速排斥实验：以两线段为对角线的矩形区域若不重叠则一定不相交；

3. 跨立实验：分别判断两条线段的两个端点是否位于另一条线段的两侧；

   ```c++
   bool segment_intersection(Point a1,Point a2,Point b1,Point b2)
   {
   	double c1 = cross(a2 - a1,b1 - a1), c2 = cross(a2 - a1,b2 - a1);
   	double c3 = cross(b2 - b1,a2 - b1), c4 = cross(b2 - b1,a1 - b1);
   	return (c1 * c2 <= 0 && c3 * c4 <= 0);
   }
   ```

##### 判断一点是否在多边形内部

###### 光线投射算法

以该点为端点引出一条射线，如果这条射线与多边形有奇数个交点，则该点在多边形内部，否则该点在多边形外部，我们简记为**奇内偶外**。

###### 回转数算法

把该点与多边形的所有顶点连接起来，计算相邻两边夹角的和。注意这里的夹角是**有方向的**。如果夹角和为0，则这个点在多边形外，否则在多边形内。

##### 求两条直线的交点

先确定两条直线是否平行，若相交则计算交点。

```c++
Point intersection(Point p, Vector v, Point q, Vector w){ //使用点向式表示直线
	Vector u=p-q;
	double t=cross(w,u)/cross(v,w);
	return {p.first+t*v.first, p.second+t*v.second};
}
```

##### 求任意多边形的周长和面积

1. 三角形的面积

   ```c++
   p = (a+b+c) / 2;
   s = sqrt(p * (p-a) * (p-b) * (p-c));
   ```

2. 多边形的面积(鞋带公式)

   任取平面上一点P，多边形面积为（以四边形ABCD为例）：

   $ \begin{aligned} S_{多边形面积}=\frac{\overrightarrow {PA}×\overrightarrow {AB}+\overrightarrow {PB}×\overrightarrow {BC}+\overrightarrow {PC}×\overrightarrow {CD}+\overrightarrow {PD}×\overrightarrow {DA}}{2}\end{aligned} $

   给定一个按顺时针/逆时针顺序排列的多边形顶点序列，$P_0,P_1,...,P_{n}$，本质就是一堆叉积的和（考虑$P_n=P_0$，即构成一个回路）。
   
   ```c++
   double area(vector<Point> p){
   	double area=0;
       for(int i=0;i<=n;i++) area+=cross(p[i],p[i+1]);
       return abs(area)/2.0;
   }
   //在凸包、三角剖分里
   double area(vector<Point> p){
   	double area=0;
       for(int i=0;i<=n-1;i++) area+=cross(p[i]-p[0],p[i+1]-p[0]);
       return abs(area)/2.0;
   }
   ```

##### 圆与直线相关

###### 求直线与圆的交点

首先判断直线与圆的位置关系。如果直线与圆相离则无交点，若相切则可以利用切线求出切点与半径所在直线，之后转化为求两直线交点。

若有两交点，则可以利用勾股定理求出两交点的中点，然后沿直线方向加上半弦长即可。

###### 求两圆交点

首先我们判断一下两个圆的位置关系，如果外离或内含则无交点，如果相切，可以算出两圆心连线的方向向量，然后利用两圆半径计算出平移距离，最后将圆心沿这个方向向量进行平移即可。

如果两圆相交，则必有两个交点，并且关于两圆心连线对称。因此下面只说明一个交点的求法，另一个交点可以用类似方法求出。

我们先将一圆圆心与交点相连，求出两圆心连线与该连线所成角。这样，将两圆心连线的方向向量旋转这个角度，就是圆心与交点相连形成的半径的方向向量了。沿方向向量方向将圆心平移半径长度即可得到一个交点。

##### 极角序

## 三维计算几何基础

##### 三正弦定理

二面角度数为$a$，平面M上有一条射线AC，它和棱AB所成角为$b$，和平面N所成角为$r$，则

$sin r=sina*sinb$

##### 三余弦定理

设O为平面上一点，过平面外一点B的直线BO 在面上的射影为AO，OC为面上的一条直线，那么 $∠COB，∠AOC，∠AOB$三角的余弦关系为$cos∠BOC=cos∠AOB*cos∠AOC$（$∠AOB$和$∠AOC$只能是锐角）

## 常用距离

#### 欧氏距离

[欧式距离 中](https://www.luogu.com.cn/problem/P3958#ide)

#### 曼哈顿距离

$d(A,B)=|x_1-x_2|+|y_1-y_2|$

[曼哈顿距离 易](https://www.luogu.com.cn/problem/P5098#ide)

---

###### 曼哈顿距离最小化问题

给定平面上n个点，找到一个点P，使得所有点到P的曼哈顿距离之和最小。

x方向和y方向分开处理！

- 一维情况：x的中位数
- 二维情况：分别取x、y的中位数组合起来即为所求坐标

变形：

- 必须选给定点之一
  1. 分别对x、y排序并计算前缀和
  2. 遍历所有点计算找到最小距离和（排序后的x、y另开数组存储）
- 加权曼哈顿距离（每个点$i$有权重）——带权中位数
  1. 分别对x、y排序，累加权重直到超过总权重的一半
  2. 当前点就是带权中位数
- 选多个点，使所有点到最近点距离和最小

---

#### 切比雪夫距离

$d(A,B)=max(∣x_1−x_2∣,∣y_1−y_2∣)$

> 点$(x_1,y_1),(x_2,y_2)$的曼哈顿距离 = 点$(x_1+y_1,x_1-y_1),(x_2+y_2,x_2-y_2)$的切比雪夫距离。

> 点$(x_1,y_1),(x_2,y_2)$的切比雪夫距离 = 点$(\frac{x_1+y_1}{2},\frac{x_1-y_1}{2}),(\frac{x_2+y_2}{2},\frac{x_2-y_2}{2})$的曼哈顿距离。

[松鼠聚会](https://www.luogu.com.cn/problem/P3964)

由题意给出的移动方式，我们发现其对应的移动距离就是切比雪夫距离，而切比雪夫距离很难直接处理，我们考虑通过坐标变换将它变成更熟悉的曼哈顿距离。

即只需将题目给的坐标进行变换，然后在这些点中找一个使其他点到它的距离之和最小。

主要就是注意一下计算距离和的时候要分左右（绝对值）。

```c++
#include <iostream>
#include<vector>
#include<algorithm>
#include<climits>
using namespace std;
using ll=long long;
typedef pair<ll,ll> pii;
int main(){
    int n;
    cin >> n;
    vector<ll> x0(n+1,0),y0(n+1,0);
    vector<ll> x(n+1,0),y(n+1,0);
    vector<ll> pre_x(n+1,0),pre_y(n+1,0);
    for(int i=1;i<=n;i++) {
        ll s,t;
        cin >> s >> t;
        x0[i]=s+t;
        y0[i]=s-t;
        x[i]=s+t;
        y[i]=s-t;
    }
    sort(x.begin()+1,x.end());
    sort(y.begin()+1,y.end());
    for(int i=1;i<=n;i++){
        pre_x[i]=pre_x[i-1]+x[i];
        pre_y[i]=pre_y[i-1]+y[i];
    }
    ll ans=LLONG_MAX;
    for(int i=1;i<=n;i++){
        auto it_x=lower_bound(x.begin()+1,x.begin()+n+1,x0[i]);
        auto it_y=lower_bound(y.begin()+1,y.begin()+n+1,y0[i]);
        int pos_x=it_x-x.begin();
        int pos_y=it_y-y.begin();

        ll sum_x = (pos_x-1) * x0[i] - pre_x[pos_x-1] + pre_x[n] - pre_x[pos_x] - (n-pos_x)*x0[i];
        ll sum_y = (pos_y-1) * y0[i] - pre_y[pos_y-1] + pre_y[n] - pre_y[pos_y] - (n-pos_y)*y0[i];

        ans=min(ans,sum_x+sum_y);
    }
    cout << ans/2 << endl;
    return 0;
}
```

[pairs 动物对数](https://www.luogu.com.cn/problem/P4648)

（有点复杂，后续补）

#### 闵可夫斯基距离

## Pick定理

给定顶点均为整点的简单多边形，其面积$A$和内部格点数目$i$、边上格点数目$b$的关系：$A=i+\frac{b}{2}-1$

##### 例题

>  在直角坐标系中，一个机器人从任意点出发进行$n$次移动，每次向右移动 $𝑑𝑥$，向上移动 $dy$，最后会形成一个平面上的封闭简单多边形，求边上的点的数量，多边形内的点的数量，多边形面积。

给定n+1个向量（每次移动都是一个向量），其中$p_0=(0,0),p_1=p_0+(dx_1,dy_1),...,p_n=p_0$

总边界点数：$B=∑gcd⁡(∣dx_i∣,∣dy_i∣)$，

多边形面积：$A=\frac{|∑(x_iy_{i+1}-x_{i+1}y_i)|}{2}$（鞋带公式）

多边形内部点个数（pick定理）

```c++
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;

struct Point{
    int x,y;
};

int gcd(int a,int b){
    a = abs(a);
    b = abs(b);
    return b==0?a:gcd(b,a%b);
}

int main(){
    int n;
    cin >> n;
    vector<Point> p(n+1);
    vector<Point> m(n+1); 
    
    p[0] = {0,0};
    for(int i=1;i<=n;i++){
        int a,b;
        cin >> a >> b;
        p[i].x = p[i-1].x + a;
        p[i].y = p[i-1].y + b;
        m[i].x = a;
        m[i].y = b;
    }
    
    // 1. 求边上点的个数 B
    int B = 0;
    for(int i=1;i<=n;i++) 
        B += gcd(m[i].x, m[i].y);
    
    // 2. 求多边形的面积 A（鞋带公式）
    long long area2 = 0; 
    p[n] = p[0];
    for(int i=0;i<n;i++) 
        area2 += (long long)p[i].x * p[i+1].y - (long long)p[i+1].x * p[i].y;
    area2 = abs(area2);
    double area = area2 / 2.0;
    // 3. 用 pick 定理求内部点数 I
    int I = (area2 - B) / 2 + 1;
    
    cout << B << endl << I << endl << area << endl;
    return 0;
}
```

## 三角剖分

$DT$：二维几何中的完美三角剖分

###### 构造DT的分治算法

1. 将定点集按照x坐标升序排列；
2. 点集有序之后，按照分治将其不断分成两个部分，直到子点集大小不超过3，这些子点集是三角形或线段；

## 凸包

凸包：在平面上能包含所有给定点的最小凸多边形（所有内角大小都在[0,𝜋]之前）。

理解为用一个橡皮筋包含住所有给定点的形态，用最小的周长。

包含：可以在橡皮筋上，也可以在橡皮筋围住区域里面（凸多边形在周长上一定是最优的）。

#### 二维凸包

###### Andrew 算法求凸包（常用）

$o(nlogn)$，n为待求凸包点集的大小。

1. 把所有点以横坐标为第一关键字，纵坐标为第二关键字排序；
2. 用一个单调栈来维护上下凸壳

###### Graham 扫描法

1. 找到所有点中纵坐标最小的点P，该点一定在凸包上；
2. 将所有点以相对于点P的极角大小为关键字进行排序；
3. 从点P出发在凸包上逆时针走，所有经过的点一定是左拐的，就是说连续经过的三个点一定满足内积大于等于0；

新建栈用于存储凸包的信息，先将P压入栈中，然后按照极角序依次尝试加入每一个点。如果右拐了就弹出栈顶，不断重复该过程直至栈中只剩下一个元素。

如果坐标是浮点数，最好加入一个eps，在去重和判断cross时用eps。

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Point {
    ll x, y;
};

// cross product (b - a) x (c - a)
ll cross(const Point& a, const Point& b, const Point& c) {
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

ll dist2(const Point& a, const Point& b) {
    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

// ------------------ Andrew (Monotonic Chain) ------------------
vector<Point> Andrew(vector<Point> pts) {
    //检查边界情况
    if (pts.size() <= 1) return pts;
    sort(pts.begin(), pts.end());

    //去重
    pts.erase(unique(pts.begin(), pts.end()), pts.end());
    if (pts.size() <= 1) return pts;

    //1.扫描加入下凸壳
    vector<Point> lower, upper;
    for (const Point& p : pts) {
        while (lower.size() >= 2 && cross(lower[lower.size()-2], lower.back(), p) <= 0)
            lower.pop_back();
        lower.push_back(p);
    }
    /*
    for(int i=0;i<p.size();i++){
        while(lower.size()>=2&&cross(p[i-2],p[i-1],p[i])<=0) lower.pop_back();
        lower.push_back(p[i]);
    }
    */

    //2.上凸壳
    for (int i = (int)pts.size() - 1; i >= 0; --i) {
        const Point& p = pts[i];
        while (upper.size() >= 2 && cross(upper[upper.size()-2], upper.back(), p) <= 0)
            upper.pop_back();
        upper.push_back(p);
    }

    //3.去头去尾然后合并
    lower.pop_back();
    upper.pop_back(); 
    vector<Point> hull;
    hull.reserve(lower.size() + upper.size());
    for (auto &p : lower) hull.push_back(p);
    for (auto &p : upper) hull.push_back(p);

    return hull;
}

// ------------------ Graham Scan ------------------
vector<Point> Graham(vector<Point> pts) {
    if (pts.size() <= 1) return pts;
    sort(pts.begin(), pts.end());
    pts.erase(unique(pts.begin(), pts.end()), pts.end());
    if (pts.size() <= 1) return pts;

    int pivot_idx = 0;
    for (int i = 1; i < (int)pts.size(); ++i) {
        if (pts[i].y < pts[pivot_idx].y || (pts[i].y == pts[pivot_idx].y && pts[i].x < pts[pivot_idx].x))
            pivot_idx = i;
    }
    swap(pts[0], pts[pivot_idx]);
    Point p0 = pts[0];

    sort(pts.begin() + 1, pts.end(), [p0](const Point& a, const Point& b) {
        ll c = cross(p0, a, b);
        if (c != 0) return c > 0;
        return dist2(a, p0) < dist2(b, p0);
    });

    vector<Point> st;
    st.push_back(pts[0]);
    st.push_back(pts[1]);

    for (int i = 2; i < (int)pts.size(); ++i) {
        while (st.size() >= 2 && cross(st[st.size()-2], st.back(), pts[i]) <= 0)
            st.pop_back();
        st.push_back(pts[i]);
    }

    return st;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n;
    cin >> n;
    vector<Point> pts;
    pts.reserve(n);
    for (int i = 0; i < n; ++i) {
        ll x, y; cin >> x >> y;
        pts.emplace_back(x, y);
    }

    vector<Point> hull = Andrew(pts);
    // vector<Point> hull = Graham(pts);

    cout << hull.size() << '\n';
    for (auto &p : hull) cout << p.x << ' ' << p.y << '\n';
    return 0;
}
```

#### 闵科夫斯基和

点集P和点集Q的闵可夫斯基和$P+Q=\{a+b|a∈P,b∈Q\}$，即把P中的每一个点和Q中的每一个点相加，得到一个新的点集。

几何意义：把Q平移到P的每个点上，扫出来的区域。（凸包+凸包=凸包）

- 判断两个凸多边形是否相交

  算出$C=A⊕(-B)$，若原点在C里面，则两个凸多边形相交。

- 膨胀、偏移

核心思想：

1. 把两个凸多边形按逆时针顺序存好；
2. 从各自的最左下角点开始把边向量（当前顶点-前一个顶点）逐个合并。

```c++
struct Point {
  long long x, y;

  friend Point operator+(const Point &a, const Point &b) {
    return {a.x + b.x, a.y + b.y};
  }

  friend Point operator-(const Point &a, const Point &b) {
    return {a.x - b.x, a.y - b.y};
  }

  friend long long operator^(const Point &a, const Point &b) {
    return a.x * b.y - a.y * b.x;
  }
};

bool cmp(const Point &a, const Point &b) {
    return (a ^ b) < 0;  
}

vector<Point> minkowski_sum(vector<Point> a, vector<Point> b) {
  vector<Point> c{a[0] + b[0]};
  for (int i = 0; i + 1 < a.size(); ++i) a[i] = a[i + 1] - a[i];
  for (int i = 0; i + 1 < b.size(); ++i) b[i] = b[i + 1] - b[i];
  a.pop_back(); 
  b.pop_back();
  c.resize(a.size() + b.size() + 1);
  merge(a.begin(), a.end(), b.begin(), b.end(), c.begin() + 1, cmp);
  for (int i = 1; i < c.size(); ++i) c[i] = c[i] + c[i - 1];
  return c;
}
```

#### 三维凸包

1. 对其微小扰动，避免出现四点共面的情况；

   给点坐标加上一个极小的随机数（$ep=1e-9$），扰动量足够小不会影响最终结果

2. 对于已知的凸包，增加一个新点，只要判断它是否能看到当前凸包的某些面，如果可以则删去该点；

   see函数：判断该点是否在面的法向量方向，即判断点积是否小于0.

3. 重复步骤2直到所有点加入。

```c++
#include <bits/stdc++.h>
using namespace std;

constexpr int N = 2010;
constexpr double eps = 1e-9;

int n;              // 点数
double ans;         // 表面积

struct Point3D {
    double x, y, z;

    // 向量减法
    Point3D operator-(const Point3D &b) const {
        return {x-b.x, y-b.y, z-b.z};
    }

    // 叉积
    Point3D cross(const Point3D &b) const {
        return {y*b.z - z*b.y, z*b.x - x*b.z, x*b.y - y*b.x};
    }

    // 点积
    double dot(const Point3D &b) const {
        return x*b.x + y*b.y + z*b.z;
    }

    // 向量长度
    double len() const {
        return sqrt(x*x + y*y + z*z);
    }

    // 随机扰动，避免共面
    void shake() {
        double r = ((rand() / (double)RAND_MAX) - 0.5) * eps;
        x += r; y += r; z += r;
    }
} P[N];

struct Face {
    int v[3]; // 顶点索引

    // 法向量
    Point3D Normal() const {
        return (P[v[1]] - P[v[0]]).cross(P[v[2]] - P[v[0]]);
    }

    // 面积
    double area() const {
        return Normal().len() / 2.0;
    }
};

// 判断点 b 是否在面 a 外侧
bool see(const Face &a, const Point3D &b) {
    return ((b - P[a.v[0]]).dot(a.Normal())) > 0;
}

// 三维凸包增量法
vector<Face> ConvexHull3D(int n) {
    vector<Face> f, C;
    int vis[N][N] = {0};  //存有向边的状态（是否可见）

    // 初始化两个面（前三个点）
    f.push_back({{0,1,2}});
    f.push_back({{2,1,0}});

    for(int i=3;i<n;i++){
        C.clear();
        memset(vis,0,sizeof(vis));

        // 标记可见面
        for(auto &face:f){
            bool v = see(face, P[i]); //v=1 可见
            if(!v) C.push_back(face);
				
            //每个面有三个顶点，最后必须要回到第0个点
            for(int k=0;k<3;k++)
                vis[face.v[k]][face.v[(k+1)%3]] = v; 
        }

        // 构造新面
        for(auto &face:f){
            for(int k=0;k<3;k++){
                int x = face.v[k], y = face.v[(k+1)%3];
                if(vis[x][y] && !vis[y][x])
                    C.push_back({{x,y,i}}); //(x->y)属于可见面
            }
        }

        f = C; // 更新凸包
    }

    return f;
}

int main() {
    cin >> n;
    for(int i=0;i<n;i++) {
        cin >> P[i].x >> P[i].y >> P[i].z;
        P[i].shake(); // 避免共面
    }

    vector<Face> hull = ConvexHull3D(n);

    ans = 0;
    for(auto &face:hull) ans += face.area();

    cout << fixed << setprecision(3) << ans << "\n";
    return 0;
}
```

---

## 练习题

[最大土地面积](https://www.luogu.com.cn/problem/P4166#ide)

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <cmath>
using namespace std;

struct point {
    double x, y;
    bool operator<(const point &p) const {
        return x < p.x || (x == p.x && y < p.y);
    }
    bool operator==(const point &p) const {
        return fabs(x - p.x) < 1e-9 && fabs(y - p.y) < 1e-9;
    }
};

// 叉积
double cross(point a, point b, point c) {
    return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x);
}

// Andrew 算法生成凸包
vector<point> Andrew(vector<point> p) {
    if(p.size() <= 1) return p;
    sort(p.begin(), p.end());
    p.erase(unique(p.begin(), p.end()), p.end());
    if(p.size() <= 1) return p;

    vector<point> lower, upper;

    for(int i = 0; i < p.size(); i++) {
        while(lower.size() >= 2 && cross(lower[lower.size()-2], lower.back(), p[i]) <= 0)
            lower.pop_back();
        lower.push_back(p[i]);
    }

    for(int i = p.size() - 1; i >= 0; i--) {
        while(upper.size() >= 2 && cross(upper[upper.size()-2], upper.back(), p[i]) <= 0)
            upper.pop_back();
        upper.push_back(p[i]);
    }

    lower.pop_back();
    upper.pop_back();

    vector<point> hull = lower;
    hull.insert(hull.end(), upper.begin(), upper.end());

    return hull;
}

// 计算三角形面积
double area(point a, point b, point c) {
    return fabs(cross(a, b, c)) / 2.0;
}

int main() {
    int n;
    cin >> n;
    vector<point> p(n);
    for(int i = 0; i < n; i++) cin >> p[i].x >> p[i].y;

    vector<point> hull = Andrew(p);
    int m = hull.size();

    if(m < 4) {
        cout << "0.000\n";
        return 0;
    }

    double ans = 0;
    // 枚举 i, j 作为两点，找两边最大面积三角形
    for(int i = 0; i < m; i++) {
        for(int j = i + 1; j < m; j++) {
            double max1 = 0, max2 = 0;
            // i+1 到 j-1
            for(int k = i + 1; k < j; k++) max1 = max(max1, area(hull[i], hull[j], hull[k]));
            // j+1 到 i+m-1 (绕回去)
            for(int k = j + 1; k < i + m; k++) max2 = max(max2, area(hull[i], hull[j], hull[k % m]));
            ans = max(ans, max1 + max2);
        }
    }

    cout << fixed << setprecision(3) << ans << "\n";
    return 0;
}
```

[信用卡凸包](https://www.luogu.com.cn/problem/P3829)

[保护出题人](https://www.luogu.com.cn/problem/P3299)

---

