---
title: 数论
date: 2025-08-25 14:07:00
tags: [编程，竞赛]
categories: [编程]
excerpt: 数论算法总结，包括大指数幂计算、最大公约数、素数判断、欧拉函数等核心数论知识。
---

### 大指数幂的相关计算

大整数：__ int128

$$a^b$$：快速幂，将b化为二进制表示，$$b=b_1+b_2+……+b_n$$，则$$a^b=a^{b_1}*a^{b_2}*...*a^{b_n}$$

```c++
long long cal(long long a,long long b){
	long long ans=1;
    while(b){
		if(b&1) res=res*a;
        a=a*a;
        b>>=1;
    }
    return ans;
}
```

$a(mod$ $m),a\le10^{100}$：大整数取模

$(a+b)$ $(mod)$ $m=(a(mod$ $m)+b(mod$ $m))mod$ $m$ 

对于大整数$a$，可以化作：$a=(((a_0*10+a_1)*10+a_2)*10+……)$

```c++
long long cal(string s, long long m){
	long long ans=0;
    for(int i=0;i<s.length();i++)
        ans=((ans*10)+s[i])%m;
    return ans;
}
```

$a^bmod$ $n$：模重复平方运算法，取模运算不会干涉乘法运算

```c++
long long cal(long long a,long long b,long long n){
    a%=n;
    long long ans=1;
    while(b){
		if(b&1) ans=ans*a%n;
        a=a*a%n;
        b>>=1;
    }
    return ans;
}
```

欧拉定理$$(a,n)=1，a^{φ(n)}modn=1$$，则可知当n为素数时有$$a^bmodp=a^{bmod(p-1)}modp$$

### 乘法逆元的计算

`前提：当gcd(a,m)=1时，逆元存在`

- 当模数为素数时——快速幂+欧拉定理

  $当m是素数且gcd(a,m)=1时，有a^{m-1}≡1(mod$ $m)即$

  $a^{-1}≡a^{m-2}(mod$ $m)$

  ```c++
  long long cal(long long a,long long m){
  	int b=m-2;
      long long ans=1;
      while(b){
  		if(b&1) ans=ans*a%m;
          a=a*a%m;
          b>>=1;
      }
      retur ans;
  }
  ```

- 当模数不为素数时——广义欧几里得算法

  $∃s,t,使s*a+t*m=1,此时s即为a在模m下的逆元$

  ```c++
  int exgcd(int a, int b, int &x, int &y){
      if (!b){
          x = 1; y = 0;
          return a;    //返回的是最大公约数
      }
      int d = exgcd(b, a % b, x, y); 
      int temp=y;   
      y=x-(a/b)*y;
      x=temp;
      return d;   //求出x，y及gcd(a,b)
  }
  long long cal(long a,long m){
      int s,t;
      int d=exgcd(a,m,s,t);
      if(d!=1) return -1;
      else return (x%m+m)%m;
  }
  ```

### 扩展欧几里得算法

应用：

- 判断$a*x+b*y=c$是否有解
- 求出$a*x+b*y=c$的任意一组解，通解及最小解
- 求逆元

1. 扩展欧几里得的写法

   $∃x,y,使x*a+y*b=gcd(a,b),设gcd(a,b)=d,则有x*a+y*b=d$

   `gcd(0,a)=|a|`

   $exgcd(b, a $%$ b, x, y)$调用后我们可以得到：$x*b+y*(a$%$b)=gcd(a,b)=d$，辗转相除求gcd(a,b)

   我们此时对该式子进行变形：
   $$
   x*b+y*(a\%b)=d\\\
   \Rightarrow x*b+y*(a-\left\lfloor \frac{a}{b} \right\rfloor*b)=d\\
   \Rightarrow y*a+(x-\left\lfloor \frac{a}{b} \right\rfloor*y)*b=d
   $$
   则我们所求的x，y即：$x=y,y=x-\left\lfloor \frac{a}{b} \right\rfloor*y$，左边为所求，右边为递归调用函数后的返回值

   ```c++
   int exgcd(int a, int b, int &x, int &y){
       if (!b){
           x = 1; y = 0;
           return a;    //返回的是最大公约数
       }
       int d = exgcd(b, a % b, x, y); 
       int temp=y;   
       y=x-(a/b)*y;
       x=temp;
       return d;   //求出x，y及gcd(a,b)
   }
   ```

2. 对方程$a*x+b*y=c$，若求出$x_0,y_0$是一组解，则通解可写为

   $(x_0+k*b^{'},y-k*a^{'}),其中,a^{'}=a/gcd(a,b),b^{'}=b/gcd(a,b)$

3. 对方程$a*x+b*y=c$，若$gcd(a,b)=d$，且方程$a*x+b*y=d一组解为(x_0,y_0)$：

   - 当c是d的倍数时，一组解为$(x_0*c/d,y_0*c/d)$
   - 当c不是d的倍数时，该方程无整数解

### 最大公约数

辗转相除法

```c++
int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
	//当b=0时，说明b=k*a
}
```

求g的所有正因子

```c++
for(int i=1;i<=g/i;i++)
	if(g%i==0){
		a.push_back(i);
		if(i!=g/i) a.push_back(g/i);
	}
```

当要求多个数的最大公约数时：

```c++


```

### 最小公倍数

$lcm(a,b)=a/gcd(a,b)*b$   先除后乘，避免中间越界

### 素因数的相关结论

- 每个大于1的整数都可以分解为若干素数的乘积$n=p_1^{a_1}*p_2^{a_2}*……*p_k^{a_k}$
- n的约数个数为：$d(n)=(a_1+1)(a_2+1)……(a_k+1)$

```c++
//计算d(n)
ans = 1;          
for(int i=2;i<=n/i;i++){
	int cnt=0;
	while(n%i==0){
		cnt++;
		n/=i;
	}
	if(cnt) ans*=(cnt+1);
}
if(n>1) ans*=2;    //n除到最后，要么是1要么是一个素数（大于1），如果此时n>1，说明上面漏了该素数，ans要乘2
```

- 约数之和  $n=p_1^{a_1}+p_2^{a_2}+……+p_k^{a_k}$

  $a(n)=(1+p_1+p_1^2+……+p_1^{a_1})*……*(1+p_k+p_k^2+……+p_k^{a_k})$

  当$p_i\not= 1时,a(n)=∏\frac{p_i^{a_i+1}-1}{p_i-1}$

  则在模m下：   

  - 若$(p_i-1)mod$ $m=0$时，$1+p_1+p_1^2+……+p_1^{a_1}=1+a_1$

  - 若存在逆元，素因数之和即为

    $∏(p_i^{a_i+1}-1)*(p_i-1)^{-1}mod$ $m=∏(p_i^{a_i+1}-1)*(p_i-1)^{m-2}mod$ $m$

```c++
#include<iostream>
using namespace std;
#include<unordered_map>
typedef long long ll;
const int N=9901;
ll a,b;
unordered_map<int,int> freq;
void cal(){
    for(int i=2;i*i<=a;i++){
        if(a%i==0)
            while(a%i==0){
                freq[i]++;
                a/=i;
            }
    }
    if(a>1) freq[a]++;
}
ll qmi(ll a,ll b){
    ll ans=1;
    while(b){
        if(b&1)ans=ans*a%N;
        a=a*a%N;
        b>>=1;
    }
    return ans;
}
int main(){
    cin >> a >>b;
    if(!a)  {
		cout << 0;
    	return 0;
    }
    cal();
    ll ans=1;
    for(auto it:freq){
        int q=it.first,k=it.second*b;
        if((q-1)%N==0) ans=ans*(k+1)%N;
        else {
            ans=ans*(qmi(q,k+1)-1)%N*qmi(q-1,N-2)%N;
        }
    }
    cout << (ans+N)%N;
    return 0;
}
```

- n的约数之积为：$n^{d(n)/2}$
- 若一个数是完全平方数，则$d(n)$是奇数

```c++
//计算不同素因数的个数
int count=0;
for(int i=2;i<=n/i;i++){
	if(n%i==0){
		count++;
        while(n%i==0) n/=i;      //除去相同的素因数
    }
}

//线性筛法求所有的素因数
prime[N] ------ 存入1~n的所有素数
st[N] ------ 标记素数(false为素数)  默认为false
for(int i=2;i<=n;i++){            //从2开始遍历1~n
	if(!st[i])  prime[cnt++]=i;   //标记是素数
    for(int j=0;prime[j]*i<=n;j++){  //访问素数表中所有的素数
		st[i*prime[j]]=true;     //素数的倍数一定是合数
        if(i%prime[j]==0) break; //此时prime[j]是i的最小素数，剪枝，避免重复筛除
    }
}
-----
int main(){
    for(int i=0;i<cnt;i++){
		int p=prime[i];
        int s=0;
        for(int j=n;j;j/=p) s+=j/p;
        cout << p << s << endl;
    }
}
```

### 欧拉函数

求某个数的欧拉函数，将数n拆成素数的乘积，则

$$φ(n)=n*(1-\frac{1}{p_1})*……*(1-\frac{1}{p_m})$$

```c++
int fun(int n){
	int res=n;
    for(int i=2;i*i<=n;i++)
        if(n%i==0){
			res-=res/i;    //乘 (1-1/p)
            while(n%i==0) n/=i;
        }
    if(n>1) res-=res/n;
    return res;
}
```

线性筛法求1~n的欧拉函数值

```c++
int f[N];           //存储欧拉函数值
bool visited[N];    //标记该数是否被访问
vector<int> prime;  //存储素数
void fun(int n){
	f[1]=1;
	for(int i=2;i<=n;i++){
		if(!visited[i]){
			prime.push_back(i);
            f[i]=i-1;
        }
        for(int p:prime){
			if(p*i>n) break;
            visited[p*i]=true;
            if(i%p==0){
				f[p*i]=f[i]*p;
                break;
            }else{
				f[p*i]=f[i]*(p-1);
            }
        }
    }
}
```

### 求同余方程式的解

$ax≡b(modm)$的解，一定满足$ax-b$是m的整数倍即$ax-b=k*m$，转化为求该一次方程的解$x与k$

### 组合计数（求C(n,k)）

$C(n,k)=\frac{n!}{k!(n-k)!}$ 在模m下时，即为$n!*(k!)^{-1}*((n-k)!)^{-1}mod$ $m$（分母的模即为其逆元）

```c++
fac[N]----存阶乘    inv[N]----存i的阶乘在模mod下的逆元
int qmi(int a,int b){    //快速幂
    int res=1;
    while(b){
		if(b&1) res=*res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
void init(){       //预处理阶乘和逆元（main函数先调用）
	fac[0]=inv[0]=1;
    for(int i=1;i<N;i++){
		fac[i]=fac[i-1]*i%mod;
        inv[i]=qmi(fac[i],mod-2)%mod;
        //求fac[i]的逆元-----fac[i]的mod-2次方
    }
}
int C(int n,int k){
	if(k<0||k>n) return 0;
    return fac[n]*inv[k]%mod*inv[n-k]%mod;
}
```

### 矩阵乘法

快速幂计算矩阵$A^n$

```c++
Matrix mul(Matrix &A,Matrix &B){
	int n=A.size(),m=B[0].size(),p=B.size();
    Matrix C(n,vector<ll>(m,0));
    for(int i=0;i<n;i++)
        for(int k=0;k<p;k++)
            for(int j=0;j<m;j++)
                C[i][j]=(C[i][j]+A[i][k]*B[k][j])%MOD;
    return C;
}
Matrix matrix_pow(Matrix A,ll n){
	int size=A.size();
    Matrix ans(size,vector<ll>(size,0));
    for(int i=1;i<size;i++)  ans[i][i]=1;
    while(n>0){
        if(n&1) ans=mul(res,A);
        A=mus(A,A);
        n>>=1;
    }
    return ans;
}
```

###
