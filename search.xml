<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组操作几兄弟</title>
      <link href="/chunk.github.io/2025/09/18/%E7%BC%96%E7%A8%8B/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%87%A0%E5%85%84%E5%BC%9F/"/>
      <url>/chunk.github.io/2025/09/18/%E7%BC%96%E7%A8%8B/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%87%A0%E5%85%84%E5%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="数组操作几兄弟"><a href="#数组操作几兄弟" class="headerlink" title="数组操作几兄弟"></a>数组操作几兄弟</h1><h2 id="核心三兄弟"><a href="#核心三兄弟" class="headerlink" title="核心三兄弟"></a>核心三兄弟</h2><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">pre</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="comment">// sum l..r:</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = pre[r]-pre[l<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><h4 id="后缀和"><a href="#后缀和" class="headerlink" title="后缀和"></a>后缀和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">suf</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">suf[n]=a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) suf[i]=pre[i<span class="number">+1</span>]+a[i];</span><br><span class="line"><span class="comment">// sum l..r:</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = pre[r]-pre[l<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) d[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//[l,r]区间数组a的值+val</span></span><br><span class="line">d[l]+=c;</span><br><span class="line">d[r<span class="number">+1</span>]-=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) b[i]=d[i]+a[i<span class="number">-1</span>];<span class="comment">//b数组即为变化后得到的数组</span></span><br></pre></td></tr></table></figure><h4 id="二维扩展"><a href="#二维扩展" class="headerlink" title="二维扩展"></a>二维扩展</h4><p>矩阵版，用于子矩阵求和或子矩阵批量加值（地毯&#x2F;染色类问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b[x1][y1]+=v; b[x1][y2<span class="number">+1</span>]-=v;</span><br><span class="line">b[x2<span class="number">+1</span>][y1]-=v; b[x2<span class="number">+1</span>][y2<span class="number">+1</span>]+=v;</span><br><span class="line"><span class="comment">// 最后做二维前缀和还原</span></span><br><span class="line"><span class="keyword">for</span>(i) <span class="keyword">for</span>(j) b[i][j]+=b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><h4 id="前缀积"><a href="#前缀积" class="headerlink" title="前缀积"></a>前缀积</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p[i]=p[i<span class="number">-1</span>]*a[i];</span><br></pre></td></tr></table></figure><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p><a href="https://www.luogu.com.cn/problem/U97755?utm_source=chatgpt.com#ide">模板题</a></p><p>前缀异或和数组与前缀和数组类似。（卡了一个endl的复杂度，要改成’\n’才能过）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">pre[i] = pre[i<span class="number">-1</span>] + a[i];</span><br><span class="line">res[i] = res[i<span class="number">-1</span>] ^ a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) cout &lt;&lt; (pre[z] - pre[y - <span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">2</span>) cout &lt;&lt; (res[z] ^ res[y - <span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/1232/">k倍区间</a></p><p>如果只用前缀和数组判断倍数，会TLE。</p><p>若存在某连续区间$[i,j]$的和为k的倍数，则有$pre[j]-pre[i-1]≡0(mod$ $ m)$ ，</p><p>变形可得$pre[i]≡pre[i-1]$(mod $ m)$，即在前缀和数组里模m相同的两点之间区间满足题意。</p><hr><p>！！！若存在$pre[i]≡0$$(mod $ m)，则我们可以取$[1,i]$，前面所有的相加模m是为0的，考虑到这种情况，我们设定res[0]&#x3D;1。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span> ;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">res</span><span class="params">(k<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        pre[i]=(pre[i<span class="number">-1</span>]+arr[i])%k;</span><br><span class="line">        res[pre[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        ans+=(res[i]<span class="number">-1</span>)*res[i]/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3131#ide">Subsequences Summing to Sevens S</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;pii&gt; <span class="title">p</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)p[i] = &#123; n<span class="number">+1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    p[<span class="number">1</span>] = &#123; <span class="number">0</span> ,<span class="number">0</span> &#125;;   <span class="comment">//相当于上面的res[0]=1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        pre[i] = (pre[i - <span class="number">1</span>] + arr[i]) % <span class="number">7</span>;</span><br><span class="line">        p[pre[i]].first = <span class="built_in">min</span>(p[pre[i]].first, i);</span><br><span class="line">        p[pre[i]].second = <span class="built_in">max</span>(p[pre[i]].second, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, p[i].second - p[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/description/4408/">统计子矩阵</a></p><p>不能单纯的用二维前缀和数组，子矩阵的位置至少要四个变量才能确定——矩阵的大小以及右下角位置。</p><p>考虑用双指针，矩阵的宽度由枚举i、j决定，而高度用p、q指针滑动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    ll k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">pre</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;ll&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">            pre[i][j] = pre[i - <span class="number">1</span>][j] + pre[i][j - <span class="number">1</span>] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>, q = <span class="number">1</span>; p &lt;= q &amp;&amp; q &lt;= n; q++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (p &lt;= q &amp;&amp; (pre[q][j] - pre[q][i - <span class="number">1</span>] - pre[p - <span class="number">1</span>][j] + pre[p - <span class="number">1</span>][i - <span class="number">1</span>]) &gt; k) p++;</span><br><span class="line">                <span class="keyword">if</span> (p &lt;= q) ans += (q - p + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="综合算法题"><a href="#综合算法题" class="headerlink" title="综合算法题"></a>综合算法题</h4><p><a href="https://www.luogu.com.cn/problem/P1719#ide">最大加权矩形</a></p><p>前提知识：如果求一维数组中连续和的最大值——$dp[i]&#x3D;max(dp[i-1]+a[i],a[i])$ 只需要考虑当前$a[i]$是否加入该连续和</p><p>此题将一维数组变为矩阵，我们考虑将二维前缀和数组转化为一位前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pre</span>(n + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">pre[i][j] = pre[i - <span class="number">1</span>][j] + pre[i][j - <span class="number">1</span>] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] + num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    ###########################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">for (int s = 1; s &lt;= n; s++) &#123;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> t = s; t &lt;= n; t++) &#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">row[i] = pre[t][i] - pre[s<span class="number">-1</span>][i] - pre[t][i<span class="number">-1</span>] + pre[s<span class="number">-1</span>][i<span class="number">-1</span>];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">dp[<span class="number">1</span>] = row[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + row[i], row[i]);</span><br><span class="line">ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    #############################################################################<span class="meta">#</span></span><br><span class="line"><span class="meta">cout &lt;&lt; ans;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验报告——推箱子小游戏</title>
      <link href="/chunk.github.io/2025/09/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%8E%A8%E7%AE%B1%E5%AD%90%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/chunk.github.io/2025/09/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E6%8E%A8%E7%AE%B1%E5%AD%90%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a><strong>实验目标</strong></h2><ol><li>综合应用所学的知识创建完整的推箱子游戏；</li><li>熟练掌握 和绘图 API。</li></ol><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>创建空项目并手动修改页面配置。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 133509.png" style="zoom:50%;" /><h4 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h4><h6 id="创建页面项目"><a href="#创建页面项目" class="headerlink" title="创建页面项目"></a>创建页面项目</h6><p>在<code>app.json </code>文件中 <code>pages</code> 属性添加<code>“pages/game/game&quot;</code>，保存后会在<code>pages</code>文件夹下自动生成<code>game</code>目录。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 150508.png" style="zoom:50%;" /><h6 id="删除和修改文件"><a href="#删除和修改文件" class="headerlink" title="删除和修改文件"></a>删除和修改文件</h6><ul><li><p>删除<code>index.wxml</code>、<code>index.wxss</code>和<code>app.wxss</code>中的所有代码；</p></li><li><p>删除<code>index.js</code>中的所有代码并输入<code>&quot;page&quot;</code>使其自动补全函数；</p></li><li><p>删除<code>app.js</code>中的所有代码并输入<code>&quot;app&quot;</code>使其自动补全函数。</p></li></ul><h6 id="创建其他文件"><a href="#创建其他文件" class="headerlink" title="创建其他文件"></a>创建其他文件</h6><ol><li><p>添加图片文件</p><p>在目录结构中添加<code>images</code>文件夹，将游戏页面中需要用到的游戏界面复制进去，并将需要用到的游戏图标素材放在其下的<code>icons</code>文件夹中。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 145155.png" style="zoom:50%;" /></li><li><p>创建公共JS文件</p><p>新建<code>utils</code>文件夹，在其下新建<code>data.js</code>。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 145735.png" style="zoom:50%;" /></li></ol><h4 id="视图设计"><a href="#视图设计" class="headerlink" title="视图设计"></a>视图设计</h4><h6 id="导航栏设计"><a href="#导航栏设计" class="headerlink" title="导航栏设计"></a>导航栏设计</h6><p>在<code>app.json</code>文件中修改导航栏效果，将其改为珊瑚红背景白色字体，更改后的代码如图中所示。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 151114.png" style="zoom:50%;" /><h6 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h6><ol><li><p>公共样式设计</p><p>首先添加页面容器和顶端标题的公共样式，在<code>app.wxss</code>中添加如图所示代码。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 151606.png" style="zoom:50%;" /></li><li><p>首页设计</p><p>使<code>&lt;view&gt;</code>组件设置首页的标题以及关卡列表的页面设计，首先在<code>index.wxml</code>文件中添加如图所示代码，可以看见此时已经成功导入了关卡1的图片，但格式还需要调整；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 152224.png" style="zoom:50%;" /><p>接着在<code>index.wxss</code>文件中添加如图所示代码，通过改变图片的尺寸以及<code>box</code>组件的排列方式，使第一关只占左边50%。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 152527.png" style="zoom:50%;" /></li><li><p>游戏页面设计</p><p>游戏页面包括游戏关卡标题、游戏画面、方向键和“重新开始”按钮，由于暂时没有做点击跳转的逻辑设计，所以可以在开发工具顶端选择“普通编译”下的“添加编译模式”，并携带临时测试参数 level 0，如图所示，之后预览就可以直接显示 game页面了。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 153616.png" style="zoom:50%;" /><p>首先在<code>game.wxml</code>文件中添加如图所示代码，成功加入了方向键及重新开始游戏键，但格式还需要进行调整；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 154655.png" style="zoom:50%;" /><p>接着在<code>game.wxss</code>文件中添加如下代码，将方向按钮组件纵向排列且居中，同时第二行横向排列，效果如图所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">canvas&#123;</span><br><span class="line">    <span class="attr">border</span>: 1rpx solid;</span><br><span class="line">    <span class="attr">width</span>: 320px;</span><br><span class="line">    <span class="attr">height</span>: 320px;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">btnBox</span>&#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    flex-<span class="attr">direction</span>: column;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">btnBox</span> view&#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    flex-<span class="attr">direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">btnBox</span> button&#123;</span><br><span class="line">    <span class="attr">width</span>: 90rpx;</span><br><span class="line">    <span class="attr">height</span>: 90rpx;</span><br><span class="line">&#125;</span><br><span class="line">button&#123;</span><br><span class="line">    <span class="attr">margin</span>: 10rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/chunk.github.io/images/屏幕截图 2025-09-08 154514.png" style="zoom:50%;" /></li></ol><h4 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h4><h6 id="公共逻辑"><a href="#公共逻辑" class="headerlink" title="公共逻辑"></a>公共逻辑</h6><p>在公共JS文件（<code>utils/data,js</code>）中配置游戏地图数据，分别使用map1~map4代表4个不同关卡的地图数据，并分别以二维数组的形式存放，每个位置的数字代表对应的图标素材。</p><p>然后需要在<code>data.js</code>中使用<code>module.exports</code>语句暴露数据出口，并在<code>game</code>页面的JS文件端引用该公共逻辑。</p><blockquote><p>tips：注意小程序在这里暂时还不支持绝对路径引用，只能使用相对路径！</p></blockquote><img src="/chunk.github.io/images/屏幕截图 2025-09-08 160334.png" style="zoom:50%;" /><h6 id="首页逻辑"><a href="#首页逻辑" class="headerlink" title="首页逻辑"></a>首页逻辑</h6><ol><li><p>关卡列表展示</p><p>在JS文件的<code>data</code>中录入关卡图片的数据信息</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 160711.png" style="zoom:50%;" /><p>接着为关卡对应的<code>&lt;view&gt;</code>组件添加<code>wx:for</code>属性循环显示列表数据和图片，效果如图所示。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 161034.png" style="zoom:50%;" /></li><li><p>点击跳转游戏页面</p><p>首先为关卡列表项目添加点击事件，更改<code>index.wxml</code>代码，为关卡添加自定义点击事件函数<code>chooseLevel</code>，并使用<code>data-level</code>属性携带关卡图片下标信息。</p><p>接着在对应的<code>index.js</code>文件中添加自定义点击函数的内容，此时以及可以点击跳转到game页面并成功携带了关卡图片数据，但仍需在<code>game</code>页面进行携带数据的接受处理才可显示正确的游戏画面。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 161835.png" style="zoom:50%;" /></li></ol><h6 id="游戏页逻辑"><a href="#游戏页逻辑" class="headerlink" title="游戏页逻辑"></a>游戏页逻辑</h6><ol><li><p>显示当前第几关</p><p>之前已经实现了页面跳转并携带了关卡对应的图片信息，现在需要在游戏界面接收关卡信息并显示对应的图片内容。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 163034.png" style="zoom:50%;" /></li><li><p>游戏逻辑实现</p><ul><li><p>准备工作</p><p>在<code>game.js</code>文件的顶端记录一些游戏初始数据信息。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 163600.png" style="zoom:50%;" /></li><li><p>初始化游戏画面</p><ul><li><p>在<code>game.js</code>文件中添加<code>initMap</code>函数，现场从公共函数文件中读取对应关卡的游戏地图数据，然后使用双重for循环对每一块地图数据进行解析并更新当前游戏数据；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 164836.png" style="zoom:50%;" /></li><li><p>接着在<code>game.js</code>中添加自定义函数<code>drawCanvas</code>，将地图信息绘制到画布上；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 165406.png" style="zoom:50%;" /></li><li><p>最后在<code>game.js</code>的<code>onLoad</code>函数中创建画布上下文，并依次调用自定义函数<code>initMap</code>和<code>drawCanvas</code>。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 165814.png" style="zoom:50%;" /></li></ul></li><li><p>方向键逻辑实现</p><ul><li><p>修改<code>game.wxml</code>页面中的4个方向键，为其绑定点击事件；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 233501.png" style="zoom:50%;" /></li><li><p>在<code>game.js</code>文件中添加上述点击事件函数，分别用于实现游戏主角上下左右的移动，每次点击在条件允许的情况下移动一格。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 234601.png" alt="屏幕截图 2025-09-08 234601" style="zoom:50%;" /></li></ul></li></ul></li><li><p>判断游戏成功</p><ul><li><p>在<code>game.js</code>文件中添加自定义函数<code>isWin</code>，用于判断游戏是否已经成功；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 235838.png" style="zoom:50%;" /></li><li><p>然后在<code>game.js</code>中添加自定义函数<code>checkWin</code>，一旦游戏成功就弹出提示对话框；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 234645.png" style="zoom:50%;" /></li><li><p>最后在<code>game.js</code>的4个方向键函数中追加关于游戏成功判断的函数。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 234645.png" style="zoom:50%;" /></li></ul></li></ol><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><p>推箱子小游戏可以正常运行，具有以下功能：</p><ol><li>关卡选择：首页显示4个不同关卡，点击可进入对应游戏</li><li>游戏操作：通过方向键控制角色移动，推动箱子到指定位置</li><li>游戏判断：当所有箱子都推到目标位置时，弹出胜利提示</li><li>重新开始：可以重置当前关卡重新游戏</li></ol><h2 id="问题总结与体会"><a href="#问题总结与体会" class="headerlink" title="问题总结与体会"></a>问题总结与体会</h2><h3 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h3><ol><li><p>Canvas绘图技能：深入学习了微信小程序中Canvas组件的使用，掌握了基本的绘图API；</p></li><li><p>游戏开发思维：通过开发推箱子游戏，学会了如何将复杂的游戏逻辑分解为简单的函数模块，提高了编程的逻辑思维能力。</p></li><li><p>事件处理机制：学习了小程序中的事件绑定和处理机制，特别是自定义事件函数的编写和参数传递。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验报告——第一个HarmonyOS应用</title>
      <link href="/chunk.github.io/2025/09/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%E5%BA%94%E7%94%A8/"/>
      <url>/chunk.github.io/2025/09/08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E7%AC%AC%E4%B8%80%E4%B8%AAHarmonyOS%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="2025年夏季《移动软件开发》实验报告"><a href="#2025年夏季《移动软件开发》实验报告" class="headerlink" title="2025年夏季《移动软件开发》实验报告"></a>2025年夏季《移动软件开发》实验报告</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><ol><li><p>掌握如何构建 HarmonyOS应用；</p></li><li><p>掌握应用程序包结构、资源文件的使用；</p></li><li><p>掌握ArkTS的核心功能和语法等基础知识，为后续的应用开发奠定基础。</p></li></ol><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h4 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h4><p>下载并安装最新版<a href="https://developer.huawei.com/consumer/cn/download/">DevEco Studio</a>。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 130744.png" style="zoom:50%;" /><img src="/chunk.github.io/images/屏幕截图 2025-09-08 133848.png" style="zoom:50%;" /><h4 id="创建ArkTS工程"><a href="#创建ArkTS工程" class="headerlink" title="创建ArkTS工程"></a>创建ArkTS工程</h4><ol><li><p>单击Create Project创建工程，选择Application应用开发，选择模板Empty Ability，单击Next进行配置；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 133934.png" style="zoom:50%;" /></li><li><p>进入配置工程界面，Compatible SDK选择5.1.1(19)，其他参数保持默认设置，单击Finish，等待工程创建完成。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 134024.png" style="zoom:50%;" /></li></ol><h4 id="构建第一个页面"><a href="#构建第一个页面" class="headerlink" title="构建第一个页面"></a>构建第一个页面</h4><ol><li><p>使用文本组件</p><p>在<code>Project</code>窗口，单击<code>entry &gt; src &gt; main &gt; ets &gt; pages</code>，打开<code>Index.ets</code>文件，编辑代码，将页面相对布局修改成<code>Row/Column</code>线性布局。</p><p>添加代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Index.ets</span><br><span class="line">@Entry</span><br><span class="line">@Component</span><br><span class="line">struct Index &#123;</span><br><span class="line">  @State message: string = &#x27;Hello World&#x27;;</span><br><span class="line">  build() &#123;</span><br><span class="line">    Row() &#123;</span><br><span class="line">      Column() &#123;</span><br><span class="line">        Text(this.message)</span><br><span class="line">          .fontSize(50)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">      &#125;</span><br><span class="line">      .width(&#x27;100%&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    .height(&#x27;100%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加按钮</p><p>在默认页面基础上，添加<code>Button</code>组件，作为按钮响应用户<code>onClick</code>事件，从而实现跳转到另一个页面。</p><p>添加代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Index.ets</span><br><span class="line"> @Entry</span><br><span class="line"> @Component</span><br><span class="line"> struct Index &#123;</span><br><span class="line">  @State message: string = &#x27;Hello World&#x27;;</span><br><span class="line">  build() &#123;</span><br><span class="line">    Row() &#123;</span><br><span class="line">      Column() &#123;</span><br><span class="line">        Text(this.message)</span><br><span class="line">          .fontSize(50)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        // 添加按钮，以响应用户onClick事件</span><br><span class="line">        Button() &#123;</span><br><span class="line">          Text(&#x27;Next&#x27;)</span><br><span class="line">            .fontSize(30)</span><br><span class="line">            .fontWeight(FontWeight.Bold)</span><br><span class="line">        &#125;</span><br><span class="line">        .type(ButtonType.Capsule)</span><br><span class="line">        .margin(&#123;</span><br><span class="line">          top: 20</span><br><span class="line">        &#125;)</span><br><span class="line">        .backgroundColor(&#x27;#0D9FFB&#x27;)</span><br><span class="line">        .width(&#x27;40%&#x27;)</span><br><span class="line">        .height(&#x27;5%&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">      .width(&#x27;100%&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    .height(&#x27;100%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>效果预览</p><p>在编辑窗口右上角的侧边工具栏，单击Previewer，打开预览器进行预览。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 134631.png" style="zoom:50%;" /></li></ol><h4 id="构建第二个页面"><a href="#构建第二个页面" class="headerlink" title="构建第二个页面"></a>构建第二个页面</h4><ol><li><p>创建第二个页面</p><ul><li><p>在<code>Project</code>窗口，打开<code>entry &gt; src &gt; main &gt; ets</code>，右键单击<code>pages</code>文件夹，选择 <code>New &gt; ArkTS File</code>，命名为<code>Second</code>，单击回车键。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 134727.png" style="zoom:50%;" /></li><li><p>在<code>Project</code>窗口，打开<code>entry &gt; src &gt; main &gt; resources &gt; base &gt; profile</code>，在 <code>main_pages.json</code>文件中的<code>&quot;src&quot;</code>下配置第二个页面的路由<code>&quot;pages/Second&quot;</code>。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;src&quot;: [</span><br><span class="line"> &quot;pages/Index&quot;,</span><br><span class="line"> &quot;pages/Second&quot;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/chunk.github.io/images/屏幕截图 2025-09-08 134908.png" style="zoom:50%;" /></li></ul></li><li><p>添加文本及按钮</p><p>参照第一个页面，为第二个页面添加<code>Text、button</code>等组件，在<code>Second.ets</code>中添加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Second.ets</span><br><span class="line"> @Entry</span><br><span class="line"> @Component</span><br><span class="line"> struct Second &#123;</span><br><span class="line"> @State message: string = &#x27;Hi there&#x27;;</span><br><span class="line"> build() &#123;</span><br><span class="line"> Row() &#123;</span><br><span class="line"> Column() &#123;</span><br><span class="line"> Text(this.message)</span><br><span class="line"> .fontSize(50)</span><br><span class="line"> .fontWeight(FontWeight.Bold)</span><br><span class="line"> Button() &#123;</span><br><span class="line"> Text(&#x27;Back&#x27;)</span><br><span class="line"> .fontSize(30)</span><br><span class="line"> .fontWeight(FontWeight.Bold)</span><br><span class="line"> &#125;</span><br><span class="line"> .type(ButtonType.Capsule)</span><br><span class="line"> .margin(&#123;</span><br><span class="line">     top: 20</span><br><span class="line">        &#125;)</span><br><span class="line">        .backgroundColor(&#x27;#0D9FFB&#x27;)</span><br><span class="line">        .width(&#x27;40%&#x27;)</span><br><span class="line">        .height(&#x27;5%&#x27;)</span><br><span class="line">      &#125;</span><br><span class="line">      .width(&#x27;100%&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    .height(&#x27;100%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>效果预览</p><p>点击右侧Previewer开始预览</p></li></ol><img src="/chunk.github.io/images/屏幕截图 2025-09-08 135041.png" style="zoom:50%;" /><h4 id="实现页面间跳转"><a href="#实现页面间跳转" class="headerlink" title="实现页面间跳转"></a>实现页面间跳转</h4><ol><li><p>第一个页面跳转到第二个页面</p><p>在第一个页面中，跳转按钮绑定<code>onClick</code>事件，单击按钮时跳转到第二页。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// Index.ets</span><br><span class="line"> import &#123; BusinessError &#125; from &#x27;@kit.BasicServicesKit&#x27;;</span><br><span class="line"> @Entry</span><br><span class="line"> @Component</span><br><span class="line"> struct Index &#123;</span><br><span class="line">  @State message: string = &#x27;Hello World&#x27;;</span><br><span class="line">  build() &#123;</span><br><span class="line">    Row() &#123;</span><br><span class="line">      Column() &#123;</span><br><span class="line">        Text(this.message)</span><br><span class="line">          .fontSize(50)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        // 添加按钮，以响应用户onClick事件</span><br><span class="line">        Button() &#123;</span><br><span class="line">          Text(&#x27;Next&#x27;)</span><br><span class="line">            .fontSize(30)</span><br><span class="line">            .fontWeight(FontWeight.Bold)</span><br><span class="line">        &#125;</span><br><span class="line">        .type(ButtonType.Capsule)</span><br><span class="line">        .margin(&#123;</span><br><span class="line">          top: 20</span><br><span class="line">        &#125;)</span><br><span class="line">        .backgroundColor(&#x27;#0D9FFB&#x27;)</span><br><span class="line">        .width(&#x27;40%&#x27;)</span><br><span class="line">        .height(&#x27;5%&#x27;)</span><br><span class="line">        // 跳转按钮绑定onClick事件，单击时跳转到第二页</span><br><span class="line">        .onClick(() =&gt; &#123;</span><br><span class="line">          console.info(`Succeeded in clicking the &#x27;Next&#x27; button.`)</span><br><span class="line">        // 获取UIContext</span><br><span class="line">          let uiContext: UIContext = this.getUIContext();</span><br><span class="line">          let router = uiContext.getRouter();</span><br><span class="line">          // 跳转到第二页</span><br><span class="line">          router.pushUrl(&#123; url: &#x27;pages/Second&#x27; &#125;).then(() =&gt; &#123;</span><br><span class="line">            console.info(&#x27;Succeeded in jumping to the second page.&#x27;)</span><br><span class="line">          &#125;).catch((err: BusinessError) =&gt; &#123;</span><br><span class="line">            console.error(`Failed to jump to the second page. Code is $&#123;err.code&#125;, </span><br><span class="line">message is $&#123;err.message&#125;`)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      .width(&#x27;100%&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    .height(&#x27;100%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>第二个页面返回到第一个页面</p><p>在第二个页面中，返回按钮绑定<code>onClick</code>事件，单击按钮时返回到第一页。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// Second.ets</span><br><span class="line"> import &#123; BusinessError &#125; from &#x27;@kit.BasicServicesKit&#x27;;</span><br><span class="line"> @Entry</span><br><span class="line"> @Component</span><br><span class="line"> struct Second &#123;</span><br><span class="line">  @State message: string = &#x27;Hi there&#x27;;</span><br><span class="line">  build() &#123;</span><br><span class="line">    Row() &#123;</span><br><span class="line">      Column() &#123;</span><br><span class="line">        Text(this.message)</span><br><span class="line">          .fontSize(50)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        Button() &#123;</span><br><span class="line">          Text(&#x27;Back&#x27;)</span><br><span class="line">            .fontSize(30)</span><br><span class="line">            .fontWeight(FontWeight.Bold)</span><br><span class="line">        &#125;</span><br><span class="line">        .type(ButtonType.Capsule)</span><br><span class="line">        .margin(&#123;</span><br><span class="line">          top: 20</span><br><span class="line">        &#125;)</span><br><span class="line">        .backgroundColor(&#x27;#0D9FFB&#x27;)</span><br><span class="line">        .width(&#x27;40%&#x27;)</span><br><span class="line">        .height(&#x27;5%&#x27;)</span><br><span class="line">        // 返回按钮绑定onClick事件，单击按钮时返回到第一页</span><br><span class="line">        .onClick(() =&gt; &#123;</span><br><span class="line">          console.info(`Succeeded in clicking the &#x27;Back&#x27; button.`)</span><br><span class="line">       // 获取UIContext</span><br><span class="line">          let uiContext: UIContext = this.getUIContext();</span><br><span class="line">          let router = uiContext.getRouter();</span><br><span class="line">          try &#123;</span><br><span class="line">            // 返回第一页</span><br><span class="line">            router.back()</span><br><span class="line">            console.info(&#x27;Succeeded in returning to the first page.&#x27;)</span><br><span class="line">          &#125; catch (err) &#123;</span><br><span class="line">            let code = (err as BusinessError).code; </span><br><span class="line">            let message = (err as BusinessError).message; </span><br><span class="line">            console.error(`Failed to return to the first page. Code is $&#123;code&#125;, </span><br><span class="line">message is $&#123;message&#125;`)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      .width(&#x27;100%&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    .height(&#x27;100%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>效果预览</p><p>点击Previewer预览，发现点击Next跳转到Second页面，点击Back回到Index页面。</p></li></ol><h2 id="三、程序运行结果"><a href="#三、程序运行结果" class="headerlink" title="三、程序运行结果"></a>三、程序运行结果</h2><p>电脑的预览效果如下：</p><img src="/chunk.github.io/images/屏幕截图 2025-09-08 140223.png" style="zoom:50%;" /><h2 id="问题总结与体会"><a href="#问题总结与体会" class="headerlink" title="问题总结与体会"></a>问题总结与体会</h2><h5 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h5><p>添加完第二个页面后进行预览时发生了报错，清除缓存后重新运行了项目，发现是ArkTS 编译器找不到 <code>Second.ets</code> 文件对应的模块信息，命名时写为了<code>second</code>导致错误。</p><h5 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h5><ol><li><p>初步掌握了HarmonyOS应用开发的基本流程，熟悉了DevEco Studio开发环境的使用和ArkTS语言的基础语法。</p></li><li><p>通过亲手创建第一个应用，对声明式UI开发有了直观认识，为后续深入学习奠定了基础。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>难搞的dp</title>
      <link href="/chunk.github.io/2025/09/07/%E7%BC%96%E7%A8%8B/%E9%9A%BE%E6%90%9E%E7%9A%84dp/"/>
      <url>/chunk.github.io/2025/09/07/%E7%BC%96%E7%A8%8B/%E9%9A%BE%E6%90%9E%E7%9A%84dp/</url>
      
        <content type="html"><![CDATA[<p>本文例题均来自于刘汝佳老师的《算法竞赛入门经典》，均可在 <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=827">UVa</a> 提交</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="DAG上的动态规划"><a href="#DAG上的动态规划" class="headerlink" title="DAG上的动态规划"></a>DAG上的动态规划</h3><h4 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips 1"></a>Tips 1</h4><p>很多动规的问题都可以转化为DAG上的动态规划，如：前一个矩形X可以嵌套进后一个Y，可以表示为X到Y有一条有向边，且构成的图是无环的。</p><h4 id="Tips-2"><a href="#Tips-2" class="headerlink" title="Tips 2"></a>Tips 2</h4><p>如何输出字典序最小的满足条件的路径   ——  将所以dp[i]计算出来，然后从头开始遍历选择最大d[i]对应的最小i。</p><h4 id="Tips-3"><a href="#Tips-3" class="headerlink" title="Tips 3"></a>Tips 3</h4><p><strong>填表法</strong> → “DP 填表，每格依赖前格，按公式严格计算”</p><p><strong>刷表法</strong> → “暴力&#x2F;预处理，把所有可能的值算出来存表，不用公式严格依赖”</p><h4 id="Tips-4"><a href="#Tips-4" class="headerlink" title="Tips 4"></a>Tips 4</h4><p>先找出当前状态有几个可以考虑的因素。</p><p>在判断定义dp数组为几维时，只需思考当前状态下什么或哪几个因素会影响到下一状态，然后定义出初始状态，并思考下一决策的可能情况。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h5 id="UVa-1025-城市里的间谍"><a href="#UVa-1025-城市里的间谍" class="headerlink" title="UVa 1025 城市里的间谍"></a><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=847&page=show_problem&problem=3466">UVa 1025 城市里的间谍</a></h5><p>下一状态由当前状态的所处车站位置及已经过去的时间决定，则我们定义：<code>dp[i][j]：在时刻i位于车站最少还需要等待的时间</code>(保证可以成功会面即<code>i</code>最多为<code>t</code>)</p><p>边界条件：<code>dp[T][n]=0</code> —– 已经到达目的地不需要再等待</p><p>输出数值：<code>dp[0][1]</code> —– 从0时刻位于1站台最少等待时间</p><p>下一决策（考虑影响因素的变化情况）：</p><ul><li><p>在该车站等一分钟 → <code>dp[i][j]=dp[i+1][j]+1</code>  → 计算<code>i</code>时刻必须要先知道<code>i+1</code>时刻，因此时间必须倒序考虑</p></li><li><p>搭往右走的火车 → <code>dp[i][j]=min(dp[i+a[j]][j+1],dp[i][j]</code></p></li><li><p>搭往左走的火车 → <code>dp[i][j]=min(dp[i+a[j-1]][j-1],dp[i][j]</code> → 而站台序号则可正序可倒序</p><p>即<code>dp[i][j]=min()</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">+1</span>][j]<span class="number">+1</span>,dp[i][j]);</span><br><span class="line"><span class="keyword">if</span>(j&lt;n&amp;&amp;has_train[i][j][<span class="number">0</span>]&amp;&amp;i+a[j]&lt;=t) dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i+a[j]][j<span class="number">+1</span>]);</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>&amp;&amp;has_train[i][j][<span class="number">1</span>]&amp;&amp;i+a[j<span class="number">-1</span>]&lt;=t) dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i+a[j<span class="number">-1</span>]][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>has_train[i][j][1]</code>代表在i时刻的j站台有向左的火车可以搭，该数组可在输入左右火车的出发时间时进行统计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) &#123;  <span class="comment">//考虑每辆向右行驶的火车</span></span><br><span class="line">           cin &gt;&gt; l[i];</span><br><span class="line">           <span class="keyword">if</span> (l[i] &lt;= t) has_train为<span class="number">1</span>[l[i]][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 设置站台1的停靠时间（一开始忘记了）</span></span><br><span class="line">           <span class="type">int</span> depart = l[i];  <span class="comment">//该火车出发的时间</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;  <span class="comment">//该火车到达每个站台的时间，只要没超时就代表has_train为1</span></span><br><span class="line">               depart += a[j];</span><br><span class="line">               <span class="keyword">if</span> (depart &lt;= t) has_train[depart][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>完整AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">55</span>]; <span class="comment">//相邻两站台间的耗时</span></span><br><span class="line"><span class="type">int</span> m1, m2;</span><br><span class="line"><span class="type">int</span> l[<span class="number">55</span>], r[<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">500</span>][<span class="number">55</span>];<span class="comment">//dp[i][j]---时刻i位于站台j 到达站台n的最短时间</span></span><br><span class="line"><span class="type">bool</span> has_train[<span class="number">500</span>][<span class="number">55</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        cin &gt;&gt; m1;</span><br><span class="line">        <span class="built_in">memset</span>(has_train, <span class="number">0</span>, <span class="built_in">sizeof</span>(has_train));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m1; i++) &#123;</span><br><span class="line">            cin &gt;&gt; l[i];</span><br><span class="line">            <span class="keyword">if</span> (l[i] &lt;= t) has_train[l[i]][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 设置站台1的停靠时间</span></span><br><span class="line">            <span class="type">int</span> depart = l[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                depart += a[j];</span><br><span class="line">                <span class="keyword">if</span> (depart &lt;= t) has_train[depart][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; m2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m2; i++) &#123;</span><br><span class="line">            cin &gt;&gt; r[i];</span><br><span class="line">            <span class="keyword">if</span> (r[i] &lt;= t) has_train[r[i]][n][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 设置站台n的停靠时间</span></span><br><span class="line">            <span class="type">int</span> depart = r[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; <span class="number">1</span>; j--) &#123;</span><br><span class="line">                depart += a[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (depart &lt;= t) has_train[depart][j - <span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                dp[i][j] = <span class="number">1e9</span>;</span><br><span class="line">        dp[t][n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n &amp;&amp; has_train[i][j][<span class="number">0</span>] &amp;&amp; i + a[j] &lt;= t)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + a[j]][j + <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; has_train[i][j][<span class="number">1</span>] &amp;&amp; i + a[j - <span class="number">1</span>] &lt;= t)</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + a[j - <span class="number">1</span>]][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case Number &quot;</span> &lt;&lt; index++ &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>][<span class="number">1</span>] != <span class="number">1e9</span>) cout &lt;&lt; dp[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UVa-437-巴比伦塔"><a href="#UVa-437-巴比伦塔" class="headerlink" title="UVa 437 巴比伦塔"></a><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=847&page=show_problem&problem=378">UVa 437 巴比伦塔</a></h5><p>砖的摆放很明显是完全随机的，唯一要满足的条件就是：上面的砖的底面长、宽必须严格小于下面砖的地面长、宽。</p><p>由于砖的尺度是三维，如果考虑用尺度来建dp数组（<code>dp[i][j][k]-长宽高分别为i,j,k的砖在顶部</code>）的话会很麻烦，因此我们考虑将尺度的三维减小维数，同时，由于砖的摆放限制条件很少，一块砖可以有三种摆放情况，考虑将每块砖的三种摆放情况都存入某数组，第三维的变量做高，这里为了方便，我们设定长&gt;宽的条件。例如：砖(a,b,c)，假定<code>a&gt;b&gt;c</code>，则将其考虑为三块不同的砖<code>(a,b,c) (b,c,a) (a,c,b)</code>。并将所有的砖按长降序排列，若长相同则按宽降序排列。</p><p>定义<code>dp[i]</code>：排序后的第i块砖做顶砖时可以到达的最大高度。</p><p>转移条件：如果第<code>j(j&lt;i)</code>块砖的长、宽严格大于第<code>i</code>块砖则<code>dp[i]=max(dp[i],dp[j]+i.height)</code></p><p>初始状态：<code>dp[i]=i.height</code>，每块砖做顶砖时至少高度都为自己本身的高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">block</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> block&amp; a,<span class="type">const</span> block&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">vector&lt;block&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123; <span class="built_in">max</span>(x,y),<span class="built_in">min</span>(x,y),z &#125;);</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123; <span class="built_in">max</span>(x,z),<span class="built_in">min</span>(x,z),y &#125;);</span><br><span class="line">a.<span class="built_in">push_back</span>(&#123; <span class="built_in">max</span>(z,y),<span class="built_in">min</span>(z,y),x &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">90</span>];</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) dp[i] = a[i].z;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j].x &gt; a[i].x &amp;&amp; a[j].y &gt; a[i].y) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + a[i].z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; index++ &lt;&lt; <span class="string">&quot;: maximum height = &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UVa-1347-旅行"><a href="#UVa-1347-旅行" class="headerlink" title="UVa 1347 旅行"></a><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4093">UVa 1347 旅行</a></h5><p>在解决此题前，先要了解下TSP问题的解法，然后变形为双人TSP问题。</p><h6 id="TSP问题"><a href="#TSP问题" class="headerlink" title="TSP问题"></a>TSP问题</h6><p>给定图中n个点，从一个起点出发，要求访问所有点（每个点仅访问一次），求最短路径。<br>遍历顶点，找到最小值：</p><p>定义dp：<code>dp[mask][u]</code>—-已经访问的点集合为<code>mask</code>，当前在点<code>u</code>的最小路径长度</p><p>初始化：<code>dp[1][0]=0; </code>  — 从点0出发仅0被访问 </p><p>​               <code>             dp[mask][u]=INF;</code>  — 初始化INF表示还未被计算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cost[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][<span class="number">25</span>];  <span class="comment">//顶点数不超过20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            cin &gt;&gt; cost[i][j];</span><br><span class="line">    <span class="type">int</span> full = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; full; ++mask)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; ++u)</span><br><span class="line">            dp[mask][u] = INF;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历full种情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; full; mask++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (!((mask &gt;&gt; u) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;  <span class="comment">//选取在已访问点集中的点u</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;  <span class="comment">//从u点开始向外延申</span></span><br><span class="line">                <span class="keyword">if</span> (mask &gt;&gt; v &amp; <span class="number">1</span>) <span class="keyword">continue</span>;  <span class="comment">//v被访问过了跳过</span></span><br><span class="line">                <span class="type">int</span> newmask = mask | <span class="number">1</span> &lt;&lt; v;  <span class="comment">//更新点集</span></span><br><span class="line">                dp[newmask][v] = <span class="built_in">min</span>(dp[newmask][v], dp[mask][u] + cost[u][v]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> res = INF;</span><br><span class="line">    <span class="comment">//1.必须回到起始点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt; n; ++u)</span><br><span class="line">        res = <span class="built_in">min</span>(res, dp[full - <span class="number">1</span>][u] + cost[u][<span class="number">0</span>]); <span class="comment">//还要加上u回到原点的代价</span></span><br><span class="line"><span class="comment">//2.只需要访问所有点，不用回到原点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt; n; u++)</span><br><span class="line">        res = <span class="built_in">min</span>(res, dp[full - <span class="number">1</span>][u]);</span><br><span class="line">    <span class="comment">//3.指定终点为n-1</span></span><br><span class="line">    res = dp[full - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="双人TSP问题"><a href="#双人TSP问题" class="headerlink" title="双人TSP问题"></a>双人TSP问题</h6><p>此题与一般TSP不同，指定必须要从左向右访问到最右边的结点再返回，而一般TSP的方向是任意的。</p><p>为了高效解决这个问题，我们将问题转化为：两个人从最左点同时出发，都严格向右移动，但沿着不同的路径访问点，最终都到达最右点。这样，两条路径覆盖所有点，且路径长度之和就是原问题中从最左点到最右点再返回最左点的总路径长度。</p><p>定义：<code>dp[i][j]--一个人到达第i个点，另一人到达第j个点，i&lt;j（第一个人在前面），且前i个点都已经被访问了，此种状态下到达终点的最短路径</code></p><p>转移条件：</p><ul><li>第一个人继续往<code>i+1</code>个点走—<code>dp[i+1][j]=min(dp[i+1][j],dp[i][j]+cost[i][i+1])</code></li><li>第二个人先去第<code>i+1</code>个点走—<code>dp[i+1][i]=min(dp[i+1][i],dp[i][j]+cost[j][i+1])</code></li></ul><p>初始条件：当i&#x3D;n-2时，两个人的下一步都是到n-1的终点即</p><p>​                   <code>for(int j=0;j&lt;n-2;j++) dp[n-2][j]=cost[n-2][n-1]+cost[j][n-1]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; a;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((x.first - y.first) * (x.first - y.first) + (x.second - y.second) * (x.second - y.second));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">a.<span class="built_in">resize</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;0.00&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="number">2</span> * <span class="built_in">func</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(n, <span class="number">1e6</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">2</span>; j++) dp[n - <span class="number">2</span>][j] = <span class="built_in">func</span>(a[n - <span class="number">2</span>], a[n - <span class="number">1</span>]) + <span class="built_in">func</span>(a[j], a[n - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i + <span class="number">1</span>][j] + <span class="built_in">func</span>(a[i], a[i + <span class="number">1</span>]), dp[i + <span class="number">1</span>][i] + <span class="built_in">func</span>(a[j], a[i + <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; dp[<span class="number">1</span>][<span class="number">0</span>] + <span class="built_in">func</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多阶段决策问题"><a href="#多阶段决策问题" class="headerlink" title="多阶段决策问题"></a>多阶段决策问题</h3>]]></content>
      
      
      <categories>
          
          <category> 编程，《算法竞赛入门经典》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何</title>
      <link href="/chunk.github.io/2025/09/07/%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
      <url>/chunk.github.io/2025/09/07/%E7%BC%96%E7%A8%8B/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
      
        <content type="html"><![CDATA[<p>计算几何<br>4.1 二维计算几何基础<br>4.2 凸包<br>4.3 半平面交<br>4.4 最小圆覆盖<br>4.5 三维计算几何基础<br>4.6 三维凸包<br>4.7 旋转卡壳<br>4.8 三角剖分<br>4.9 扫描线<br>4.10 自适应辛普森积分</p><h2 id="二维计算几何基础"><a href="#二维计算几何基础" class="headerlink" title="二维计算几何基础"></a>二维计算几何基础</h2><h3 id="基础元素的代码表示"><a href="#基础元素的代码表示" class="headerlink" title="基础元素的代码表示"></a>基础元素的代码表示</h3><h5 id="点-向量"><a href="#点-向量" class="headerlink" title="点|向量"></a>点|向量</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="直线-射线"><a href="#直线-射线" class="headerlink" title="直线|射线"></a>直线|射线</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">斜率式：y=kx+b;</span><br><span class="line">点向式：p+tv  <span class="comment">//p为直线上一点，v为方向向量，每一个t对应一个点</span></span><br></pre></td></tr></table></figure><h5 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h5><p>记录左右端点即可。</p><h5 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h5><p>使用数组按一定顺序记录多边形的每个顶点即可。</p><h5 id="曲线图形"><a href="#曲线图形" class="headerlink" title="曲线图形"></a>曲线图形</h5><p>一些特殊曲线，如函数图像等一般记录其解析式。对于圆，直接记录其圆心和半径即可。</p><h3 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h3><ol><li>正弦定理         $ \begin{aligned} \frac{A}{sinA}&#x3D;\frac{b}{sinB}+\frac{c}{sinC}\end{aligned} $</li><li>余弦定理</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h5 id="判断点与直线的位置"><a href="#判断点与直线的位置" class="headerlink" title="判断点与直线的位置"></a>判断点与直线的位置</h5><p>已知直线的方向向量$\mathbf{v}$，以及直线上一点P，判断点Q与直线的关系。</p><p>计算$\mathbf{v}×\overrightarrow {PQ}$，若向量积为（左右相对于方向向量而言）</p><ul><li>负：Q在直线右侧</li><li>正：Q在直线左侧</li><li>0： Q在直线上</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point a,Point b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x * b.y - b.x * a.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_line</span><span class="params">(Point p,Point a,Point b)</span></span>&#123;</span><br><span class="line">Vector v = b - a,u = p - a;   <span class="comment">//vector是向量的意思</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cross</span>(v,u) == <span class="number">0</span>)  cout &lt;&lt; <span class="string">&quot;on&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cross</span>(v,u) &gt; <span class="number">0</span>)  cout &lt;&lt; <span class="string">&quot;left&quot;</span>;</span><br><span class="line"><span class="keyword">else</span>  cout &lt;&lt; <span class="string">&quot;left&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="判断两条线段是否相交"><a href="#判断两条线段是否相交" class="headerlink" title="判断两条线段是否相交"></a>判断两条线段是否相交</h5><ol><li><p>斜率相等，两线段平行，则不可能相交；</p></li><li><p>快速排斥实验：以两线段为对角线的矩形区域若不重叠则一定不相交；</p></li><li><p>跨立实验：分别判断两条线段的两个端点是否位于另一条线段的两侧；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">segment_intersection</span><span class="params">(Point a1,Point a2,Point b1,Point b2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> c1 = <span class="built_in">cross</span>(a2 - a1,b1 - a1), c2 = <span class="built_in">cross</span>(a2 - a1,b2 - a1);</span><br><span class="line"><span class="type">double</span> c3 = <span class="built_in">cross</span>(b2 - b1,a2 - b1), c4 = <span class="built_in">cross</span>(b2 - b1,a1 - b1);</span><br><span class="line"><span class="keyword">return</span> (c1 * c2 &lt;= <span class="number">0</span> &amp;&amp; c3 * c4 &lt;= <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="判断一点是否在多边形内部"><a href="#判断一点是否在多边形内部" class="headerlink" title="判断一点是否在多边形内部"></a>判断一点是否在多边形内部</h5><h6 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h6><p>以该点为端点引出一条射线，如果这条射线与多边形有奇数个交点，则该点在多边形内部，否则该点在多边形外部，我们简记为<strong>奇内偶外</strong>。</p><h6 id="回转数算法"><a href="#回转数算法" class="headerlink" title="回转数算法"></a>回转数算法</h6><p>把该点与多边形的所有顶点连接起来，计算相邻两边夹角的和。注意这里的夹角是<strong>有方向的</strong>。如果夹角和为0，则这个点在多边形外，否则在多边形内。</p><h5 id="求两条直线的交点"><a href="#求两条直线的交点" class="headerlink" title="求两条直线的交点"></a>求两条直线的交点</h5><p>先确定两条直线是否平行，若相交则计算交点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">intersection</span><span class="params">(Point p, Vector v, Point q, Vector w)</span></span>&#123; <span class="comment">//使用点向式表示直线</span></span><br><span class="line">Vector u=p-q;</span><br><span class="line"><span class="type">double</span> t=<span class="built_in">cross</span>(w,u)/<span class="built_in">cross</span>(v,w);</span><br><span class="line"><span class="keyword">return</span> &#123;p.first+t*v.first, p.second+t*v.second&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求任意多边形的周长和面积"><a href="#求任意多边形的周长和面积" class="headerlink" title="求任意多边形的周长和面积"></a>求任意多边形的周长和面积</h5><ol><li><p>三角形的面积</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = (a+b+c) / <span class="number">2</span>;</span><br><span class="line">s = <span class="built_in">sqrt</span>(p * (p-a) * (p-b) * (p-c));</span><br></pre></td></tr></table></figure></li><li><p>多边形的面积</p><p>任取平面上一点P，多边形面积为（以四边形ABCD为例）：</p><p>$ \begin{aligned} S_{多边形面积}&#x3D;\frac{\overrightarrow {PA}×\overrightarrow {AB}+\overrightarrow {PB}×\overrightarrow {BC}+\overrightarrow {PC}×\overrightarrow {CD}+\overrightarrow {PD}×\overrightarrow {DA}}{2}\end{aligned} $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：枚举每个点，这里取原点o作为定点方便计算</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygon_area</span><span class="params">(Point p[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">s += <span class="built_in">cross</span>(p[i],p[i<span class="number">-1</span>]);<span class="comment">//cross是计算叉积</span></span><br><span class="line">s += <span class="built_in">cross</span>(p[n<span class="number">-1</span>],p[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> s / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：枚举多边形的每条边，如上图</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygon_area</span><span class="params">(Point p[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n<span class="number">-1</span>;i++)</span><br><span class="line">s += <span class="built_in">cross</span>(p[i] - p[<span class="number">0</span>],p[i<span class="number">+1</span>] - p[i]);</span><br><span class="line"><span class="keyword">return</span> s / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="圆与直线相关"><a href="#圆与直线相关" class="headerlink" title="圆与直线相关"></a>圆与直线相关</h5><h6 id="求直线与圆的交点"><a href="#求直线与圆的交点" class="headerlink" title="求直线与圆的交点"></a>求直线与圆的交点</h6><p>首先判断直线与圆的位置关系。如果直线与圆相离则无交点，若相切则可以利用切线求出切点与半径所在直线，之后转化为求两直线交点。</p><p>若有两交点，则可以利用勾股定理求出两交点的中点，然后沿直线方向加上半弦长即可。</p><h6 id="求两圆交点"><a href="#求两圆交点" class="headerlink" title="求两圆交点"></a>求两圆交点</h6><p>首先我们判断一下两个圆的位置关系，如果外离或内含则无交点，如果相切，可以算出两圆心连线的方向向量，然后利用两圆半径计算出平移距离，最后将圆心沿这个方向向量进行平移即可。</p><p>如果两圆相交，则必有两个交点，并且关于两圆心连线对称。因此下面只说明一个交点的求法，另一个交点可以用类似方法求出。</p><p>我们先将一圆圆心与交点相连，求出两圆心连线与该连线所成角。这样，将两圆心连线的方向向量旋转这个角度，就是圆心与交点相连形成的半径的方向向量了。沿方向向量方向将圆心平移半径长度即可得到一个交点。</p><h5 id="极角序"><a href="#极角序" class="headerlink" title="极角序"></a>极角序</h5><h2 id="三维计算几何基础"><a href="#三维计算几何基础" class="headerlink" title="三维计算几何基础"></a>三维计算几何基础</h2><h5 id="三正弦定理"><a href="#三正弦定理" class="headerlink" title="三正弦定理"></a>三正弦定理</h5><p>二面角度数为$a$，平面M上有一条射线AC，它和棱AB所成角为$b$，和平面N所成角为$r$，则</p><p>$sin r&#x3D;sina*sinb$</p><h5 id="三余弦定理"><a href="#三余弦定理" class="headerlink" title="三余弦定理"></a>三余弦定理</h5><p>设O为平面上一点，过平面外一点B的直线BO 在面上的射影为AO，OC为面上的一条直线，那么 $∠COB，∠AOC，∠AOB$三角的余弦关系为$cos∠BOC&#x3D;cos∠AOB*cos∠AOC$（$∠AOB$和$∠AOC$只能是锐角）</p><h2 id="常用距离"><a href="#常用距离" class="headerlink" title="常用距离"></a>常用距离</h2><h4 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h4><p><a href="https://www.luogu.com.cn/problem/P3958#ide">欧式距离 中</a></p><h4 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h4><p><a href="https://www.luogu.com.cn/problem/P5098#ide">曼哈顿距离 易</a></p><h4 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h4><p>$d(A,B)&#x3D;max(∣x_1−x_2∣,∣y_1−y_2∣)$</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验报告——视频播放小程序</title>
      <link href="/chunk.github.io/2025/09/02/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/chunk.github.io/2025/09/02/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><ol><li>掌握视频列表的切换方法；</li><li>掌握视频自动播放方法；</li><li>掌握视频随机颜色弹幕效果。</li></ol><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h4 id="创建空项目并完成页面配置"><a href="#创建空项目并完成页面配置" class="headerlink" title="创建空项目并完成页面配置"></a>创建空项目并完成页面配置</h4><ol><li><p>创建新项目</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 160820.png" alt="屏幕截图 2025-09-01 160820" style="zoom:50%;" /></li><li><p>进行页面配置</p><ul><li><p>删除<code>index.wxml</code>、<code>index.wxss</code>和<code>app.wxss</code>中的所有代码；</p>  <img src="/chunk.github.io/images/屏幕截图 2025-09-01 161001.png" alt="屏幕截图 2025-09-01 161001" style="zoom:50%;" /></li><li><p>删除<code>index.js</code>中的所有代码并输入<code>&quot;page&quot;</code>使其自动补全函数；删除<code>app.js</code>中的所有代码并输入<code>&quot;app&quot;</code>使其自动补全函数。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 161046.png" alt="屏幕截图 2025-09-01 161046" style="zoom:50%;" /></li></ul></li><li><p>创建<code>images</code>文件存放播放图标</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 161329.png" alt="屏幕截图 2025-09-01 161329" style="zoom:50%;" /></li></ol><h4 id="视图设计"><a href="#视图设计" class="headerlink" title="视图设计"></a>视图设计</h4><h5 id="导航栏设计"><a href="#导航栏设计" class="headerlink" title="导航栏设计"></a>导航栏设计</h5><p>改动<code>app.json</code>中代码，将导航栏背景改为金棕色</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 161710.png" alt="屏幕截图 2025-09-01 161710" style="zoom:50%;" /><h5 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h5><h6 id="区域1：视频播放器"><a href="#区域1：视频播放器" class="headerlink" title="区域1：视频播放器"></a>区域1：视频播放器</h6><p>使用<code>&lt;video&gt;</code>组件实现一个视频播放器，在<code>index.wxml</code>中添加如图所示代码，其中controls属性用于播放&#x2F;暂停、音量等控制组件。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 162123.png" alt="屏幕截图 2025-09-01 162123" style="zoom:50%;" /><p>可以看到此时播放器未居中，且没有填满一行。接下来我们在<code>index.wxss</code>中添加如图所示代码，将视频组件的宽度调整为填满一行。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 162420.png" alt="屏幕截图 2025-09-01 162420" style="zoom:50%;" /><h6 id="区域2：弹幕发送区域"><a href="#区域2：弹幕发送区域" class="headerlink" title="区域2：弹幕发送区域"></a>区域2：弹幕发送区域</h6><p>使用<code>&lt;view&gt;</code>组件实现一个单行区域，包括文本输入框和发送按钮。在<code>index.wxml</code>中添加如图所示代码，输入框使用<code>&lt;input&gt;</code>实现，发送按钮使用<code>&lt;button&gt;</code>实现。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 162828.png" alt="屏幕截图 2025-09-01 162828" style="zoom:50%;" /><p>可以看到此时的组件为纵向排列，且输入框和发送按钮字体大小不一样，总体外观很丑，之后更改<code>index.wxss</code>中代码。</p><p>通过<code>flex</code>将两个组件改为横向排列，用<code>flex-grow</code>让文本输入框扩展多余空间使区域2填满整行，同时调整字体及背景颜色。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 163425.png" alt="屏幕截图 2025-09-01 163425" style="zoom:50%;" /><h6 id="区域3：视频列表"><a href="#区域3：视频列表" class="headerlink" title="区域3：视频列表"></a>区域3：视频列表</h6><p>使用<code>&lt;view&gt;</code>组件实现一个可扩展的多行区域，每行包括一个播放图标和一个视频标题文本。首先设计第一行效果（后续使用for循环添加多行），在<code>index.wxml</code>中添加如图所示代码。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 163957.png" alt="屏幕截图 2025-09-01 163957" style="zoom:50%;" /><p>之后我们在<code>index.wxss</code>中更新各组件样式，使图标与文字样式更协调。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 165340.png" alt="屏幕截图 2025-09-01 165340" style="zoom:50%;" /><h4 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h4><h5 id="更新播放列表"><a href="#更新播放列表" class="headerlink" title="更新播放列表"></a>更新播放列表</h5><p>在区域3添加<code>wx:for</code>属性，实现循环展示列表。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 170716.png" alt="屏幕截图 2025-09-01 170716" style="zoom:50%;" /><p>然后在JS文件的data属性中追加list数组，用于存放视频信息。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-02 091506.png" alt="屏幕截图 2025-09-02 091506" style="zoom:50%;" /><h5 id="点击播放视频"><a href="#点击播放视频" class="headerlink" title="点击播放视频"></a>点击播放视频</h5><p>在区域3的<code>videoBar</code>部分添加<code>data-url</code>属性和<code>bindtap</code>属性，其中前者用于记录每行视频对应的播放地址，后者用于触发点击事件。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-02 083139.png" alt="屏幕截图 2025-09-02 083139" style="zoom:50%;" /><p>发现运行时控制台报错，更改play函数为图中所示代码。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-02 093337.png" alt="屏幕截图 2025-09-02 093337" style="zoom:50%;" /><h5 id="发送弹幕"><a href="#发送弹幕" class="headerlink" title="发送弹幕"></a>发送弹幕</h5><p>在区域1对<code>&lt;video&gt;</code>组件添加<code>enable-danmu</code>和<code>danmu-btn</code>属性，用于允许发送弹幕和显示“发送弹幕”。</p><p>然后在区域2为文本输入框追加<code>bindinput</code>属性，用于获取弹幕文本内容；为按钮追加<code>bindtap</code>属性，用于触发点击事件。</p><p>并在JS文件中添加相应的<code>getDanmu</code>和<code>sendDanmu</code>函数。</p><p>此时可以成功发送红色弹幕，效果如图所示。</p><img src="/chunk.github.io/images/屏幕截图 2025-09-02 085559.png" alt="屏幕截图 2025-09-02 085559" style="zoom:50%;" /><p>为了可以发送随机颜色的弹幕内容，在JS文件中追加自定义函数<code>getRandomColor</code>函数，通过随机数来随机生成rgb颜色并同步更新<code>sendDanmu</code>函数中关于color的部分:<code>color:getRandomColor()</code></p><img src="/chunk.github.io/images/屏幕截图 2025-09-02 090433.png" alt="屏幕截图 2025-09-02 090433" style="zoom:50%;" /><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><p>小程序可以成功切换视频或停止播放，弹幕功能良好：</p><img src="/chunk.github.io/images/屏幕截图 2025-09-02 090543.png" alt="屏幕截图 2025-09-02 090543" style="zoom:50%;" /><h2 id="问题总结与体会"><a href="#问题总结与体会" class="headerlink" title="问题总结与体会"></a>问题总结与体会</h2><h3 id="遇到的主要问题"><a href="#遇到的主要问题" class="headerlink" title="遇到的主要问题"></a>遇到的主要问题</h3><ol><li><p>打字错误频繁：在编写代码过程中经常打错字母，特别是在写函数名和属性名的时候，导致程序运行出错。需要更加仔细地检查代码拼写。</p></li><li><p>play()函数报错问题：在运行<code>play()</code>函数时遇到了报错，虽然能看懂报错信息，但一开始不明白具体是什么意思。后来询问AI才发现是因为<code>play</code>函数会被<code>pause</code>中断，解决方法是在<code>playVideo</code>函数里加了一个延迟播放的处理。</p></li></ol><h3 id="学习收获"><a href="#学习收获" class="headerlink" title="学习收获"></a>学习收获</h3><ol><li><p>组件设置的深入理解：通过这次实验，对小程序中各种组件的设置有了更深入的理解，特别是<code>&lt;video&gt;</code>组件的各种属性配置。</p></li><li><p><code>wx:for</code>循环的掌握：学会了使用<code>wx:for</code>循环来设置循环输出，这让我能够动态地展示视频列表，而不用手动写很多重复的代码。</p></li><li><p>随机颜色功能实现：学会了如何通过<code>JavaScript</code>生成随机RGB颜色，并应用到弹幕功能中，让弹幕显示更加丰富多彩。</p></li><li><p>事件绑定和数据传递：掌握了如何使用<code>bindtap</code>绑定点击事件，以及通过<code>data-</code>属性传递数据，这些都是小程序开发中的基础但重要的技能。</p></li></ol><p>总的来说，这次实验让我对小程序的开发流程有了更全面的认识，虽然过程中遇到了一些问题，但通过解决这些问题也学到了很多实用的技巧。</p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验报告——微信小程序云开发</title>
      <link href="/chunk.github.io/2025/09/01/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/"/>
      <url>/chunk.github.io/2025/09/01/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><ol><li>学习微信小程序云开发的基础知识。</li><li>能够完成利用文本搜索的功能就好，图像识别、语音识别接口有时有问题，不强求。</li></ol><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h4 id="创建项目及云环境"><a href="#创建项目及云环境" class="headerlink" title="创建项目及云环境"></a>创建项目及云环境</h4><ol><li><p>创建空项目，本实验要选取开发模式为微信云开发；</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 133547.png" alt="屏幕截图 2025-09-01 133547" style="zoom: 50%;" /></li><li><p>点开控制台体验云开发免费资源</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 133656.png" alt="屏幕截图 2025-09-01 133656" style="zoom: 50%;" /><img src="/chunk.github.io/images/屏幕截图 2025-09-01 133734.png" alt="屏幕截图 2025-09-01 133734" style="zoom: 50%;" /></li><li><p>注册百度智能云并实名认证, 创建一个图像应用, 记录相应的<code>API KEY</code> 和<code> SECRET KEY</code></p></li></ol><img src="/chunk.github.io/images/屏幕截图 2025-09-01 142943.png" alt="屏幕截图 2025-09-01 142943" style="zoom:50%;" />                          <img src="/chunk.github.io/images/屏幕截图 2025-09-01 145034.png" alt="屏幕截图 2025-09-01 145034" style="zoom:50%;" />                                  <h4 id="导入垃圾分类数据集"><a href="#导入垃圾分类数据集" class="headerlink" title="导入垃圾分类数据集"></a>导入垃圾分类数据集</h4><p>​在控制台中点击数据集，添加集合并导入相应的数据集。</p>   <img src="/chunk.github.io/images/屏幕截图 2025-09-01 142336.png" alt="屏幕截图 2025-09-01 142336" style="zoom:50%;" /><h4 id="创建及调用云函数代码"><a href="#创建及调用云函数代码" class="headerlink" title="创建及调用云函数代码"></a>创建及调用云函数代码</h4><ol><li><p>在新建的小程序中导入垃圾分类小程序小程序</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 145421.png" alt="屏幕截图 2025-09-01 145421" style="zoom: 50%;" /></li><li><p>在<code>project.config.json</code>文件中添加微信开发工具中的个人appid</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 145542.png" alt="屏幕截图 2025-09-01 145542" style="zoom:50%;" /></li><li><p>在<code>miniprogram</code>文件夹下的<code>app.js</code>中添加云开发的ID<br>云开发环境的ID：打开云开放，界面右上角有一个环境ID，点击复制即可</p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 153852.png" alt="屏幕截图 2025-09-01 153852" style="zoom: 50%;" /><img src="/chunk.github.io/images/屏幕截图 2025-09-01 153825.png" alt="屏幕截图 2025-09-01 153825" style="zoom: 50%;" /></li><li><p>在<code>miniprogram</code>的子文件夹<code>search</code>下的<code>search.js</code>中添加百度云图像识别应用的<code>API Key</code>与 <code>Secret Key</code></p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 153911.png" alt="屏幕截图 2025-09-01 153911" style="zoom: 50%;" /></li><li><p>部署云函数，将<code>cloudfuntions</code>文件夹下的子文件夹全部上传并部署</p><p>右击各个上传的子文件点击<code>上传并部署：云端安装依赖</code></p><img src="/chunk.github.io/images/屏幕截图 2025-09-01 145911.png" alt="屏幕截图 2025-09-01 145911" style="zoom:50%;" /></li></ol><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2>   <img src="/chunk.github.io/images/屏幕截图 2025-09-01 150132.png" alt="屏幕截图 2025-09-01 150132" style="zoom:33%;" />        <img src="/chunk.github.io/images/屏幕截图 2025-09-01 150141.png" alt="屏幕截图 2025-09-01 150141" style="zoom:33%;" />           <img src="/chunk.github.io/images/屏幕截图 2025-09-01 150152.png" alt="屏幕截图 2025-09-01 150152" style="zoom:33%;" />          <img src="/chunk.github.io/images/屏幕截图 2025-09-01 150335.png" alt="屏幕截图 2025-09-01 150335" style="zoom:33%;" />  <h2 id="问题总结与体会"><a href="#问题总结与体会" class="headerlink" title="问题总结与体会"></a>问题总结与体会</h2><h4 id="遇到的主要问题及解决方案"><a href="#遇到的主要问题及解决方案" class="headerlink" title="遇到的主要问题及解决方案"></a>遇到的主要问题及解决方案</h4><ul><li><p>云环境ID配置错误</p><p>一开始没搞清楚云环境ID究竟是什么，最后在谷歌上搜索才发现我写错了导致一直不能搜索。</p></li><li><p>进行数据库的配置时将原先的两个数据集上传到了一个里面导致无法进行匹配</p><p>上传数据集时，需要确保数据集的格式正确，并且在上传前先创建好数据集的集合。</p></li></ul><h4 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h4><p>​在本次实验中，我学会了如何使用微信小程序云开发工具以及百度智能云的图像识别API来构建一个垃圾分类小程序，并从中收获了许多宝贵的经验。<br>​首先，通过搭建和配置云开发环境，我了解云开发架构。云开发能够极大地简化应用的开发流程，特别是对于初学者来说，无需过多关注服务器的管理和底层技术。实验过程中，创建云数据库和云函数的操作非常直观，在云函数中实现业务逻辑、进行数据处理也变得更加简单。<br>​其次，对于百度智能云的图像识别部分，在完成API的配置和调用后，我成功实现了对垃圾图像的识别。这部分让我认识到如何将第三方API与微信小程序结合，并且深刻体会到API调用中的参数配置和数据处理的重要性。<br>​通过这次实验，我对微信小程序云开发的基本过程有了一定的了解。</p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP认证</title>
      <link href="/chunk.github.io/2025/08/30/%E7%BC%96%E7%A8%8B/CSP%E8%AE%A4%E8%AF%81/"/>
      <url>/chunk.github.io/2025/08/30/%E7%BC%96%E7%A8%8B/CSP%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="第36次CCF计算机软件能力认证"><a href="#第36次CCF计算机软件能力认证" class="headerlink" title="第36次CCF计算机软件能力认证"></a>第36次CCF计算机软件能力认证</h1><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a><a href="https://sim.csp.thusaac.com/contest/36/problem/0">移动</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dx = <span class="number">0</span>, dy = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;</span><br><span class="line">        dx = x;</span><br><span class="line">        dy = y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;f&#x27;</span>) dy = y + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;b&#x27;</span>) dy = y - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;l&#x27;</span>) dx = x - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;r&#x27;</span>) dx = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dx &lt;= n &amp;&amp; dx &gt;= <span class="number">1</span> &amp;&amp; dy &lt;= n &amp;&amp; dy &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                x = dx;</span><br><span class="line">                y = dy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dx = x;</span><br><span class="line">                dy = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="梦境巡查"><a href="#梦境巡查" class="headerlink" title="梦境巡查"></a><a href="https://sim.csp.thusaac.com/contest/36/problem/1">梦境巡查</a></h4><p><a href="">前缀和</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="缓存模拟"><a href="#缓存模拟" class="headerlink" title="缓存模拟"></a><a href="https://sim.csp.thusaac.com/contest/36/problem/2">缓存模拟</a></h4><h4 id="跳房子"><a href="#跳房子" class="headerlink" title="跳房子"></a><a href="https://sim.csp.thusaac.com/contest/36/problem/3">跳房子</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"></span><br><span class="line">ll a[N], k[N];</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; k[i];</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) p.<span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">ll u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">ll l = u + <span class="number">1</span>, r = <span class="built_in">min</span>(n, u + k[u]);</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">auto</span> it = p.<span class="built_in">lower_bound</span>(l);</span><br><span class="line"><span class="keyword">while</span> (it != p.<span class="built_in">end</span>() &amp;&amp; *it &lt;= r) &#123;</span><br><span class="line">ll j = *it;</span><br><span class="line">ll pos = j - a[j];</span><br><span class="line"><span class="keyword">if</span> (dp[pos] == <span class="number">-1</span>) &#123;</span><br><span class="line">dp[pos] = dp[u] + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line">it = p.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="梦魔"><a href="#梦魔" class="headerlink" title="梦魔"></a><a href="https://sim.csp.thusaac.com/contest/36/problem/4">梦魔</a></h4><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a><a href="https://sim.csp.thusaac.com/contest/35/problem/0">密码</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; a;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> flag1 = <span class="literal">false</span>, flag2 = <span class="literal">false</span>, flag3 = <span class="literal">false</span>;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">auto</span> it = a.<span class="built_in">find</span>(s[i]);</span><br><span class="line"><span class="keyword">if</span> (it != a.<span class="built_in">end</span>()) a[s[i]]++;</span><br><span class="line"><span class="keyword">else</span> a.<span class="built_in">insert</span>(&#123; s[i],<span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">if</span> (a[s[i]] &gt; <span class="number">2</span>) flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) flag1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) flag1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) flag2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> flag3 = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag1 &amp;&amp; flag2 &amp;&amp; flag3) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://sim.csp.thusaac.com/contest/35/problem/1">字符串变换</a></p><p><a href="https://sim.csp.thusaac.com/contest/35/problem/2">补丁应用</a></p><p><a href="https://sim.csp.thusaac.com/contest/35/problem/3">通讯延迟</a></p><p>根据题意很容易看出做法为建图用迪杰斯特拉算法求最短路径。</p><p>但如果考虑简单建图，会把基站覆盖的点两两相连每个基站覆盖 $k$个点时建$ O(k^2)$条边，当k很大时复杂度会很高。</p><p>则我们考虑用<strong>虚拟节点</strong>：(通俗点说，就是bfs里的节点定义变一下)</p><ol><li><p>区间&#x2F;集合压缩：一个集合内的点可以互相跳转、通信</p><p>为集合建一个虚拟节点s，对集合内每个实际节点u，令：u -&gt; v : 0    v-&gt;u : w</p><p>此时任意u、v之间都要通过s到达，而代价等于原来全连接的权，但此时只需要O(K)条边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n=<span class="number">5</span>;  <span class="comment">//原始点</span></span><br><span class="line"><span class="type">int</span> m=<span class="number">2</span>;  <span class="comment">//两个基站</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;vector&lt;PII&gt; adj(n+m+1); //下标从1开始</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=1;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> virtual_i=i+n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nodes=&#123;1,3,5&#125;;  //假设覆盖点为1、3、5</span><br><span class="line"><span class="type">int</span> w=2;  //权重</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u:nodes)&#123;</span><br><span class="line">adj[u].push_back(&#123;virtual_i,0&#125;);</span><br><span class="line">adj[virtual_i].push_back(&#123;u,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态压缩型：需要收集钥匙、物品才能通过</p><p>状态用掩码实现（难上加难！！！！！！！！！！）</p><p><a href="https://www.luogu.com.cn/problem/P4011#ide">孤岛营救问题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> state;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> key[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">1</span> &lt;&lt; <span class="number">15</span>][<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> door[<span class="number">15</span>][<span class="number">15</span>][<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span> &#125;, dy[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, p, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k;</span><br><span class="line"><span class="built_in">memset</span>(key, <span class="number">0</span>, <span class="built_in">sizeof</span>(key));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">15</span>); i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">15</span>; k++)</span><br><span class="line">dist[i][j][k] = INT_MAX;</span><br><span class="line"><span class="built_in">memset</span>(door, <span class="number">-1</span>, <span class="built_in">sizeof</span>(door));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="type">int</span> x1, y1, x2, y2, g;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; g;</span><br><span class="line">door[x1][y1][x2][y2] = g;</span><br><span class="line">door[x2][y2][x1][y1] = g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, q;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; q;</span><br><span class="line">key[x][y] |= (<span class="number">1</span> &lt;&lt; q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">dist[key[<span class="number">1</span>][<span class="number">1</span>]][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; key[<span class="number">1</span>][<span class="number">1</span>],<span class="number">1</span>,<span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">node u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> step = dist[u.state][u.x][u.y];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (u.x == n &amp;&amp; u.y == m) &#123;</span><br><span class="line">cout &lt;&lt; step &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> new_x = u.x + dx[i];</span><br><span class="line"><span class="type">int</span> new_y = u.y + dy[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (new_x&lt;<span class="number">1</span> || new_x&gt;n || new_y&lt;<span class="number">1</span> || new_y&gt;m) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> barrier = door[u.x][u.y][new_x][new_y];</span><br><span class="line"><span class="keyword">if</span> (barrier == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (barrier &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(u.state &amp; (<span class="number">1</span> &lt;&lt; barrier))) <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> new_state = u.state | key[new_x][new_y];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (step + <span class="number">1</span> &lt; dist[new_state][new_x][new_y]) &#123;</span><br><span class="line">dist[new_state][new_x][new_y] = step + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; new_state,new_x,new_y &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P2622#ide">关灯问题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_STATE = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> steps[MAX_STATE];</span><br><span class="line"><span class="type">int</span> a[<span class="number">105</span>][<span class="number">15</span>]; </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(steps, <span class="number">-1</span>, <span class="built_in">sizeof</span>(steps)); </span><br><span class="line">    <span class="type">int</span> start = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;     </span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    steps[start] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> state = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; steps[state] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> new_state = state;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == <span class="number">1</span> &amp;&amp; (state &amp; (<span class="number">1</span> &lt;&lt; j))) &#123;</span><br><span class="line">                    new_state &amp;= ~(<span class="number">1</span> &lt;&lt; j); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a[i][j] == <span class="number">-1</span> &amp;&amp; !(state &amp; (<span class="number">1</span> &lt;&lt; j))) &#123;</span><br><span class="line">                    new_state |= (<span class="number">1</span> &lt;&lt; j);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (steps[new_state] == <span class="number">-1</span>) &#123;</span><br><span class="line">                steps[new_state] = steps[state] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(new_state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3959">宝藏</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(<span class="number">15</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">15</span>,INT_MAX));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) g[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">u--;</span><br><span class="line">v--;</span><br><span class="line">g[u][v] = <span class="built_in">min</span>(g[u][v], w);</span><br><span class="line">g[v][u] = <span class="built_in">min</span>(g[v][u], w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> all = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">1</span> &lt;&lt; n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">15</span>, INT_MAX));</span><br><span class="line">dp[<span class="number">1</span> &lt;&lt; start][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">min_w</span>(all<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> state = <span class="number">0</span>; state &lt;= all; state++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line"><span class="keyword">if</span> ((state &gt;&gt; u &amp; <span class="number">1</span>) &amp;&amp; g[u][v] &lt; INT_MAX)</span><br><span class="line">min_w[state][v] = <span class="built_in">min</span>(min_w[state][v], g[u][v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> state = <span class="number">0</span>; state &lt;= all; state++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> depth = <span class="number">0</span>; depth &lt; n; depth++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[state][depth] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> s = all ^ state;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> subset = s; subset; subset = (subset - <span class="number">1</span>) &amp; s) &#123;</span><br><span class="line"><span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line"><span class="keyword">if</span> (subset &gt;&gt; u &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (min_w[state][u] == INT_MAX) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cost += min_w[state][u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> new_state = state | subset;</span><br><span class="line"><span class="type">int</span> new_cost = dp[state][depth] + cost * (depth + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (dp[new_state][depth + <span class="number">1</span>] &gt; new_cost) dp[new_state][depth + <span class="number">1</span>] = new_cost;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> depth = <span class="number">0</span>; depth &lt; n; depth++) ans = <span class="built_in">min</span>(ans, dp[all][depth]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>操作序列型：在不同状态间进行转换操作</p></li><li><p>时间维度型：图结构随时间变化，不同时间道路可用性不同</p></li><li><p>多目标型：需要同时优化多个目标，如最短路和次短路</p></li><li><p>免费次数型： K 次免费通过边的机会，求使用最多 K 次免费后的最短路</p><p>建多层图，每一层分别表示用了几次免费，$u_0,u_1,……,u_k$，建二维dist数组更新最小距离，有：</p><ul><li>使用免费票：<code>dist[layer+1][v]=dist[layer][u]</code></li><li>不使用免费票：<code>dist[layer][v]=dist[layer][u]+cost(v,u)</code></li></ul><p><a href="https://www.luogu.com.cn/problem/P4568">飞行路线</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;edge&gt;&gt; <span class="built_in">adj</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        adj[a].<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">        adj[b].<span class="built_in">push_back</span>(&#123;a, c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用二维数组 dist[layer][node]</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(k<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, INT_MAX));</span><br><span class="line">    <span class="keyword">using</span> State = pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;; <span class="comment">// &#123;distance, &#123;layer, node&#125;&#125;</span></span><br><span class="line">    priority_queue&lt;State, vector&lt;State&gt;, greater&lt;State&gt;&gt; pq;</span><br><span class="line">    </span><br><span class="line">    dist[<span class="number">0</span>][s] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, &#123;<span class="number">0</span>, s&#125;&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, state] = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">auto</span> [layer, u] = state;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (d != dist[layer][u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == t) <span class="keyword">continue</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : adj[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = e.to, w = e.w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不使用免费机会</span></span><br><span class="line">            <span class="keyword">if</span> (dist[layer][v] &gt; d + w) &#123;</span><br><span class="line">                dist[layer][v] = d + w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[layer][v], &#123;layer, v&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用免费机会（如果还有）</span></span><br><span class="line">            <span class="keyword">if</span> (layer &lt; k &amp;&amp; dist[layer<span class="number">+1</span>][v] &gt; d) &#123;</span><br><span class="line">                dist[layer<span class="number">+1</span>][v] = d;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dist[layer<span class="number">+1</span>][v], &#123;layer<span class="number">+1</span>, v&#125;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dist[i][t]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1948#ide">电话线</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, p, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;edge&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, l;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; l;</span><br><span class="line">        adj[a].<span class="built_in">push_back</span>(&#123; b, l &#125;);</span><br><span class="line">        adj[b].<span class="built_in">push_back</span>(&#123; a, l &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dist</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;ll&gt;(n + <span class="number">1</span>, LLONG_MAX));</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        PII a = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        ll d = a.first;</span><br><span class="line">        <span class="type">int</span> layer = a.second.first;</span><br><span class="line">        <span class="type">int</span> u = a.second.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d != dist[layer][u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == n) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            edge e = adj[u][i];</span><br><span class="line">            <span class="type">int</span> v = e.to;    </span><br><span class="line">            ll w = e.w; </span><br><span class="line"></span><br><span class="line">            ll new_cost = <span class="built_in">max</span>(d, w);</span><br><span class="line">            <span class="keyword">if</span> (new_cost &lt; dist[layer][v]) &#123;</span><br><span class="line">                dist[layer][v] = new_cost;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[layer][v], <span class="built_in">make_pair</span>(layer, v)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (layer &lt; k &amp;&amp; d &lt; dist[layer + <span class="number">1</span>][v]) &#123;</span><br><span class="line">                dist[layer + <span class="number">1</span>][v] = d;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(d, <span class="built_in">make_pair</span>(layer + <span class="number">1</span>, v)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = LLONG_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i][n] &lt; ans) &#123;</span><br><span class="line">            ans = dist[i][n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == LLONG_MAX) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P2939#ide">约翰的牛</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">1</span>, t = n; </span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;edge&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        ll t;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t;</span><br><span class="line">        adj[a].<span class="built_in">push_back</span>(&#123; b, t &#125;);</span><br><span class="line">        adj[b].<span class="built_in">push_back</span>(&#123; a, t &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;ll, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;;</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">dist</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;ll&gt;(n + <span class="number">1</span>, LLONG_MAX));</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    dist[<span class="number">0</span>][s] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123; <span class="number">0</span>, &#123;<span class="number">0</span>, s&#125; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pii p = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        ll d = p.first;</span><br><span class="line">        <span class="type">int</span> layer = p.second.first;</span><br><span class="line">        <span class="type">int</span> u = p.second.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d != dist[layer][u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == t) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : adj[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = e.to;</span><br><span class="line">            ll w = e.w;</span><br><span class="line">            <span class="keyword">if</span> (layer &lt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[layer][u] &lt; dist[layer + <span class="number">1</span>][v]) &#123;</span><br><span class="line">                    dist[layer + <span class="number">1</span>][v] = dist[layer][u];</span><br><span class="line">                    pq.<span class="built_in">push</span>(&#123; dist[layer + <span class="number">1</span>][v], &#123;layer + <span class="number">1</span>, v&#125; &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dist[layer][u] + w &lt; dist[layer][v]) &#123;</span><br><span class="line">                dist[layer][v] = dist[layer][u] + w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123; dist[layer][v], &#123;layer, v&#125; &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll ans = LLONG_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[i][t] &lt; ans) &#123;</span><br><span class="line">            ans = dist[i][t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    ll to, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Station</span> &#123;</span><br><span class="line">    ll x, y, r, t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">x</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">y</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    <span class="function">vector&lt;Station&gt; <span class="title">station</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; station[i].x &gt;&gt; station[i].y &gt;&gt; station[i].r &gt;&gt; station[i].t;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N = n + m;</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adj</span>(N + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ll x1 = station[i].x - station[i].r, x2 = station[i].x + station[i].r;</span><br><span class="line">        ll y1 = station[i].y - station[i].r, y2 = station[i].y + station[i].r;</span><br><span class="line">        <span class="type">int</span> virtualId = n + i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[j] &gt;= x1 &amp;&amp; x[j] &lt;= x2 &amp;&amp; y[j] &gt;= y1 &amp;&amp; y[j] &lt;= y2) &#123;</span><br><span class="line">                adj[j].<span class="built_in">push_back</span>(&#123; virtualId,<span class="number">0</span> &#125;);</span><br><span class="line">                adj[virtualId].<span class="built_in">push_back</span>(&#123; j,station[i].t &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(N + <span class="number">1</span>, LLONG_MAX)</span></span>;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> edge= pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        ll d = edge.first;</span><br><span class="line">        <span class="type">int</span> u = edge.second;</span><br><span class="line">        <span class="keyword">if</span> (d != dist[u]) <span class="keyword">continue</span>;  <span class="comment">//状态过期判断，提高效率</span></span><br><span class="line">        <span class="keyword">if</span> (u == n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : adj[u]) &#123;</span><br><span class="line">            ll v = e.to;</span><br><span class="line">            ll w = e.w;</span><br><span class="line">            <span class="keyword">if</span> (dist[u] + w &lt; dist[v]) &#123;</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123; dist[v], v &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == LLONG_MAX) cout &lt;&lt; <span class="string">&quot;Nan\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://sim.csp.thusaac.com/contest/35/problem/4">木板切割</a></p><p>34</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int n, m, p, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; q;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; a(n, vector&lt;int&gt;(m));</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">for (int j = 0; j &lt; m; j++)</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">int count = 1;</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">if ((count) % q == 0) cout &lt;&lt; a[i][j] &lt;&lt; endl;</span><br><span class="line">else cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSP认证，编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSP认证，洛谷，编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的神奇妙用</title>
      <link href="/chunk.github.io/2025/08/27/%E7%BC%96%E7%A8%8B/%E6%A0%91%E7%9A%84%E7%A5%9E%E5%A5%87%E5%A6%99%E7%94%A8/"/>
      <url>/chunk.github.io/2025/08/27/%E7%BC%96%E7%A8%8B/%E6%A0%91%E7%9A%84%E7%A5%9E%E5%A5%87%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>本文例题均来自于刘汝佳老师的《算法竞赛入门经典》，均可在 <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=827">UVa</a> 提交</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="邻接表（万能的）"><a href="#邻接表（万能的）" class="headerlink" title="邻接表（万能的）"></a>邻接表（万能的）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,in v)</span></span>&#123;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(v:g[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bfs示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(N, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dist[v] = dist[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父节点数组-倍增表"><a href="#父节点数组-倍增表" class="headerlink" title="父节点数组 + 倍增表"></a>父节点数组 + 倍增表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> parent[N][LOG], depth[N];</span><br></pre></td></tr></table></figure><h4 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; euler; </span><br><span class="line"><span class="type">int</span> first[N]; <span class="comment">// first[u] = u 在欧拉序的出现位置</span></span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">Node *lchild,*rchild;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">lchild</span>(<span class="literal">NULL</span>),<span class="built_in">rchild</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">bulid_tree</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">cin &gt;&gt; val;</span><br><span class="line"><span class="keyword">if</span>(val==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">Node* root=<span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">root-&gt;lchild=<span class="built_in">build_tree</span>();</span><br><span class="line">root-&gt;rchild=<span class="built_in">build_tree</span>();</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组存储——完全二叉树-堆"><a href="#数组存储——完全二叉树-堆" class="headerlink" title="数组存储——完全二叉树&#x2F;堆"></a>数组存储——完全二叉树&#x2F;堆</h4><p>下标从<code>1（root）</code>开始，<code>i</code>的左孩子是<code>2*i</code>，右孩子是<code>2*i+1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tree[N],n=<span class="number">1</span>;</span><br><span class="line">tree[n++]=val; <span class="comment">//层次遍历</span></span><br></pre></td></tr></table></figure><h2 id="树和二叉树基础"><a href="#树和二叉树基础" class="headerlink" title="树和二叉树基础"></a>树和二叉树基础</h2><h4 id="二叉树的编号"><a href="#二叉树的编号" class="headerlink" title="二叉树的编号"></a>二叉树的编号</h4><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=620">UVa 679 小球下落</a></p><p>当第$i$个小球落到机关上时掉落方向与前$i-1$个小球中落到该机关的小球数量有关，假设此前有$k$个小球落到此机关：</p><ul><li>若$k$为偶数，此时机关为$false$，第$i$个小球落向左边 → $i$为奇数</li><li>若$k$为奇数，第$i$个小球落向右边 →$i$为偶数</li></ul><p>如果我们按掉落的层数来分析，可以看出：每个小球都需要下落$D-1$层，在每一层，只需要考虑当前小球是落到此处的第几个小球。</p><blockquote><p>在完全二叉树中，对于结点k，其左、右孩子对应的编号为<code>2*k，2*k+1</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="type">int</span> d, n;</span><br><span class="line">cin &gt;&gt; d &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; d; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line">ans = ans*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">n = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">ans = ans * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=58">UVa 122 树的层次遍历</a></p><p>难点：如何处理输入构建二叉树？</p><blockquote><ol><li><code>sscanf(&amp;str,&quot;*&quot;,&amp;path)</code>：读取字符串<code>str</code>格式为*的字串存入path<ul><li>当要完整解析整个字符串，用<code>str.c_str()</code></li><li>当想跳过前面若干字符时，用<code>&amp;str[i]</code>，会从<code>str[i]</code>开始</li><li>格式：<code>%d，(%d, %s)，(%d,%[^ )])</code><ul><li><code>%[^)]</code>—读取连续字符直到读到<code>&#39;)&#39;</code>结束</li></ul></li></ul></li><li><code>str.c_str()</code>：返回一个指向该字符串内容的 <code>const char*</code>的指针</li></ol></blockquote><p>初始考虑用数组存二叉树，当为$’R’$时存储位置下标$*2$，为$’L’$时，存储位置下标$*2+1$，建树过程中检查是否有重复赋值的情况，建完树之后检查是否有父节点未赋值的情况，输出层次遍历即按序输出数组元素。</p><p>但树结点不超过256，若为单边链表数组空间太大无法存储。</p><p>于是还是考虑用链表建树，最后bfs输出树的层次遍历（或用哈希表存储二叉树）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* lchild;</span><br><span class="line">    Node* rchild;</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="number">-1</span>), <span class="built_in">lchild</span>(<span class="literal">NULL</span>), <span class="built_in">rchild</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">build</span><span class="params">(Node*&amp; root, <span class="type">int</span> val, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    Node* cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;lchild) cur-&gt;lchild = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            cur = cur-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;rchild) cur-&gt;rchild = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            cur = cur-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;val != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    cur-&gt;val = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;lchild) q.<span class="built_in">push</span>(cur-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;rchild) q.<span class="built_in">push</span>(cur-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node*&amp; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">remove</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">remove</span>(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        vector&lt;string&gt; node;</span><br><span class="line">        <span class="keyword">if</span> (!(cin &gt;&gt; s)) <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">&quot;()&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        node.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != <span class="string">&quot;()&quot;</span>) &#123;</span><br><span class="line">            node.<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node* root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : node) &#123;</span><br><span class="line">            <span class="type">char</span> cpath[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            <span class="built_in">sscanf</span>(str.<span class="built_in">c_str</span>(), <span class="string">&quot;(%d,%[^)])&quot;</span>, &amp;val, cpath); </span><br><span class="line">            string path = cpath;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">build</span>(root, val, path)) ok = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ok || !<span class="built_in">bfs</span>(root)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;not complete\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">remove</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h4><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=489">UVa 548 树</a></p><p>按照中序、后序遍历建树，最后对树dfs求最小路径。</p><blockquote><p>如何由中序、后序遍历构建二叉树？</p><ol><li>从后序序列中取出最后一位即为根节点；</li><li>在中序序列中找到根节点位置，其左边即为左子树，右边即为右子树</li></ol><p>递归建树。</p></blockquote><p>主要是在递归建树时中后序序列的范围容易写错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">build</span><span class="params">(<span class="type">int</span> in_start,<span class="type">int</span> in_end,<span class="type">int</span> post_start,<span class="type">int</span> post_end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (in_start &gt; in_end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">Node* cur = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"><span class="type">int</span> root = post_order[post_end];</span><br><span class="line">cur-&gt;val = root;</span><br><span class="line"><span class="type">int</span> k = in_start;</span><br><span class="line"><span class="keyword">while</span> (in_order[k] != root) k++;</span><br><span class="line"><span class="type">int</span> left_len = k - in_start;</span><br><span class="line">cur-&gt;lchild = <span class="built_in">build</span>(in_start, k - <span class="number">1</span>, post_start, post_start + left_len - <span class="number">1</span>);</span><br><span class="line">cur-&gt;rchild = <span class="built_in">build</span>(k + <span class="number">1</span>, in_end, post_start + left_len, post_end - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该树dfs，在递归的过程中不断更新最小路径及最小树叶权重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> in_order[<span class="number">10001</span>], post_order[<span class="number">10001</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> min_sum = INT_MAX, ans = INT_MAX;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> val=<span class="number">-1</span>;</span><br><span class="line">Node *lchild = <span class="literal">NULL</span>, *rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">sum += root-&gt;val;</span><br><span class="line"><span class="keyword">if</span> (!root-&gt;lchild &amp;&amp; !root-&gt;rchild) &#123;</span><br><span class="line"><span class="keyword">if</span> (min_sum &gt; sum || (min_sum == sum &amp;&amp; root-&gt;val &lt; ans)) &#123;</span><br><span class="line">min_sum=sum;</span><br><span class="line">ans=root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;lchild) <span class="built_in">dfs</span>(root-&gt;lchild, sum);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;rchild) <span class="built_in">dfs</span>(root-&gt;rchild, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string inorder, postorder;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, inorder)) &#123;</span><br><span class="line"><span class="keyword">if</span> (inorder.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">getline</span>(cin, postorder);</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(inorder)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; x) in_order[n++] = x;</span><br><span class="line"><span class="function">stringstream <span class="title">ss1</span><span class="params">(postorder)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">ss1 &gt;&gt; x;</span><br><span class="line">post_order[i] = x;</span><br><span class="line">&#125;</span><br><span class="line">min_sum = INT_MAX, ans = INT_MAX;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">Node* root=<span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);  <span class="comment">//见上</span></span><br><span class="line"><span class="built_in">dfs</span>(root, sum);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=780">UVa 839 天平</a></p><p>难点在于对子天平的处理，子天平需要考虑以下两个方面：</p><ul><li>子天平是否平衡</li><li>子天平的重量对整个天平的影响</li></ul><p>即，我们需要做的是：</p><ul><li>判断子天平是否平衡</li><li>计算出天平左右的总重量，再判断是否平衡</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span>&amp; w)</span> </span>&#123;   <span class="comment">//输入天平，判断其子天平是否平衡，同时更新w为子天平的总质量</span></span><br><span class="line"><span class="type">int</span> w1, d1, w2, d2;</span><br><span class="line"><span class="type">int</span> flag1 = <span class="literal">true</span>, flag2 = <span class="literal">true</span>;</span><br><span class="line">cin &gt;&gt; w1 &gt;&gt; d1 &gt;&gt; w2 &gt;&gt; d2;</span><br><span class="line"><span class="keyword">if</span> (!w1) flag1=<span class="built_in">solve</span>(w1);</span><br><span class="line"><span class="keyword">if</span> (!w2) flag2=<span class="built_in">solve</span>(w2);</span><br><span class="line">w = w1 + w2;</span><br><span class="line"><span class="keyword">return</span> flag1 &amp;&amp; flag2 &amp;&amp; (w1 * d1 == w2 * d2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">solve</span>(w)) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(t) cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=640">UVa 699 下落的树叶</a></p><p>此题二叉树选择用数组存储，将根节点存在下标为0处，然后分别递归存储左右子树，因为出现了负下标，因此我们选择使用哈希表存储树。</p><p>通过<code>build(pos - 1); build(pos + 1);</code>不断递归建树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; tree;</span><br><span class="line"><span class="type">int</span> min_pos = <span class="number">0</span>, max_pos = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">tree[pos] += x;</span><br><span class="line"><span class="keyword">if</span> (pos &lt; min_pos) min_pos = pos;</span><br><span class="line"><span class="keyword">if</span> (pos &gt; max_pos) max_pos = pos;</span><br><span class="line"><span class="built_in">build</span>(pos - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(pos + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">tree.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">tree[<span class="number">0</span>] += x;</span><br><span class="line">min_pos = <span class="number">0</span>;</span><br><span class="line">max_pos = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; index++ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = min_pos; i &lt;= max_pos; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; min_pos) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; tree[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=838&page=show_problem&problem=1503">UVa 10562 看图写树</a></p><p>难点：如何处理输入的画——利用二维数组存储，之后递归处理打印字符即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=477">UVa 536 二叉树重建</a></p><p>由前序+中序输出后序，与前面那题相似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string pre_order, in_order;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">char</span> val = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">Node* lchild = <span class="literal">NULL</span>, * rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node* <span class="title">build</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l1 &gt; r1) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">Node* cur = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">cur-&gt;val = pre_order[l1];</span><br><span class="line"><span class="type">int</span> k = l2;</span><br><span class="line"><span class="keyword">while</span> (k &lt;= r2 &amp;&amp; in_order[k] != pre_order[l1]) k++;</span><br><span class="line">cur-&gt;lchild = <span class="built_in">build</span>(l1 + <span class="number">1</span>, l1 + k - l2, l2, k - <span class="number">1</span>);</span><br><span class="line">cur-&gt;rchild = <span class="built_in">build</span>(l1 + <span class="number">1</span> + k - l2 , r1, k + <span class="number">1</span>, r2);</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post_order</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;lchild) <span class="built_in">post_order</span>(root-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;rchild) <span class="built_in">post_order</span>(root-&gt;rchild);</span><br><span class="line">cout &lt;&lt; root-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; pre_order &gt;&gt; in_order) &#123;</span><br><span class="line"><span class="keyword">if</span> (!pre_order.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">n = pre_order.<span class="built_in">size</span>();</span><br><span class="line">Node* root=<span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">post_order</span>(root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=839&page=show_problem&problem=3318">UVa 12166 修改天平</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, sum;</span><br><span class="line"><span class="type">char</span> exp[<span class="number">1500000</span>];</span><br><span class="line">map&lt;LL, <span class="type">int</span>&gt; ID;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exp[l] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exp[i] == <span class="string">&#x27;[&#x27;</span>) p++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (exp[i] == <span class="string">&#x27;]&#x27;</span>) p--;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; exp[i] == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(l + <span class="number">1</span>, i - <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">dfs</span>(i + <span class="number">1</span>, r - <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line">        <span class="built_in">sscanf</span>(exp + l, <span class="string">&quot;%d&quot;</span>, &amp;weight);</span><br><span class="line">        ID[(LL)weight * (<span class="number">1</span> &lt;&lt; depth)]++;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iCase;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;iCase);</span><br><span class="line">    <span class="keyword">while</span> (iCase--) &#123;</span><br><span class="line">        ID.<span class="built_in">clear</span>();</span><br><span class="line">        cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, exp);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="built_in">strlen</span>(exp) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        map&lt;LL, <span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">        <span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (iter = ID.<span class="built_in">begin</span>(); iter != ID.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">            Max = Max &gt; iter-&gt;second ? Max : iter-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum - Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1351">UVa 10410 树重建</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) == <span class="number">1</span>) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">children</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读 BFS 序列，记录位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            pos[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> root;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;root);</span><br><span class="line">        stk.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历剩余 n-1 个 DFS 序列元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> t = stk.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">// 判断 x 是否是 t 的子节点</span></span><br><span class="line">                <span class="keyword">if</span> (t == root || pos[x] &gt; pos[t] + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 是 child</span></span><br><span class="line">                    children[t].<span class="built_in">push_back</span>(x);</span><br><span class="line">                    stk.<span class="built_in">push</span>(x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不是，说明应当回溯</span></span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c : children[i]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fa;</span><br><span class="line"><span class="built_in">UnionFind</span>(<span class="type">int</span> num) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">fa.<span class="built_in">push_back</span>(i);   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fa[n] == n) <span class="keyword">return</span> n;</span><br><span class="line">fa[n] = <span class="built_in">find</span>(fa[n]);</span><br><span class="line"><span class="keyword">return</span> fa[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> fa1 = <span class="built_in">find</span>(a), fa2 = <span class="built_in">find</span>(b);</span><br><span class="line">fa[fa1] = fa2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程，《算法竞赛入门经典》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验报告——天气预报</title>
      <link href="/chunk.github.io/2025/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/"/>
      <url>/chunk.github.io/2025/08/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>1、掌握服务器域名配置和临时服务器部署；</p><p>2、掌握 wx.request 接口的用法。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li><p>申请API密钥</p><ul><li><p>选择可以提供全球气象数据服务s接口的和风天气API，首先进入官方网址，输入邮箱免费注册；</p><img src="/chunk.github.io/images/image-20250826082930902.png" alt="实验结果" style="zoom: 33%;" />   <img src="/chunk.github.io/images/image-20250826083128319.png" style="zoom: 25%;" /></li><li><p>注册完成后访问控制台查看账号信息，依据官方文档成功生成API KEY，记录该key。（API KEY可以用于在小程序发出网络请求时作为身份识别的标识一起发送给和风天气的第三方服务器）</p><img src="/chunk.github.io/images/image-20250826085659494.png" style="zoom: 50%;" /></li></ul></li><li><p>调用API</p><ul><li><p>取出在和风天气中的API KEY及API Host</p></li><li><p>访问<a href="https://mn5xmd96fj.re.qweatherapi.com//v7/weather/now?location=101010100&key=f40427d91c8c43a9a7db17aede262b09">https://mn5xmd96fj.re.qweatherapi.com//v7/weather/now?location=101010100&amp;key=f40427d91c8c43a9a7db17aede262b09</a>。</p><blockquote><p>weather关键字代表获取实况天气，基于weather的接口有两个必填参数，分别为city和key，其中，city表示要查询的城市，此处选取城市ID为主要参数，key即为开发者的API KEY。</p></blockquote></li></ul><img src="/chunk.github.io/images/image-20250826140547601.png" style="zoom:50%;" /></li><li><p>服务器域名配置</p><p>登录微信公众平台，进入小程序管理员后台，在“开发设置面板”的“服务器域名”中添加或修改所需要的网络通信的服务器域名地址。此小程序主要需要添加的为request合法域名，即为开发者在和风天气中的API Host。</p><img src="/chunk.github.io/images/image-20250826100200164.png" style="zoom:50%;" /></li></ol><h4 id="小程序开发"><a href="#小程序开发" class="headerlink" title="小程序开发"></a>小程序开发</h4><h6 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h6><p>在微信开发者工具新建空项目。</p><img src="/chunk.github.io/images/image-20250826100730046.png" alt="image-20250826100730046" style="zoom:33%;" /><h6 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h6><ol><li><p>创建页面文件</p><p>在根目录下生成文件夹pages存放页面文件，首页默认为index。</p><img src="/chunk.github.io/images/image-20250826101006438.png" style="zoom:50%;" /></li><li><p>删除和修改文件</p><ul><li><p>删除<code>utils</code>文件夹及其所有内容；</p></li><li><p>删除<code>pages</code>文件夹下的<code>logs</code>目录及其所有内容；</p></li><li><p>删除<code>index.wxml</code>、<code>index.wxss</code>和<code>app.wxss</code>的所有代码；</p></li><li><p>删除<code>index.js</code>的全部代码，输入关键词”page”自动补全函数；</p></li><li><p>删除的<code>app.js</code>的所有代码，输入关键词”app”自动补全函数。</p><img src="/chunk.github.io/images/image-20250826101308791.png" style="zoom: 33%;" />  <img src="/chunk.github.io/images/image-20250826101345252.png" style="zoom:33%;" /></li></ul></li><li><p>创建其他文件</p><p>本项目还需要一个文件夹用存放天气图标素材，素材均来自于和风天气官网。在根目录下新建images文件夹及其子文件夹weather_icon，将图片文件全部复制进去。（需要注意的是，为了使图片更加覆盖各种天气，这里下载的是和风天气官网提供的完整zip，但图片格式为<code>.svg</code>）</p><img src="/chunk.github.io/images/image-20250826141142734.png" style="zoom: 50%;" /></li></ol><h6 id="视图设计"><a href="#视图设计" class="headerlink" title="视图设计"></a>视图设计</h6><ol><li><p>导航栏设计</p><p>更改<code>app.json</code>文件将导航栏标题和背景改为自定义颜色。</p><p>图中所示代码改为蓝色背景色，预览效果如图。</p><img src="/chunk.github.io/images/image-20250826102930658.png" style="zoom:33%;" /></li><li><p>页面设计</p><blockquote><p>本小程序页面主要包含4个区域：</p><ol><li>区域1： 地区选择器，用户可以自行选择查询的省、市、区；</li><li>区域2： 显示当前城市的温度和天气状态的文字说明；</li><li>区域3： 显示当前城市的天气图标；</li><li>区域4： 分多行显示其他天气信息，如湿度、气压、能见度和风向。</li></ol></blockquote><p>具体使用的组件如下：</p><ul><li><code>&lt;view&gt;</code></li><li><code>&lt;picker&gt;</code></li><li><code>&lt;image&gt;</code></li></ul><p>首先，定义页面的容器<code>container</code>并在<code>app.wxss</code>中设置容器样式，包括高度、布局、是否居中以及间距。</p><img src="/chunk.github.io/images/image-20250826103312691.png" alt="image-20250826103312691" style="zoom:33%;" /><p>接着，添加各种组件元素。</p><ul><li><p>区域1：使用<code>&lt;picker&gt;</code>组件完成，用户可以点击切换其他城市，组件内部随意填写一个城市名称（相当于默认城市），当点击城市名称时会从底部弹出控件让用户进行省、市、区的选择；</p><img src="/chunk.github.io/images/image-20250826103530348.png" style="zoom: 50%;" /></li><li><p>区域2：主要是进行文字的设计，包括当前城市的温度和天气状况；</p><img src="/chunk.github.io/images/image-20250826103748981.png" style="zoom:50%;" /></li><li><p>区域3：将天气图标导入（由于文件中下载的是<code>.svg</code>的图标，因此在image组件内部必须注意要写为：<code>/images/weather_icon/1.svg</code>)；</p><img src="/chunk.github.io/images/image-20250826104114273.png" style="zoom: 33%;" /></li><li><p>区域4：展示多行天气信息，使用<code>detail</code>，接着定义需要的单元行（<code>bar</code>），在每行内部定义单元格(<code>box</code>)。</p><img src="/chunk.github.io/images/image-20250826105124992.png" alt="image-20250826105124992" style="zoom: 33%;" /></li></ul></li></ol><h6 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h6><ol><li><p>更新省、市、区信息</p><p>将<code>picker</code>组件中的具体省份改为<code>&#123;&#123;region&#125;&#125;</code>，接着为该组件追加自定义的<code>bindchange</code>事件，用于监听选项变化；</p><img src="/chunk.github.io/images/image-20250826144726629.png" alt="image-20250826144726629" style="zoom:50%;" /><p>由于地区选择器的返回结果是数组的形式，因此在JS文件的data中定义一个包含省、市、区三个项目的数组，初始信息由开发者自己定义。</p><p><img src="/chunk.github.io/chunk.github.io/images/image-20250826105504046.png" alt="image-20250826105504046"></p></li><li><p>获取实况天气数据</p><p>在JS文件中添加自定义<code>getWeather</code>函数进行实况天气数据的获取，后续的天气查询以城市作为查询依据。</p><img src="/chunk.github.io/images/image-20250826145104775.png" alt="image-20250826145104775" style="zoom:50%;" /><p>将定义的<code>getWeather</code>函数在生命周期函数<code>onLoad</code>和<code>regionChange</code>中分别调用，表示当页面加载时和切换城市时均主动获取一次实况天气数据。</p><img src="/chunk.github.io/images/image-20250826150017775.png" alt="image-20250826150017775" style="zoom:50%;" /><p>编译后重新运行会在控制台得到第三方服务器发挥的JSON数据，如图所示。</p><img src="/chunk.github.io/images/image-20250826111501997.png" alt="image-20250826111501997" style="zoom:50%;" /></li><li><p>更新页面天气信息</p><p>将WXML页面上的所有零食数据都替换成<code>&#123;&#123;now.属性&#125;&#125;</code>的形式，为了加快获取数据的速度，最好在IS文件的<code>data</code>中为<code>now</code>规定初始数据，在获取到实际数据之前可以临时显示这些数据。</p><img src="/chunk.github.io/images/image-20250826150403170.png" alt="image-20250826150403170" style="zoom:50%;" /><img src="/chunk.github.io/images/image-20250826150557076.png" alt="image-20250826150557076" style="zoom:50%;" /></li></ol><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2><p>可以成功获取动态获取各城市天气：<br><img src="/chunk.github.io/images/image-20250826131959017.png" alt="image-20250826131959017" style="zoom:33%;" /><br><img src="/chunk.github.io/images/image-20250826131934346.png" alt="image-20250826131934346" style="zoom:33%;" /></p><h2 id="问题总结与体会"><a href="#问题总结与体会" class="headerlink" title="问题总结与体会"></a>问题总结与体会</h2><h5 id="主要问题及解决方案"><a href="#主要问题及解决方案" class="headerlink" title="主要问题及解决方案"></a>主要问题及解决方案</h5><ol><li><p>API配置问题</p><ul><li><p>问题：URL地址不完整，域名未加入白名单</p></li><li><p>解决：配置完整API地址，在小程序后台添加域名白名单</p></li></ul></li><li><p>参数格式错误</p><ul><li><p>问题：使用城市名称而非城市代码</p></li><li><p>解决：建立城市名称到代码的映射关系</p></li></ul></li><li><p>数据字段不匹配</p><ul><li><p>问题：API返回字段与代码期望字段不一致</p></li><li><p>解决：修正字段映射关系</p></li></ul></li><li><p>图标格式错误</p><ul><li><p>问题：代码引用<code>PNG</code>格式，实际为<code>SVG</code>格式</p></li><li><p>解决：修改图标路径为正确的<code>SVG</code>格式</p></li></ul></li><li><p>缺少动态更新</p><ul><li><p>问题：<code>location</code>参数硬编码，无法动态切换城市</p></li><li><p>解决：实现<code>getCityCode</code>函数，支持动态城市代码获取</p></li></ul></li></ol><h5 id="主要收获"><a href="#主要收获" class="headerlink" title="主要收获"></a>主要收获</h5><ol><li>微信小程序开发技能<ul><li>学会了picker组件的多级联动，支持省市区三级选择</li><li>理解了数据绑定机制和<code>setData</code>的使用方法</li><li>更加熟悉小程序的生命周期函数（<code>onLoad</code>、<code>onShow</code>等）</li></ul></li><li>网络编程与API集成<ul><li>学会了使用<code>wx.request</code>接口，了解API及服务器域名配置</li><li>掌握了JSON数据的解析和字段映射技巧</li></ul></li><li>调试与问题解决能力<ul><li>熟练使用微信开发者工具的调试功能和网络面板</li><li>掌握了系统性的问题分析方法：问题定位→原因分析→解决方案→验证测试</li><li>提升了阅读官方文档和API文档的能力</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验报告——第一个微信小程序</title>
      <link href="/chunk.github.io/2025/08/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/chunk.github.io/2025/08/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>1、学习使用快速启动模板创建小程序的方法；</p><p>2、学习不使用模板手动创建小程序的方法。</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h4 id="自动生成小程序"><a href="#自动生成小程序" class="headerlink" title="自动生成小程序"></a>自动生成小程序</h4><ul><li><p>在微信开发者工具中选择模板创建项目，如图所示；</p><p>依次填写项目名称、目录和 AppID 就可以新建一个小程序项目。其中项目名称为开发者自定义，仅供开发者工具管理使用；目录即为项目文件存放的路径地址；AppID为管理员在微信公众平台上注册的小程序ID（以登录微信公众平台<a href="https://mp.weixin.qq.com查看)./">https://mp.weixin.qq.com查看）。</a></p><img src="/chunk.github.io/images/image-20250825134403333.png" alt="image-20250825134403333" style="zoom: 33%;" /></li><li><p>编译预览小程序。</p><img src="/chunk.github.io/images/image-20250825135537636.png" alt="image-20250825135537636" style="zoom:33%;" /></li></ul><h4 id="手动创建小程序"><a href="#手动创建小程序" class="headerlink" title="手动创建小程序"></a>手动创建小程序</h4><ul><li><p>不选取模板创建空白项目</p><img src="/chunk.github.io/images/image-20250825140243487.png" alt="image-20250825140243487" style="zoom:33%;" /><img src="/chunk.github.io/images/image-20250825140435939.png" alt="image-20250825140435939" style="zoom:33%;" /></li><li><p>进行页面配置</p><ul><li><p>创建页面文件</p><p>page文件内存储页面文件，一般来说，首页默认命名为index，表示小程序运行的第一个页面。</p><img src="/chunk.github.io/images/image-20250825141119412.png" alt="image-20250825141119412" style="zoom:33%;" /></li><li><p>删除<code>index.wxml</code>、<code>index.wxss</code>和<code>app.wxss</code>中的所有代码；</p><img src="/chunk.github.io/images/image-20250825141713756.png" alt="image-20250825141713756" style="zoom: 50%;" /><img src="/chunk.github.io/images/image-20250825141748090.png" alt="image-20250825141748090" style="zoom:40%;" /></li><li><p>删除<code>index.js</code>中的所有代码并输入<code>&quot;page&quot;</code>使其自动补全函数；</p><img src="/chunk.github.io/images/image-20250825141512906.png" alt="image-20250825141512906" style="zoom:40%;" /><img src="/chunk.github.io/images/image-20250825141626784.png" alt="image-20250825141626784" style="zoom:40%;" /></li><li><p>删除<code>app.js</code>中的所有代码并输入<code>&quot;app&quot;</code>使其自动补全函数。</p><img src="/chunk.github.io/images/image-20250825141858454.png" alt="image-20250825141858454" style="zoom:33%;" /></li></ul></li><li><p>视图设计</p><ul><li><p>导航栏设计</p><p>在<code>app.json</code>文件中对windows属性进行重新配置来自定义导航栏效果，将小程序导航栏更改为紫色背景及白色字体。</p><blockquote><p>663399使用rgb格式，代表紫色；</p></blockquote><img src="/chunk.github.io/images/image-20250825142757592.png" alt="image-20250825142757592" style="zoom:33%;" /><p>对应效果如下：</p><img src="/chunk.github.io/images/image-20250825143203516.png" alt="image-20250825143203516" style="zoom: 67%;" /></li><li><p>页面设计</p><p>首先，在小程序中添加微信头像、昵称及“点击获取头像和昵称”按钮三个组件，并将其设置为列项居中排列。</p><blockquote><p>使用组件格式：</p><ul><li><p>微信头像：<code>&lt;image&gt;</code>组件; </p></li><li><p>微信昵称: <code>&lt;text&gt;</code>(文本)组件; </p></li><li><p>按钮: <code>&lt;button&gt;</code>(按钮)组件。</p></li></ul></blockquote><img src="/chunk.github.io/images/image-20250825144902724.png" alt="image-20250825144902724" style="zoom:67%;" /><p>由于尚未获得头像图片，临时使用本地图片代替微信头像，之后再通过点击按钮获取微信头像后进行更改。</p><p>在项目中新建自定义文件夹images用于存放图片并将本地图片移入等待使用，之后修改<code>&lt;image&gt;</code>组件读取该图片。</p><img src="/chunk.github.io/images/image-20250825150038680.png" alt="image-20250825150038680" style="zoom: 50%;" /><img src="/chunk.github.io/images/image-20250825150358220.png" alt="image-20250825150358220" style="zoom:50%;" /></li></ul></li><li><p>逻辑实现</p><ul><li><p>获取微信用户信息</p><p>在<code>WXML</code>页面修改<code>&lt;button&gt;</code>组件的代码，其中<code>open-type= get User Info&#39;</code>表示激活获取微信用户信息功能,然后使用 <code>bindgetuserinfo</code>属 性表示获得的数据将传递给自定义函数 <code>getMyInfo</code>, 名称可自定义。</p><img src="/chunk.github.io/images/image-20250825154954451.png" alt="image-20250825154954451" style="zoom:50%;" /><p>在<code>JS</code>页面的<code>Page()</code>内部追加<code>getMyInfo</code>函数</p><img src="/chunk.github.io/images/image-20250825155039146.png" alt="image-20250825155039146" style="zoom:50%;" /><p>保存后预览项目，如果点击按钮后 Console 控制台能够成功输出一段数据，就说明获取成功。</p><img src="/chunk.github.io/images/image-20250825155452602.png" alt="image-20250825155452602" style="zoom:50%;" /></li><li><p>使用动态数据显示头像和昵称</p><p>在WXML页面修改<code>&lt;image&gt;</code>和<code>&lt;text&gt;</code>组建的代码；</p><img src="/chunk.github.io/images/image-20250825155515375.png" alt="image-20250825155515375" style="zoom:50%;" /><p>修改JS文件，在现有的data 属性中追加这两个动态数据的值，使其仍然可以显示原先的内容；</p><img src="/chunk.github.io/images/image-20250825155945307.png" alt="image-20250825155945307" style="zoom:50%;" /><p>更新后预览图不变，如图所示：</p><img src="/chunk.github.io/images/image-20250825153228796.png" alt="image-20250825153228796" style="zoom:50%;" /></li><li><p>更新头像和昵称</p><p>修改<code>JS</code>文件中<code>getMyInfo</code> 函数的代码,使获取到的信息更新到动态数据上。</p><img src="/chunk.github.io/images/image-20250825160158123.png" alt="image-20250825160158123" style="zoom:50%;" /><p>点击按钮后，头像和昵称成功更新：</p><img src="/chunk.github.io/images/image-20250825160245678.png" alt="image-20250825160245678" style="zoom:50%;" /></li></ul></li></ul><h2 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h2> <img src="/chunk.github.io/images/image-20250825140021498.png" alt="img" style="zoom:33%;" />                   <img src="/chunk.github.io/images/image-20250825153228796.png" alt="image-20250825153228796" style="zoom:50%;" />   <h2 id="问题总结与体会"><a href="#问题总结与体会" class="headerlink" title="问题总结与体会"></a>问题总结与体会</h2><ol><li>学会了微信开发者工具的基础操作，能按步骤新建项目，用快速启动模板快速看到可运行的小程序效果，初步了解了小程序开发的基本流程。</li><li>通过手动创建小程序，我大致了解了不同文件的作用，也掌握了修改配置（如导航栏样式）和删减多余文件的方法，对小程序的配置逻辑有了简单的认识。</li><li>尝试用基础组件搭建页面，用 WXSS 调 用户信息、更新页面数据，理解了一些简单原理。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序开发 </tag>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论</title>
      <link href="/chunk.github.io/2025/08/25/%E7%BC%96%E7%A8%8B/%E6%95%B0%E8%AE%BA/"/>
      <url>/chunk.github.io/2025/08/25/%E7%BC%96%E7%A8%8B/%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="大指数幂的相关计算"><a href="#大指数幂的相关计算" class="headerlink" title="大指数幂的相关计算"></a>大指数幂的相关计算</h3><p>大整数：__ int128</p><p>$$a^b$$：快速幂，将b化为二进制表示，$$b&#x3D;b_1+b_2+……+b_n$$，则$$a^b&#x3D;a^{b_1}<em>a^{b_2}</em>…*a^{b_n}$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$a(mod$ $m),a\le10^{100}$：大整数取模</p><p>$(a+b)$ $(mod)$ $m&#x3D;(a(mod$ $m)+b(mod$ $m))mod$ $m$ </p><p>对于大整数$a$，可以化作：$a&#x3D;(((a_0*10+a_1)*10+a_2)*10+……)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal</span><span class="params">(string a, <span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        ans=((ans*<span class="number">10</span>)+s[i])%m;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$a^bmod$ $n$：模重复平方运算法，取模运算不会干涉乘法运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b,<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    a%=n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%n;</span><br><span class="line">        a=a*a%n;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧拉定理$$(a,n)&#x3D;1，a^{φ(n)}modn&#x3D;1$$，则可知当n为素数时有$$a^bmodp&#x3D;a^{bmod(p-1)}modp$$</p><h3 id="乘法逆元的计算"><a href="#乘法逆元的计算" class="headerlink" title="乘法逆元的计算"></a>乘法逆元的计算</h3><p><code>前提：当gcd(a,m)=1时，逆元存在</code></p><ul><li><p>当模数为素数时——快速幂+欧拉定理</p><p>$当m是素数且gcd(a,m)&#x3D;1时，有a^{m-1}≡1(mod$ $m)即$</p><p>$a^{-1}≡a^{m-2}(mod$ $m)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> b=m<span class="number">-2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%m;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    retur ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当模数不为素数时——广义欧几里得算法</p><p>$∃s,t,使s<em>a+t</em>m&#x3D;1,此时s即为a在模m下的逆元$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;    <span class="comment">//返回的是最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y); </span><br><span class="line">    <span class="type">int</span> temp=y;   </span><br><span class="line">    y=x-(a/b)*y;</span><br><span class="line">    x=temp;</span><br><span class="line">    <span class="keyword">return</span> d;   <span class="comment">//求出x，y及gcd(a,b)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s,t;</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">exgcd</span>(a,m,s,t);</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (x%m+m)%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>应用：</p><ul><li>判断$a<em>x+b</em>y&#x3D;c$是否有解</li><li>求出$a<em>x+b</em>y&#x3D;c$的任意一组解，通解及最小解</li><li>求逆元</li></ul><ol><li><p>扩展欧几里得的写法</p><p>$∃x,y,使x<em>a+y</em>b&#x3D;gcd(a,b),设gcd(a,b)&#x3D;d,则有x<em>a+y</em>b&#x3D;d$</p><p><code>gcd(0,a)=|a|</code></p><p>$exgcd(b, a $%$ b, x, y)$调用后我们可以得到：$x<em>b+y</em>(a$%$b)&#x3D;gcd(a,b)&#x3D;d$，辗转相除求gcd(a,b)</p><p>我们此时对该式子进行变形：<br>$$<br>x<em>b+y</em>(a%b)&#x3D;d\<br>\Rightarrow x<em>b+y</em>(a-\left\lfloor \frac{a}{b} \right\rfloor<em>b)&#x3D;d\<br>\Rightarrow y</em>a+(x-\left\lfloor \frac{a}{b} \right\rfloor*y)<em>b&#x3D;d<br>$$<br>则我们所求的x，y即：$x&#x3D;y,y&#x3D;x-\left\lfloor \frac{a}{b} \right\rfloor</em>y$，左边为所求，右边为递归调用函数后的返回值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;    <span class="comment">//返回的是最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y); </span><br><span class="line">    <span class="type">int</span> temp=y;   </span><br><span class="line">    y=x-(a/b)*y;</span><br><span class="line">    x=temp;</span><br><span class="line">    <span class="keyword">return</span> d;   <span class="comment">//求出x，y及gcd(a,b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对方程$a<em>x+b</em>y&#x3D;c$，若求出$x_0,y_0$是一组解，则通解可写为</p><p>$(x_0+k<em>b^{‘},y-k</em>a^{‘}),其中,a^{‘}&#x3D;a&#x2F;gcd(a,b),b^{‘}&#x3D;b&#x2F;gcd(a,b)$</p></li><li><p>对方程$a<em>x+b</em>y&#x3D;c$，若$gcd(a,b)&#x3D;d$，且方程$a<em>x+b</em>y&#x3D;d一组解为(x_0,y_0)$：</p><ul><li>当c是d的倍数时，一组解为$(x_0<em>c&#x2F;d,y_0</em>c&#x2F;d)$</li><li>当c不是d的倍数时，该方程无整数解</li></ul></li></ol><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>辗转相除法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);</span><br><span class="line"><span class="comment">//当b=0时，说明b=k*a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求g的所有正因子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=g/i;i++)</span><br><span class="line"><span class="keyword">if</span>(g%i==<span class="number">0</span>)&#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span>(i!=g/i) a.<span class="built_in">push_back</span>(g/i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当要求多个数的最大公约数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>$lcm(a,b)&#x3D;a&#x2F;gcd(a,b)*b$   先除后乘，避免中间越界</p><h3 id="素因数的相关结论"><a href="#素因数的相关结论" class="headerlink" title="素因数的相关结论"></a>素因数的相关结论</h3><ul><li>每个大于1的整数都可以分解为若干素数的乘积$n&#x3D;p_1^{a_1}<em>p_2^{a_2}</em>……*p_k^{a_k}$</li><li>n的约数个数为：$d(n)&#x3D;(a_1+1)(a_2+1)……(a_k+1)$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算d(n)</span></span><br><span class="line">ans = <span class="number">1</span>;          </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">n/=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt) ans*=(cnt<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans*=<span class="number">2</span>;    <span class="comment">//n除到最后，要么是1要么是一个素数（大于1），如果此时n&gt;1，说明上面漏了该素数，ans要乘2</span></span><br></pre></td></tr></table></figure><ul><li><p>约数之和  $n&#x3D;p_1^{a_1}+p_2^{a_2}+……+p_k^{a_k}$</p><p>$a(n)&#x3D;(1+p_1+p_1^2+……+p_1^{a_1})<em>……</em>(1+p_k+p_k^2+……+p_k^{a_k})$</p><p>当$p_i\not&#x3D; 1时,a(n)&#x3D;∏\frac{p_i^{a_i+1}-1}{p_i-1}$</p><p>则在模m下：   </p><ul><li><p>若$(p_i-1)mod$ $m&#x3D;0$时，$1+p_1+p_1^2+……+p_1^{a_1}&#x3D;1+a_1$</p></li><li><p>若存在逆元，素因数之和即为</p><p>$∏(p_i^{a_i+1}-1)<em>(p_i-1)^{-1}mod$ $m&#x3D;∏(p_i^{a_i+1}-1)</em>(p_i-1)^{m-2}mod$ $m$</p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">9901</span>;</span><br><span class="line">ll a,b;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; freq;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span>(a%i==<span class="number">0</span>)&#123;</span><br><span class="line">                freq[i]++;</span><br><span class="line">                a/=i;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">1</span>) freq[a]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qmi</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%N;</span><br><span class="line">        a=a*a%N;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(!a)  &#123;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cal</span>();</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:freq)&#123;</span><br><span class="line">        <span class="type">int</span> q=it.first,k=it.second*b;</span><br><span class="line">        <span class="keyword">if</span>((q<span class="number">-1</span>)%N==<span class="number">0</span>) ans=ans*(k<span class="number">+1</span>)%N;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans=ans*(<span class="built_in">qmi</span>(q,k<span class="number">+1</span>)<span class="number">-1</span>)%N*<span class="built_in">qmi</span>(q<span class="number">-1</span>,N<span class="number">-2</span>)%N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans+N)%N;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>n的约数之积为：$n^{d(n)&#x2F;2}$</li><li>若一个数是完全平方数，则$d(n)$是奇数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算不同素因数的个数</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;      <span class="comment">//除去相同的素因数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性筛法求所有的素因数</span></span><br><span class="line">prime[N] ------ 存入<span class="number">1</span>~n的所有素数</span><br><span class="line">st[N] ------ 标记素数(<span class="literal">false</span>为素数)  默认为<span class="function"><span class="literal">false</span></span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span></span>&#123;            <span class="comment">//从2开始遍历1~n</span></span><br><span class="line"><span class="keyword">if</span>(!st[i])  prime[cnt++]=i;   <span class="comment">//标记是素数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;prime[j]*i&lt;=n;j++)&#123;  <span class="comment">//访问素数表中所有的素数</span></span><br><span class="line">st[i*prime[j]]=<span class="literal">true</span>;     <span class="comment">//素数的倍数一定是合数</span></span><br><span class="line">        <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//此时prime[j]是i的最小素数，剪枝，避免重复筛除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-----</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line"><span class="type">int</span> p=prime[i];</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j;j/=p) s+=j/p;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>求某个数的欧拉函数，将数n拆成素数的乘积，则</p><p>$$φ(n)&#x3D;n*(1-\frac{1}{p_1})<em>……</em>(1-\frac{1}{p_m})$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">res-=res/i;    <span class="comment">//乘 (1-1/p)</span></span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) res-=res/n;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性筛法求1~n的欧拉函数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N];           <span class="comment">//存储欧拉函数值</span></span><br><span class="line"><span class="type">bool</span> visited[N];    <span class="comment">//标记该数是否被访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;  <span class="comment">//存储素数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            f[i]=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p:prime)&#123;</span><br><span class="line"><span class="keyword">if</span>(p*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            visited[p*i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p==<span class="number">0</span>)&#123;</span><br><span class="line">f[p*i]=f[i]*p;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">f[p*i]=f[i]*(p<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求同余方程式的解"><a href="#求同余方程式的解" class="headerlink" title="求同余方程式的解"></a>求同余方程式的解</h3><p>$ax≡b(modm)$的解，一定满足$ax-b$是m的整数倍即$ax-b&#x3D;k*m$，转化为求该一次方程的解$x与k$</p><h3 id="组合计数（求C-n-k-）"><a href="#组合计数（求C-n-k-）" class="headerlink" title="组合计数（求C(n,k)）"></a>组合计数（求C(n,k)）</h3><p>$C(n,k)&#x3D;\frac{n!}{k!(n-k)!}$ 在模m下时，即为$n!<em>(k!)^{-1}</em>((n-k)!)^{-1}mod$ $m$（分母的模即为其逆元）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fac[N]----存阶乘    inv[N]----存i的阶乘在模mod下的逆元</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;    <span class="comment">//快速幂</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=*res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;       <span class="comment">//预处理阶乘和逆元（main函数先调用）</span></span><br><span class="line">fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=<span class="built_in">qmi</span>(fac[i],mod<span class="number">-2</span>)%mod;</span><br><span class="line">        <span class="comment">//求fac[i]的逆元-----fac[i]的mod-2次方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>||k&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*inv[k]%mod*inv[n-k]%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>快速幂计算矩阵$A^n$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">mul</span><span class="params">(Matrix &amp;A,Matrix &amp;B)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B[<span class="number">0</span>].<span class="built_in">size</span>(),p=B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">Matrix <span class="title">C</span><span class="params">(n,vector&lt;ll&gt;(m,<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;p;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                C[i][j]=(C[i][j]+A[i][k]*B[k][j])%MOD;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matrix_pow</span><span class="params">(Matrix A,ll n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> size=A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">Matrix <span class="title">ans</span><span class="params">(size,vector&lt;ll&gt;(size,<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;size;i++)  ans[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=<span class="built_in">mul</span>(res,A);</span><br><span class="line">        A=<span class="built_in">mus</span>(A,A);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量子密码</title>
      <link href="/chunk.github.io/2025/05/21/%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/"/>
      <url>/chunk.github.io/2025/05/21/%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="量子计算机"><a href="#量子计算机" class="headerlink" title="量子计算机"></a>量子计算机</h3><ol><li><p>量子比特有1&#x2F;2的概率为状态|0&gt;和|1&gt;，所以&#x3D;&#x3D;量子计算机可以生成令传统电子计算机头疼的真正随机数&#x3D;&#x3D;。</p></li><li><p>在所有问题基本上都是可计算的情况下，如何构建新的密码体制</p><img src="/chunk.github.io/images/a5e5df8306ae414bef5ab87a819d679d.jpg" alt="a5e5df8306ae414bef5ab87a819d679d" style="zoom:50%;" /></li></ol><h3 id="量子密码学"><a href="#量子密码学" class="headerlink" title="量子密码学"></a>量子密码学</h3><ol><li>&#x3D;&#x3D;量子密码学不是用来取代现代密码学&#x3D;&#x3D;，而是要将量子密码学的优势和现代密码体制(如公钥密码体制)的优势结合起来，寻找新的应用领域。</li><li>量子密码的安全性基于量子状态的特性</li><li>目前，量子密码学主要用来实现对称密钥的分发，其优点：<ul><li>  密钥在公开信道中传输不必担心被窃听</li><li>  &#x3D;&#x3D;能检查出密钥在传输过程中是否被窃听&#x3D;&#x3D;</li></ul></li><li>量子密钥分发体制(QKD)的分类<ul><li>  基于不确定性原理</li><li>  基于量子纠缠态</li></ul></li><li>量子密钥学发展史<ul><li>  1970年，Wiesner（美国）提出量子密码学的思想。</li><li>  1984年，Bennett（IBM）和Brassard（Montreal大- 学）提出第一个量子密码的密钥分配协议，称为BB84协议。</li><li>  1991年，Ekert（牛津大学）提出基于纠缠量子的量子密钥分配协议(E91协议)，比BB84更灵活。</li><li>  1992年，Bennett指出只用两个非正交态即可实现量子密码通信，并提出B92协议。</li><li>  至此，量子密码通信三大主流协议(BB84、E91、B92)已基本形成。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全协议</title>
      <link href="/chunk.github.io/2025/05/20/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/"/>
      <url>/chunk.github.io/2025/05/20/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="安全协议概述"><a href="#安全协议概述" class="headerlink" title="安全协议概述"></a>安全协议概述</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>   两个或两个以上的参与者为完成某项特定任务而采取的一系列步骤</p><h4 id="协议的复杂性"><a href="#协议的复杂性" class="headerlink" title="协议的复杂性"></a>协议的复杂性</h4><ul><li>协议必须把所有<strong>不利条件</strong>事先都估计到，而<strong>不能假定</strong>一切都是正常的和非常理想的。 </li><li>看一个协议是否正确，不能光看在正常情况下是否正确，而且还必须非常仔细地检查这个协议<strong>能否应付各种异常情况</strong>。</li></ul><h4 id="两个经典例子"><a href="#两个经典例子" class="headerlink" title="两个经典例子"></a>两个经典例子</h4><ul><li>两军问题：有些问题考虑太全面则无法解决</li><li>尾生抱柱：有些问题考虑不全面会导致严重后果</li></ul><h4 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h4><ul><li>又称密码协议，使用密码技术完成某项特定任务，并满足安全需求的协议。 </li><li>在安全协议中，经常使用对称密码、公钥密码、Hash函数、PRG等密码工具。</li></ul><h4 id="安全协议的安全性需求"><a href="#安全协议的安全性需求" class="headerlink" title="安全协议的安全性需求"></a>安全协议的安全性需求</h4>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">机密性 </span><br><span class="line">完整性 </span><br><span class="line">认证性</span><br><span class="line">非否认性</span><br><span class="line">公平性</span><br><span class="line">匿名性</span><br><span class="line">……（根据应用场合不同进行组合）</span><br></pre></td></tr></table></figure><h4 id="安全协议中的角色"><a href="#安全协议中的角色" class="headerlink" title="安全协议中的角色"></a>安全协议中的角色</h4><ul><li>协议参与者</li><li>攻击者<ul><li>内部&#x2F;外部攻击者</li><li>被动&#x2F;主动攻击者</li></ul></li><li>可信第三方(TTP, Trusted Third Party)<ul><li>用户都信任的实体，通常与每个用户共享密钥</li><li>功能：使用户之间确认彼此身份 或 共享会话密钥</li></ul></li></ul><h4 id="安全协议设计与分析的困难性"><a href="#安全协议设计与分析的困难性" class="headerlink" title="安全协议设计与分析的困难性"></a>安全协议设计与分析的困难性</h4><ul><li><h5 id="安全目标本身的微妙性"><a href="#安全目标本身的微妙性" class="headerlink" title="安全目标本身的微妙性"></a>安全目标本身的微妙性</h5>表面上十分简单的目标，实际上十分微妙</li><li><h5 id="运行环境的复杂性"><a href="#运行环境的复杂性" class="headerlink" title="运行环境的复杂性"></a>运行环境的复杂性</h5>实际上,当安全协议运行在一个十分复杂的公开环境时,攻击者处处存在</li><li><h5 id="攻击者模型的复杂性"><a href="#攻击者模型的复杂性" class="headerlink" title="攻击者模型的复杂性"></a>攻击者模型的复杂性</h5>必须形式化地描述攻击者的能力，对攻击者和攻击行为进进行分类和形式化的分析</li><li><h5 id="分类和形式化的分析"><a href="#分类和形式化的分析" class="headerlink" title="分类和形式化的分析"></a>分类和形式化的分析</h5>安全协议本身具有“高并发性”</li></ul><h4 id="好的安全协议应满足的条件"><a href="#好的安全协议应满足的条件" class="headerlink" title="好的安全协议应满足的条件"></a>好的安全协议应满足的条件</h4><ul><li>满足目标(应用目标,安全目标)</li><li>易于实现</li><li>各参与者所需计算量小、存储量小</li><li>通信负载小(延迟小,占用带宽小)</li><li>交互轮数少</li></ul><h3 id="经典安全协议"><a href="#经典安全协议" class="headerlink" title="经典安全协议"></a>经典安全协议</h3><h4 id="秘密共享"><a href="#秘密共享" class="headerlink" title="秘密共享"></a>秘密共享</h4><pre><code>两种实现方案：秘密共享➕视觉密码（图像化的秘密共享）</code></pre><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><ul><li>定义：将秘密信息分割存储的密码技术</li><li>目的：防止秘密过于集中，以达到分散风险和容忍入侵的目的<ul><li>分散风险：避免权力过于集中</li><li>容忍入侵：混进几个攻击者不影响安全性</li></ul></li></ul><h5 id="门限方案—Adi-Shamir"><a href="#门限方案—Adi-Shamir" class="headerlink" title="门限方案—Adi Shamir"></a>门限方案—Adi Shamir</h5><blockquote><p>(m,n) 门限方案：<br>   将秘密信息SK拆成n份，任意m(m≤n)份或更多份都可以恢复SK<br>   任何少于m份都不能得到关于SK的任何有用信息<br>   其中，每一份都称为一个share</p></blockquote><h5 id="Shamir的门限方案"><a href="#Shamir的门限方案" class="headerlink" title="Shamir的门限方案"></a>Shamir的门限方案</h5><img src="/chunk.github.io/images/f1c171a7eeb80296c14073598833cd63.jpg" style="zoom:50%;" /><img src="/chunk.github.io/images/cea9af653d31cdc69d3049752072d5ad.jpg" style="zoom:50%;" /><h6 id="安全性原理"><a href="#安全性原理" class="headerlink" title="安全性原理"></a>安全性原理</h6><p>  对于m-1次多项式，给出不少于m个点就可以唯一地重构，少于m个则不行。<br>  保证K可从m个share中获得，少于m个则办不到。</p><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><p>  (3,5)的门限方案</p><blockquote><p>设 m &#x3D; 3，n &#x3D; 5，p &#x3D; 17，K &#x3D; 13</p><img src="/chunk.github.io/images/d81e8641b8cd962f951466494f3f56a8.jpg" style="zoom:50%;" /></blockquote><img src="/chunk.github.io/images/29f21ffb48236ee040d45644d8667775.jpg" style="zoom:50%;" /><h5 id="视觉密码"><a href="#视觉密码" class="headerlink" title="视觉密码"></a>视觉密码</h5><ul><li>方法<br>将写有秘密信息的图片拆分成n张,至少m张(m≤n)才能恢复原来的图片</li><li>优点<ul><li>安全性高</li><li>计算开销低：恢复原图片时，用幻灯机即可，无需计算机参与</li></ul></li></ul><h4 id="零知识证明"><a href="#零知识证明" class="headerlink" title="零知识证明"></a>零知识证明</h4><ol><li><h5 id="设P掌握某些信息-并希望向V证明这一事实"><a href="#设P掌握某些信息-并希望向V证明这一事实" class="headerlink" title="设P掌握某些信息,并希望向V证明这一事实"></a>设P掌握某些信息,并希望向V证明这一事实</h5><ul><li>最小泄露证明<br>P向V证明自己的确掌握该信息，但V无法推断出这些信息是什么</li><li>零知识证明<br>V除了知道P能够证明该信息，不能得到任何额外的知识</li></ul></li><li><h5 id="最小泄露证明满足下述两个性质："><a href="#最小泄露证明满足下述两个性质：" class="headerlink" title="最小泄露证明满足下述两个性质："></a>最小泄露证明满足下述两个性质：</h5><ul><li>正确性：P不知道该信息，使V相信他知道该信息的概率很低（P无法欺骗V）</li><li>完备性：P知道该信息，他能以绝对优势使V相信他确实知道。</li></ul></li><li><h5 id="零知识证明除满足上述两个性质外，还满足下述性质："><a href="#零知识证明除满足上述两个性质外，还满足下述性质：" class="headerlink" title="零知识证明除满足上述两个性质外，还满足下述性质："></a>零知识证明除满足上述两个性质外，还满足下述性质：</h5><ul><li>  零知识性：V无法获取任何额外的知识 (V无法欺骗P)<blockquote><p>获得知识——原来你自己不能干的事，现在可以自己干了<br>例：老师教授知识不属于零知识证明，学生学会了某个知识点。</p></blockquote></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于身份的密码学</title>
      <link href="/chunk.github.io/2025/05/12/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/chunk.github.io/2025/05/12/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>基于身份的密码学（identity-based cryptography, IBC）<br>提出者：Adi Shamir<br>解决问题：如何以较小的代价保证公钥的真实性</p><h4 id="IBC的原理"><a href="#IBC的原理" class="headerlink" title="IBC的原理"></a>IBC的原理</h4><h5 id="传统公钥密码中公钥的产生"><a href="#传统公钥密码中公钥的产生" class="headerlink" title="传统公钥密码中公钥的产生"></a>传统公钥密码中公钥的产生</h5><p>   先选择私钥，再计算公钥，公钥必然显得“一片混乱”<br>   公钥证书，PKI</p><h5 id="IBC产生公钥的原理"><a href="#IBC产生公钥的原理" class="headerlink" title="IBC产生公钥的原理"></a>IBC产生公钥的原理</h5><ul><li>先选择公钥，再计算私钥</li><li>公钥可选择email地址、身份证号等，称之为用户的身份，记为ID<br>    (注意：公钥就是ID，或从ID直接推导而来)</li><li>私钥看起来杂乱无章，没关系，反而有利</li><li>ID必须是每个用户唯一确定的信息，比如身份证号、电子邮箱等</li></ul><h4 id="基于身份的加密体制（IBE-Identity-based-Encryption）"><a href="#基于身份的加密体制（IBE-Identity-based-Encryption）" class="headerlink" title="基于身份的加密体制（IBE, Identity-based Encryption）"></a>基于身份的加密体制（IBE, Identity-based Encryption）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>   一个IBE包含以下算法：</p><ul><li>Setup (1^λ): 产生系统公开参数 param，生成随机主密钥 msk</li><li>KeyGen (param, ID, msk)：生成身份 ID 对应的用户私钥 sk</li><li>Enc (param, ID, m): 给定明文 m∈M，输出密文 c ∈C</li><li>Dec (param, sk,c): 给定密文 c∈C，输出 m∈M (或 ⊥)<br>一致性要求: Setup输出的 ∀(param,  msk), 对于∀ ID，KeyGen输出的∀sk :    对于 ∀m∈M，有 Dec(param, sk, Enc(param, ID, m) ) &#x3D; m</li></ul><h5 id="IBC下的秘密通信模型"><a href="#IBC下的秘密通信模型" class="headerlink" title="IBC下的秘密通信模型"></a>IBC下的秘密通信模型</h5>   <img src="/chunk.github.io/images/544147b24eeba0526f3b09d6b3e5b41a.jpg" alt="544147b24eeba0526f3b09d6b3e5b41a" style="zoom:50%;" />##### Key Generation Center (KGC)   - 用途：用户选择自己的ID作为公钥     KGC根据ID产生相应的私钥（用户的私钥从KGC那里获得）   - KGC与CA的区别     <img src="/chunk.github.io/images/8bc7f1d877d87dcd7254141b625f1a97.jpg" alt="8bc7f1d877d87dcd7254141b625f1a97" style="zoom:50%;" />##### IBC的优缺点   - 优点     避免使用复杂的PKI系统   - 缺点     *   密钥撤销问题：私钥泄露以后，相应的ID也就无法使用     *   密钥托管问题（Key-escrow）：私钥由KGC产生，一旦KGC被攻破 (主密钥泄露)，所有用户信息将受到严重威胁]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>身份认证</title>
      <link href="/chunk.github.io/2025/04/26/%E5%AF%86%E7%A0%81%E5%AD%A6/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/"/>
      <url>/chunk.github.io/2025/04/26/%E5%AF%86%E7%A0%81%E5%AD%A6/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><h4 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h4>通信一方认证另一方的身份</li><li>双向认证<br>通信双方彼此认证身份</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>Know sth.: 知道什么可用于识别身份的信息?</li><li>Have sth.：拥有什么可用于识别身份的东西?</li><li>Be sth.：有什么独特的特征？</li></ul><h3 id="Know-sth"><a href="#Know-sth" class="headerlink" title="Know sth."></a>Know sth.</h3><ul><li><h4 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h4><ul><li>最常用的身份认证机制，但安全性较差</li><li>易受到泄露、猜测、窃听、社会工程学等形式的攻击</li><li>什么是弱口令？<br> 短口令<br>   常见单词<br>   生日<br>   电话号码<br>   系统预设口令</li></ul></li><li><h4 id="口令管理措施"><a href="#口令管理措施" class="headerlink" title="口令管理措施"></a>口令管理措施</h4><ul><li><h5 id="口令空间"><a href="#口令空间" class="headerlink" title="口令空间"></a>口令空间</h5><ul><li>口令应具有一定的长度，包含多种字符类型</li><li>口令不应使用易猜测的数字或字母组合</li></ul></li><li><h5 id="口令时间"><a href="#口令时间" class="headerlink" title="口令时间"></a>口令时间</h5><ul><li>口令应具有一定的生存期</li><li>口令不应使用一定时间内的历史口令</li></ul></li><li><h5 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h5><ul><li>用户登录不同系统应使用不同的口令</li><li>系统应设定口令登录失败次数限制</li></ul></li></ul></li><li><h4 id="好记又安全的口令"><a href="#好记又安全的口令" class="headerlink" title="好记又安全的口令"></a>好记又安全的口令</h4>我爱吃苹果<br>5iChiapple<br>woaieatApple<br>……</li><li><h4 id="口令的存储"><a href="#口令的存储" class="headerlink" title="口令的存储"></a>口令的存储</h4>利用Hash函数存储口令，防范攻击者偷取数据库后得到口令<img src="/chunk.github.io/images/10880b1d8d7c29d348468c9ec8c23725.jpg" alt="10880b1d8d7c29d348468c9ec8c23725" style="zoom:50%;" /></li></ul><h3 id="Have-sth"><a href="#Have-sth" class="headerlink" title="Have sth."></a>Have sth.</h3><ul><li><h4 id="令牌"><a href="#令牌" class="headerlink" title="令牌"></a>令牌</h4><ul><li>存储卡：在磁卡上保存用户信息；与PIN配合使用</li><li>智能卡：由一个或多个集成电路芯片组成，包含CPU和存储器，具有数据存储能力和逻辑处理功能<br>……</li></ul></li><li><h4 id="令牌的优点"><a href="#令牌的优点" class="headerlink" title="令牌的优点"></a>令牌的优点</h4>可以随身携带，攻击者必须先拿到令牌，这增加了攻击难度<br>需要输入一个正确的PIN才能使令牌发挥作用<br>试图用物理手段获得存储信息，有些令牌还有自毁功能</li></ul><h3 id="Be-sth"><a href="#Be-sth" class="headerlink" title="Be sth."></a>Be sth.</h3><ul><li>生物特征<br>指纹、掌纹、虹膜、视网膜、手形、面部特征、声波、DNA等</li><li>动态特征<br>签名特征、键盘特征</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息认证</title>
      <link href="/chunk.github.io/2025/04/21/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/"/>
      <url>/chunk.github.io/2025/04/21/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h6 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a>主要目标</h6><ul><li>完整性：消息是否被改动过</li><li>真实性：消息是否是指定发送者发来的</li></ul><h6 id="认证加密——同时保证机密性和完整性"><a href="#认证加密——同时保证机密性和完整性" class="headerlink" title="认证加密——同时保证机密性和完整性"></a>认证加密——同时保证机密性和完整性</h6><h3 id="认证加密（AE-authenticated-encryption）"><a href="#认证加密（AE-authenticated-encryption）" class="headerlink" title="认证加密（AE,authenticated encryption）"></a>认证加密（AE,authenticated encryption）</h3><blockquote><p>确认消息的来源</p></blockquote><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>一个AE系统 (E,D) 是一个对称加密体制</p><ul><li>加密算法:  E:  K × M × N ⟶ C</li><li>解密算法:  D:  K × C × N ⟶  M ∪ {⊥} &#x2F;&#x2F;密文不合法时，拒绝接收</li><li>N是nonce空间（可选）</li></ul><h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>对(E,D)的要求:</p><ul><li>CPA安全性</li><li>密文完整性 (攻击者不能伪造出可以正确解密的新密文)</li></ul><h5 id="密文完整性（安全模型）"><a href="#密文完整性（安全模型）" class="headerlink" title="密文完整性（安全模型）"></a>密文完整性（安全模型）</h5><img src="/chunk.github.io/images/5275fd290f8768982566aac5981b4af7.jpg" alt="5275fd290f8768982566aac5981b4af7" style="zoom:50%;" /><img src="/chunk.github.io/images/64c1141717bc0c8945824c6d10509467.jpg" alt="64c1141717bc0c8945824c6d10509467" style="zoom:50%;" /><p>(E,D) 具有密文完整性，则对于任意高效攻击者A，在上述安全模型中伪造成功的概率<br>Adv &#x3D; Pr[ A伪造成功 ]  是可忽略的</p><h4 id="AE的性质"><a href="#AE的性质" class="headerlink" title="AE的性质"></a>AE的性质</h4><ul><li><h5 id="保证真实性"><a href="#保证真实性" class="headerlink" title="保证真实性"></a>保证真实性</h5><ul><li>攻击者不能欺骗 Bob，使他认为消息来自于Alice</li><li>如果  Dₖ(c) ≠ ⊥, Bob 知道消息来自 Alice (因为她知道密钥 k)<br>(但不能抵抗旧消息重放)</li></ul></li><li><h5 id="AE-⇒-CCA安全性"><a href="#AE-⇒-CCA安全性" class="headerlink" title="AE  ⇒ CCA安全性"></a>AE  ⇒ CCA安全性</h5></li></ul><h3 id="CCA安全性"><a href="#CCA安全性" class="headerlink" title="CCA安全性"></a>CCA安全性</h3><h4 id="攻击者攻击能力"><a href="#攻击者攻击能力" class="headerlink" title="攻击者攻击能力"></a>攻击者攻击能力</h4><ul><li><h5 id="CPA（选择明文攻击）"><a href="#CPA（选择明文攻击）" class="headerlink" title="CPA（选择明文攻击）"></a>CPA（选择明文攻击）</h5>选择任意明文，并获得相应的密文</li><li><h5 id="CCA（选择密文攻击）"><a href="#CCA（选择密文攻击）" class="headerlink" title="CCA（选择密文攻击）"></a>CCA（选择密文攻击）</h5>选择任意密文 (除了挑战密文)，并获得相应的明文</li></ul><h4 id="攻击者攻击目的"><a href="#攻击者攻击目的" class="headerlink" title="攻击者攻击目的"></a>攻击者攻击目的</h4><ul><li>破坏语义安全性</li></ul><h4 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h4><img src="/chunk.github.io/images/832fd60e6fa5e7e0752a1604f69bd322.jpg" alt="832fd60e6fa5e7e0752a1604f69bd322" style="zoom:50%;" /><img src="/chunk.github.io/images/8e51c8d99d9830ae7f986fa105ab0fd6.jpg" alt="8e51c8d99d9830ae7f986fa105ab0fd6" style="zoom:50%;" /><img src="/chunk.github.io/images/2ca6355f3329935dceb7c612f115e265.jpg" alt="2ca6355f3329935dceb7c612f115e265" style="zoom:50%;" /><p>如果一个对称加密体制是CCA安全的，则对于任意高效的攻击者A, 在上述安全模型中<br>Adv &#x3D; | Pr[EXP(0)&#x3D;1] – Pr[EXP(1)&#x3D;1] |         是可忽略的。</p><h3 id="AE的构造"><a href="#AE的构造" class="headerlink" title="AE的构造"></a>AE的构造</h3><h4 id="ENC-MAC"><a href="#ENC-MAC" class="headerlink" title="ENC+MAC"></a>ENC+MAC</h4><ul><li><h5 id="MAC-then-Enc"><a href="#MAC-then-Enc" class="headerlink" title="MAC-then-Enc"></a>MAC-then-Enc</h5><ul><li>CCA攻击下可能不安全</li><li>当IV是随机数时，采用CBC和CTR模式是CCA安全的</li><li>标准：CCM</li></ul></li><li><h5 id="Enc-then-MAC-MAC密文"><a href="#Enc-then-MAC-MAC密文" class="headerlink" title="&#x3D;&#x3D;Enc-then-MAC (MAC密文)&#x3D;&#x3D;"></a>&#x3D;&#x3D;Enc-then-MAC (MAC密文)&#x3D;&#x3D;</h5><ul><li>标准：GCM</li></ul></li><li><h5 id="Enc-and-MAC-MAC明文"><a href="#Enc-and-MAC-MAC明文" class="headerlink" title="Enc-and-MAC (MAC明文)"></a>Enc-and-MAC (MAC明文)</h5><ul><li>不推荐使用</li><li>标准：EAX</li></ul></li></ul><h4 id="MAC安全性暗示"><a href="#MAC安全性暗示" class="headerlink" title="MAC安全性暗示"></a>MAC安全性暗示</h4><p>(m , t) ⇏ (m , t’)<br>假设攻击者可以做到:  (m , t)   ⟶  (m , t’)<br>那么 Enc-then-MAC 就不是CCA安全的 (将无法保证密文完整性) !!<br><img src="/chunk.github.io/images/de10e43e7b18d191f57c7effb8c8105a.jpg" alt="de10e43e7b18d191f57c7effb8c8105a" style="zoom:50%;" /></p><img src="/chunk.github.io/images/3fe00474631f3f8c5ac7a755a69c04a3.jpg" alt="3fe00474631f3f8c5ac7a755a69c04a3" style="zoom:50%;" /><h4 id="OCB模式"><a href="#OCB模式" class="headerlink" title="OCB模式"></a>OCB模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于PRP直接构造认证加密</span><br></pre></td></tr></table></figure><p>简述：比 ENC+MAC 方式更快，完全可并行<br><img src="/chunk.github.io/images/ac0db0f35eeb2c79395b6683aae32ae4.jpg" alt="ac0db0f35eeb2c79395b6683aae32ae4" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据完整性技术</title>
      <link href="/chunk.github.io/2025/04/15/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8A%80%E6%9C%AF/"/>
      <url>/chunk.github.io/2025/04/15/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><ol><li>如果传输&#x2F;存储的数据被篡改，怎么知道？<ul><li>使用“数据完整性技术”</li><li>当消息发生改变时，可以检查出来</li></ul></li><li>若将 m 与 H(m) 一起发送，接收方用接受的 m’ 计算 H(m’) ，比较两个散列值是否可以知道消息是否被篡改<ul><li>不能</li><li>攻击者可伪造 m₀ 与 H(m₀) 发送</li><li>问题关键：Hash函数没有密钥(给定消息，任何人都可以计算)</li></ul></li><li>数据完整性技术<ul><li>当设计一个带密钥的算法时可以抵抗伪造</li><li>分类<ul><li>消息认证码(MAC&#x2F;message authentication code)<ul><li>对称密码技术</li></ul></li><li>数字签名(digital signature)<ul><li>公钥密码技术</li></ul></li></ul></li></ul></li></ol><h2 id="消息认证码MAC"><a href="#消息认证码MAC" class="headerlink" title="消息认证码MAC"></a>消息认证码MAC</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>MAC是实现数据完整性的重要工具</li><li>MAC : K × M -&gt;T ，其中， m ∈ M 称为消息， t ∈ T 称为“MAC”</li><li>Alice与Bob知道密钥k，Bob收到Alice的消息 m 和 MAC值t 后，利用密钥算出 MAC(k,m) 与t比较，若相同则说明未被篡改</li></ul><h3 id="MAC的安全性"><a href="#MAC的安全性" class="headerlink" title="MAC的安全性"></a>MAC的安全性</h3><ol><li>攻击者攻击能力<ul><li>选择消息攻击(CMA,chosen-message attack)<ul><li>攻击者选择消息，获得对应的MAC</li></ul></li><li>攻击者目的<ul><li>存在性伪造：伪造一对新的消息 MAC(m,t)(m,t) ∉ {(m₁,t₁),…,(mₚ,tₚ)}</li></ul></li><li>直觉上的MAC安全性<ul><li>攻击者不能为一个新消息产生有效的 MAC</li><li>给定 (m’,t’) ，攻击者甚至不能为 m’ 产生另一个有效的MAC t，t !&#x3D; t’</li></ul></li></ul></li><li>安全模型和定义<img src="/chunk.github.io/images/4abeee7a2ba97d5ad9a047cccc5095e1.jpg" alt="4abeee7a2ba97d5ad9a047cccc5095e1" style="zoom:50%;" />一个MAC算法是安全的，则对于任意高效的攻击者A，他在上述安全模型中伪造成功的概率      **Adv = Pr[A伪造成功]**       是可忽略的。</li></ol><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><blockquote><p>如果对于密钥空间 1&#x2F;2 的密钥，攻击者都可以找到两个消息 m₀ !&#x3D; m₁ 使得MAC(k,m₀) &#x3D; MAC(k,m₁) ，这个MAC安全吗？</p><img src="/chunk.github.io/images/df6399e8d912125c6d75c10434666479.jpg" alt="df6399e8d912125c6d75c10434666479" style="zoom:50%;" />==MAC本身必须抗碰撞==如果MAC(k,m)的输出总是5比特，这个MAC安全吗？<img src="/chunk.github.io/images/ca58aa4889c61b30d76ceab1a0c5e347.jpg" alt="ca58aa4889c61b30d76ceab1a0c5e347" style="zoom:50%;" />     ==MAC的输出必须足够长==</blockquote><h3 id="MAC的构造"><a href="#MAC的构造" class="headerlink" title="MAC的构造"></a>MAC的构造</h3><ol><li>PRF-based MACs</li></ol><ul><li>定义：设F: K × X  ⟶ Y 是安全的PRF，构造 MAC如下:<br>MAC (k,m) &#x3D; F(k, m)<img src="/chunk.github.io/images/e088d18c360497d7055d29940b9779c9.jpg" alt="e088d18c360497d7055d29940b9779c9" style="zoom:50%;" /></li><li>定理<br>只要|Y|足够大，则安全的PRF⇒安全的MAC</li><li>截取问题<br>从 PRF-based MACs 的输出中截取w-bit作为新的MAC，仍是安全的。<br>w大于等于64时是可忽略的</li><li>缺点<ul><li>只能处理短消息</li><li>如基于AES的MAC只能处理128比特的消息</li><li>利用CBC-MAC与HMAC处理长消息</li></ul></li></ul><ol start="2"><li><p>CBC-MAC(基于CBC模式)</p><ul><li><p>CBC-MAC</p><img src="/chunk.github.io/images/09f4deb75dfc6368ef49d2e4e3df24b5.jpg" alt="09f4deb75dfc6368ef49d2e4e3df24b5" style="zoom:50%;" /><img src="/chunk.github.io/images/232aae079d92fa46c5e2433e07b00d5d.jpg" alt="232aae079d92fa46c5e2433e07b00d5d" style="zoom:50%;" /></li><li><p>ECBC-MAC</p><img src="/chunk.github.io/images/60626a899321c8ec8e8495dae949e240.jpg" alt="60626a899321c8ec8e8495dae949e240" style="zoom:50%;" /><ul><li>填充 <ul><li>如果消息不是分组的整数倍，需要进行填充</li><li>若追加一串0作为填充，会导致m的MAC与新消息mll0的MAC相等<ul><li>原因：pad(m)&#x3D;pad(mll0)</li></ul></li><li>为保证安全性<ul><li>填充方法必须可逆！</li><li>m₀ ≠ m₁   ⇒  pad(m₀) ≠ pad(m₁)</li></ul></li><li>ISO填充方法：&#x3D;&#x3D;用“100…00”填充，需要的话可追加一个dummy block&#x3D;&#x3D;<ul><li>1表示这串是填充的开始</li><li>ISO标准的CBC-MAC</li></ul><img src="/chunk.github.io/images/f891c3003bb0e6ff215b4099fae4fc45.jpg" alt="f891c3003bb0e6ff215b4099fae4fc45" style="zoom:50%;" /></li></ul></li></ul></li></ul></li><li><p>HMAC（基于抗碰撞Hash函数）</p><ul><li>为什么基于Hash函数构造？<ul><li>Hash函数的软件实现快于分组密码</li><li>Hash函数没有出口限制</li></ul></li><li>模型<img src="/chunk.github.io/images/70434232a677748c370395b4641a0640.jpg" alt="70434232a677748c370395b4641a0640" style="zoom:50%;" /></li></ul></li></ol><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><h3 id="数字签名概述"><a href="#数字签名概述" class="headerlink" title="数字签名概述"></a>数字签名概述</h3><blockquote><p>基于公钥思想的数据完整性技术</p></blockquote><h4 id="手写签名"><a href="#手写签名" class="headerlink" title="手写签名"></a>手写签名</h4><ul><li>目的：绑定签名者信息与文件</li><li>问题：任何人都可使用</li></ul><h4 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h4>   <img src="/chunk.github.io/images/084d1d5b612ff6c1b290740811673717.jpg" alt="084d1d5b612ff6c1b290740811673717" style="zoom:50%;" />   <h4 id="数字签名体制定义"><a href="#数字签名体制定义" class="headerlink" title="数字签名体制定义"></a>数字签名体制定义</h4>   <img src="/chunk.github.io/images/11c1e9b12e95cbc656d5dbbcdcacbfb6.jpg" alt="11c1e9b12e95cbc656d5dbbcdcacbfb6" style="zoom:50%;" /><h4 id="数字签名体制的安全性"><a href="#数字签名体制的安全性" class="headerlink" title="数字签名体制的安全性"></a>数字签名体制的安全性</h4><ul><li><h5 id="攻击形式"><a href="#攻击形式" class="headerlink" title="攻击形式"></a>攻击形式</h5><ul><li>攻击者攻击能力：选择消息攻击攻击者<br>选择消息 m₁, …, mₚ ∈M, 他可以获得相应的签名        σᵢ &lt;- Sign (sk, mᵢ)</li><li>攻击者攻击目的：存在性伪造<br>伪造一对新的消息&#x2F;签名  (m, σ)，m  ∉  { m₁, … , mₚ }</li></ul></li><li><h5 id="直觉上的安全性"><a href="#直觉上的安全性" class="headerlink" title="直觉上的安全性"></a>直觉上的安全性</h5>攻击者不能为一个新消息产生有效的签名</li><li><h5 id="安全模型和定义"><a href="#安全模型和定义" class="headerlink" title="安全模型和定义"></a>安全模型和定义</h5><img src="/chunk.github.io/images/897ad1fc3d94d63cfc08e46bfc8b6150.jpg" alt="897ad1fc3d94d63cfc08e46bfc8b6150" style="zoom:50%;" />一个数字签名体制是安全的，则对于任意高效的攻击者  A，在上述安全模型中伪造成功的概率         Adv := Pr[ A伪造成功 ]    是可忽略的</li><li><h5 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h5><img src="/chunk.github.io/images/65963870d49fe4d8af10fddad2221f4f.jpg" alt="65963870d49fe4d8af10fddad2221f4f" style="zoom:50%;" /></li></ul><h4 id="利用抗碰撞hash函数签署长消息"><a href="#利用抗碰撞hash函数签署长消息" class="headerlink" title="利用抗碰撞hash函数签署长消息"></a>利用抗碰撞hash函数签署长消息</h4><ul><li>构造工具<ul><li><p>数字签名体制SIG&#x3D;(Setup, Sign, Verify),消息空间为 M</p></li><li><p>函数：Hash函数</p><img src="/chunk.github.io/images/ecca3b66634a18ee9cf7b74633d56e3f.jpg" alt="ecca3b66634a18ee9cf7b74633d56e3f" style="zoom:50%;" /></li><li><p>安全性<br>如果 SIG 是安全的数字签名体制 (消息空间为 M)、H是抗碰撞Hash函数，则这个数字签名体制也是安全的</p></li><li><p>例题 </p><img src="/chunk.github.io/images/124cc8994a5500707a2e98fc1ce91274.jpg" alt="124cc8994a5500707a2e98fc1ce91274" style="zoom:50%;" /></li></ul></li></ul><h3 id="RSA数字签名体制"><a href="#RSA数字签名体制" class="headerlink" title="RSA数字签名体制"></a>RSA数字签名体制</h3><h4 id="全域Hash-FDH"><a href="#全域Hash-FDH" class="headerlink" title="全域Hash (FDH)"></a>全域Hash (FDH)</h4><ul><li><h5 id="构造工具"><a href="#构造工具" class="headerlink" title="构造工具"></a>构造工具</h5><ul><li>(G, F, F⁻¹):  定义在 X 上的 TDP</li><li>H: M -&gt; X，全域Hash函数<br><code>全域Hash不等同于全域Hash函数</code></li></ul></li><li><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><img src="/chunk.github.io/images/b9cb4fd0406baed001438220b929582f.jpg" alt="b9cb4fd0406baed001438220b929582f" style="zoom:50%;" /></li><li><h5 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h5><img src="/chunk.github.io/images/5d478b0565f4229d8dd0b78fc4bd109b.jpg" alt="5d478b0565f4229d8dd0b78fc4bd109b" style="zoom:50%;" /></li></ul><h4 id="RSA-FDH"><a href="#RSA-FDH" class="headerlink" title="RSA-FDH"></a>RSA-FDH</h4>   <img src="/chunk.github.io/images/d406e001bbcd7e8bebad8aaf5da76dec.jpg" alt="d406e001bbcd7e8bebad8aaf5da76dec" style="zoom:50%;" />### PKI(公钥基础设施)`校验者如何确定收到的是签名者的公钥？     依赖认证的信道 `##### 公钥证书   * 使用过程   <img src="/chunk.github.io/images/dd61fdd42360fbdcbe07a784d43c85ce.jpg" alt="dd61fdd42360fbdcbe07a784d43c85ce" style="zoom:50%;" />   * 逻辑形式：用户身份信息+用户公钥+CA的签名##### PKI   * 定义:一个使用公钥概念和密码技术实施和提供安全服务的具有普适性的安全基础设施的总称。   * 提醒：PKI不是特指某一个密码设备和管理设施，它是     - 生成、管理、存储、颁发和撤销公钥证书所需要的软硬件、人员、策略和规程的总和     - 提供密钥管理和数字签名服务的平台   * 密钥生命周期     <img src="/chunk.github.io/images/2de7feff00e391f50dceb7047ed245c7.jpg" alt="2de7feff00e391f50dceb7047ed245c7" style="zoom:50%;" />   * **X.509**公钥证书格式   * 相关产品     - VeriSign——最大的CA     - Entrust 公司——世界一流]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据完整性技术</title>
      <link href="/chunk.github.io/2025/04/15/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/chunk.github.io/2025/04/15/%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h3><img src="/chunk.github.io/images/2c7636b09a33ffcd3c058b230795f2d6.jpg" alt="2c7636b09a33ffcd3c058b230795f2d6" style="zoom:50%;" /><img src="/chunk.github.io/images/b5ced4ae3206f0a942e7d3f65890710c.jpg" alt="b5ced4ae3206f0a942e7d3f65890710c" style="zoom:50%;" /><img src="/chunk.github.io/images/cb281f805c3ea0a6c0ce4d9b1c1b3676.jpg" alt="cb281f805c3ea0a6c0ce4d9b1c1b3676" style="zoom:50%;" /><h3 id="ECC版DH协议"><a href="#ECC版DH协议" class="headerlink" title="ECC版DH协议"></a>ECC版DH协议</h3><h4 id="ECC版DH协议-1"><a href="#ECC版DH协议-1" class="headerlink" title="ECC版DH协议"></a>ECC版DH协议</h4><p>   选择椭圆曲线E（Fₚ），选择其上一点P，P的阶是一个非常大的素数。<br>   <img src="/chunk.github.io/images/2282d0f5ae1d11310c479ad8c771a75a.jpg" alt="2282d0f5ae1d11310c479ad8c771a75a" style="zoom:50%;" /></p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>   窃听者看到：E(Fₚ) , P,   Yᴀ&#x3D;xP,  Yʙ&#x3D;yP ——&gt; xyP<br>   如果 xyP 难以计算，那么ECC版Diffie-Hellman密钥交换协议可以抵抗窃听<br>   安全性基于 <strong>椭圆曲线上的Diffie-Hellman 问题</strong><br>   <code>缺少认证 可被中间人攻击</code></p><h4 id="椭圆曲线上的Diffie-Hellman问题（都在计算上不可行）"><a href="#椭圆曲线上的Diffie-Hellman问题（都在计算上不可行）" class="headerlink" title="椭圆曲线上的Diffie-Hellman问题（都在计算上不可行）"></a>椭圆曲线上的Diffie-Hellman问题（都在计算上不可行）</h4><p>   给定 E(Fₚ)，以及 (P,  xP, yP)</p><ul><li>计算Diffie-Hellman问题 (CDH)<br>计算 xyP</li><li>判定Diffie-Hellman问题 (DDH)<br>给定 点 T∈ E(Fp) ，判断 T 是否等于 xyP</li></ul><h3 id="双线性映射"><a href="#双线性映射" class="headerlink" title="双线性映射"></a>双线性映射</h3><h4 id="超奇异椭圆曲线是有限域上一种特殊的椭圆曲线"><a href="#超奇异椭圆曲线是有限域上一种特殊的椭圆曲线" class="headerlink" title="超奇异椭圆曲线是有限域上一种特殊的椭圆曲线"></a>超奇异椭圆曲线是有限域上一种特殊的椭圆曲线</h4><h4 id="双线性映射：一种可以将曲线上两个点映射到基域上的一个元素的算法"><a href="#双线性映射：一种可以将曲线上两个点映射到基域上的一个元素的算法" class="headerlink" title="双线性映射：一种可以将曲线上两个点映射到基域上的一个元素的算法"></a>双线性映射：一种可以将曲线上两个点映射到基域上的一个元素的算法</h4>   <img src="/chunk.github.io/images/b15a1c11bd2e9c104ba106dcfd4f5bc6.jpg" alt="b15a1c11bd2e9c104ba106dcfd4f5bc6" style="zoom: 50%;" /><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>   设p是大素数，加法群 G₁ 和乘法群 G₂ 都是p阶循环群。双线性映射 e:G₁×G₁→G₂满足以下性质：<br>  <img src="/chunk.github.io/images/1d2ed5b44eb880b5193fd7e4ceaf3b96.jpg" alt="1d2ed5b44eb880b5193fd7e4ceaf3b96" style="zoom:50%;" /><br>    通常，取G₁为有限域上超奇异椭圆曲线，G₂为G₁的基域乘法群      </p><h4 id="支持双线性映射的开发包：PBC-Library、relic-toolkit、MIRACL"><a href="#支持双线性映射的开发包：PBC-Library、relic-toolkit、MIRACL" class="headerlink" title="支持双线性映射的开发包：PBC Library、relic-toolkit、MIRACL"></a>支持双线性映射的开发包：PBC Library、relic-toolkit、MIRACL</h4><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>   优点：提供了丰富的运算性质，可以满足以前难以满足的安全需求<br>   缺点：目前的计算速度较为缓慢</p><h4 id="有限域上超奇异椭圆曲线中，DDH问题不在困难"><a href="#有限域上超奇异椭圆曲线中，DDH问题不在困难" class="headerlink" title="有限域上超奇异椭圆曲线中，DDH问题不在困难"></a><strong>有限域上超奇异椭圆曲线中，DDH问题不在困难</strong></h4><p>   给定 E(Fₚ)，P,  xP,  yP，以及 T，很容易判断 T 是否等于 xyP</p>   <img src="/chunk.github.io/images/cb6745994e46dc3d0f07544edcde88c8.jpg" alt="cb6745994e46dc3d0f07544edcde88c8" style="zoom:50%;" /><h4 id="三方Diffie-Hellman密钥交换协议"><a href="#三方Diffie-Hellman密钥交换协议" class="headerlink" title="三方Diffie-Hellman密钥交换协议"></a>三方Diffie-Hellman密钥交换协议</h4>   <img src="/chunk.github.io/images/11c28257d11aff4303ca8c9ebeaec45c.jpg" alt="11c28257d11aff4303ca8c9ebeaec45c" style="zoom:50%;" /><h4 id="Bilinear-Diffie-Hellman问题（BDH）"><a href="#Bilinear-Diffie-Hellman问题（BDH）" class="headerlink" title="Bilinear Diffie-Hellman问题（BDH）"></a>Bilinear Diffie-Hellman问题（BDH）</h4><p>给定 G₁，G₂, 以及 P, aP, bP, cP,<br>计算 e(P, P)ᵃᵇᶜ<br>计算上不可行<br><img src="/chunk.github.io/images/1de31e27b7c2e6baf00c45134a274228.jpg" alt="1de31e27b7c2e6baf00c45134a274228" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公钥密码学</title>
      <link href="/chunk.github.io/2025/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/chunk.github.io/2025/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>由于对称加密体制存在的许多问题，公钥密码学被提出</p></blockquote><h5 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h5><ul><li>1976年，Diffie与Hellman提出公钥密码体制的设想</li><li>Diffie-Hellman 密钥交换协议</li><li>公钥技术是二十世纪最伟大的思想之一，密码学的一次伟大革命</li></ul><h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h5><ul><li>从未见过面的两个人如何实现秘密通信</li><li>Diffie-Hellman 密钥交换协议 只设想了该种可能，并未提出解决方案</li></ul><h5 id="RSA的发明"><a href="#RSA的发明" class="headerlink" title="RSA的发明"></a>RSA的发明</h5><blockquote><p>1978年，MIT的三位密码学家 Rivest，Shamir，Adleman联合发明RSA加密体制</p></blockquote><h4 id="Diffie-Hellman密钥交换协议"><a href="#Diffie-Hellman密钥交换协议" class="headerlink" title="Diffie-Hellman密钥交换协议"></a>Diffie-Hellman密钥交换协议</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5>   <img src="/chunk.github.io/images/830dc41f80d9cf9a0c0ab752ab94cc22.jpg" alt="830dc41f80d9cf9a0c0ab752ab94cc22" style="zoom:50%;" />##### 安全性   <img src="/chunk.github.io/images/229d83b58fa7e05091991bc63a5ad5c6.jpg" alt="229d83b58fa7e05091991bc63a5ad5c6" style="zoom:50%;" />   - Diffie-Hellman问题     <img src="/chunk.github.io/images/c298dc7d3dd61bcced0b2fb98e13ca5e.jpg" alt="c298dc7d3dd61bcced0b2fb98e13ca5e" style="zoom:50%;" />     安全性基于在有限域上的离散对数问题！   - 攻击手段     > 中间人攻击（Man-in-the-Middle Attack）：主动攻击下不安全     <pre><code> &lt;img src=&quot;/chunk.github.io/images/03574744b6adf0783c0ac388dc0f889a.jpg&quot; alt=&quot;03574744b6adf0783c0ac388dc0f889a&quot; style=&quot;zoom:50%;&quot; /&gt;</code></pre><blockquote><p>如何抵抗中间人攻击——需要对交换的数据进行&#x3D;&#x3D;认证&#x3D;&#x3D;，以使通信双方知道到底在与谁进行密钥交换</p></blockquote><h4 id="公钥加密体制"><a href="#公钥加密体制" class="headerlink" title="公钥加密体制"></a>公钥加密体制</h4><ul><li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><blockquote><p>一个公钥加密体制包含以下算法:</p><img src="/chunk.github.io/images/c65b1970dced63ac545eb9879e800a84.jpg" alt="c65b1970dced63ac545eb9879e800a84" style="zoom:50%;" />一致性要求: <p>Setup输出的 ∀(pk,  sk) : 对于∀m∈M，有 Dec(sk, Enc(pk, m)) &#x3D; m</p></blockquote></li><li><h5 id="密码通信模型"><a href="#密码通信模型" class="headerlink" title="密码通信模型"></a>密码通信模型</h5><img src="/chunk.github.io/images/6dae3a9ffbc4010c5061efec10fa15f1.jpg" alt="6dae3a9ffbc4010c5061efec10fa15f1" style="zoom:50%;" /></li><li><h5 id="陷门函数（trapdoor-function-TDF-）"><a href="#陷门函数（trapdoor-function-TDF-）" class="headerlink" title="陷门函数（trapdoor function, TDF ）"></a>陷门函数（trapdoor function, TDF ）</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/chunk.github.io/images/e19a3ae45c199b8c193fc9fb9b177b54.jpg" alt="e19a3ae45c199b8c193fc9fb9b177b54" style="zoom:50%;" /></h5><ul><li><h5 id="单向陷门函数"><a href="#单向陷门函数" class="headerlink" title="单向陷门函数"></a>单向陷门函数</h5><img src="/chunk.github.io/images/be61d5eb4a502f27aefd4470b12d195a.jpg" alt="be61d5eb4a502f27aefd4470b12d195a" style="zoom:50%;" /><ul><li>安全性<blockquote><p>如果所有高效的攻击者 A，在上述安全模型中<br>                              Adv :&#x3D;  Pr[ x &#x3D; x’ ]</p></blockquote></li></ul><p>  </p><blockquote><p>是可忽略的，则 (G, F, F^-1)  是安全的陷门函数 (此时称之为单向陷门函数，one-way trapdoor function, one-way TDF) </p></blockquote></li><li><h5 id="基于one-way-TDF构造公钥加密体制"><a href="#基于one-way-TDF构造公钥加密体制" class="headerlink" title="基于one-way TDF构造公钥加密体制"></a>基于one-way TDF构造公钥加密体制</h5><img src="/chunk.github.io/images/df775d8de55375e0745afe59ea2eda67.jpg" alt="df775d8de55375e0745afe59ea2eda67" style="zoom:50%;" /><img src="/chunk.github.io/images/f092b37256061a59396b91be163cef50.jpg" alt="f092b37256061a59396b91be163cef50" style="zoom:50%;" /><ul><li>应用避坑指南<img src="/chunk.github.io/images/6423ee38c905ff34526d175912aa4225.jpg" alt="6423ee38c905ff34526d175912aa4225" style="zoom:50%;" /></li></ul></li></ul></li><li><h5 id="陷门置换"><a href="#陷门置换" class="headerlink" title="陷门置换"></a>陷门置换</h5><ul><li><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><img src="/chunk.github.io/images/ed3ff269cd4aa4bd0da866fbeb36bd08.jpg" alt="ed3ff269cd4aa4bd0da866fbeb36bd08" style="zoom:50%;" /></li><li><h6 id="单向陷门置换（one-way-trapdoor-permutation-one-way-TDP）"><a href="#单向陷门置换（one-way-trapdoor-permutation-one-way-TDP）" class="headerlink" title="单向陷门置换（one-way trapdoor permutation, one-way TDP）"></a>单向陷门置换（one-way trapdoor permutation, one-way TDP）</h6><img src="/chunk.github.io/images/da093d60f74d75bb951275c6fdf8c32d.jpg" alt="da093d60f74d75bb951275c6fdf8c32d" style="zoom:50%;" /></li></ul></li></ul><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><h5 id="RSA-1"><a href="#RSA-1" class="headerlink" title="RSA"></a>RSA</h5><ul><li><h6 id="RSA陷门置换"><a href="#RSA陷门置换" class="headerlink" title="RSA陷门置换"></a>RSA陷门置换</h6><img src="/chunk.github.io/images/98832b14f770ad4a460cb1e3ba326c20.jpg" alt="98832b14f770ad4a460cb1e3ba326c20" style="zoom:50%;" /><img src="/chunk.github.io/images/eb9b5771c556f2b2d4bfb82e98536171.jpg" alt="eb9b5771c556f2b2d4bfb82e98536171" style="zoom:50%;" /></li><li><p>RSA陷门置换的计算问题</p><ul><li>如何产生两个大素数？<br>素数检测</li><li>如何计算d？<br>ed ≡ 1(mod ø(n))，事实上&#x3D;&#x3D;d和e在模ø(n)下互为逆元&#x3D;&#x3D;</li><li>接着计算模运算下的整数求模</li></ul></li><li><h6 id="RSA假设"><a href="#RSA假设" class="headerlink" title="RSA假设"></a>RSA假设</h6><img src="/chunk.github.io/images/4e35cb1e0c8564250fc74a89a7af3ac7.jpg" alt="4e35cb1e0c8564250fc74a89a7af3ac7" style="zoom:50%;" /></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RSA 是否是one-way TDP (安全的陷门置换)？           未知</span><br></pre></td></tr></table></figure><ul><li><h6 id="教科书式RSA"><a href="#教科书式RSA" class="headerlink" title="教科书式RSA"></a>教科书式RSA</h6><img src="/chunk.github.io/images/f931f16485675a8c5bf7628964e7eb56.jpg" alt="f931f16485675a8c5bf7628964e7eb56" style="zoom:50%;" /></li><li>不安全的加密方法 ！！！<br>不是语义安全的，存在很多攻击方法<br>⇒ <strong>&#x3D;&#x3D;RSA 陷门置换只是个函数，不是加密体制&#x3D;&#x3D;，不能直接拿来用!</strong></li><li>安全性<ul><li>？可看作大整数分解问题—未定<br>已知 n 是两个大素数 p 和 q 的乘积，对 n 进行分解，求出 p 和 q</li><li><h6 id="安全隐患-实际应用RSA时要注意很多问题，否则攻击者即使不知道陷门信息，仍可以发动各种形式的攻击"><a href="#安全隐患-实际应用RSA时要注意很多问题，否则攻击者即使不知道陷门信息，仍可以发动各种形式的攻击" class="headerlink" title="安全隐患   实际应用RSA时要注意很多问题，否则攻击者即使不知道陷门信息，仍可以发动各种形式的攻击"></a>安全隐患   实际应用RSA时要注意很多问题，否则攻击者即使不知道陷门信息，仍可以发动各种形式的攻击</h6><ul><li>共模攻击</li><li>低加密指数攻击</li><li>低解密指数攻击</li><li>选择密文攻击<br>……</li></ul></li></ul><ul><li>共模攻击</li></ul><img src="/chunk.github.io/images/334abbb5681acf21f5bbf7734a23c658.jpg" alt="334abbb5681acf21f5bbf7734a23c658" style="zoom:50%;" /></li><li><h6 id="参数和性能"><a href="#参数和性能" class="headerlink" title="参数和性能"></a>参数和性能</h6><ul><li>一般选择p、q为安全素数<ul><li>安全素数：形如p&#x3D;2m+1的素数，m也是素数</li><li>目的：确保p-1、q-1都有大的素因子，增加猜测φ(n)的难度</li></ul></li><li>e的选择<ul><li>一般选 &#x3D;&#x3D;<strong>e&#x3D;3、17、65537(2^16+1）</strong>&#x3D;&#x3D;</li></ul></li><li>d要大于某个值，否则易遭攻击（Wiener’s attack）</li><li>执行的非对称性:  加密快 &#x2F; 解密慢</li></ul></li><li><h6 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h6><ul><li>安全性问题<ul><li>还无法证明对RSA的破译是否等同于大整数分解问题</li><li>只是到目前为止，RSA似乎是安全的</li></ul></li><li>速度问题<ul><li>增大p和q将使计算开销指数级增长</li></ul></li><li>选择合适的p和q对普通用户很困难</li></ul></li></ul><h5 id="PKCS"><a href="#PKCS" class="headerlink" title="PKCS"></a>PKCS</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">永远不要使用“教科书式RSA”，实际应用中如何使用？</span><br></pre></td></tr></table></figure><img src="/chunk.github.io/images/4a73de3696ff8525e011539ef10f48e4.jpg" alt="4a73de3696ff8525e011539ef10f48e4" style="zoom:50%;" /><ul><li><p>优化的非对称加密填充:  OAEP ——是CCA安全的</p><img src="/chunk.github.io/images/defb5709c4fcd876cdcef4ea185be854.jpg" alt="defb5709c4fcd876cdcef4ea185be854" style="zoom:50%;" /></li><li><p>OAEP的变种</p><img src="/chunk.github.io/images/b3a70b592a0ad5d3a4512f4e5a71fe5b.jpg" alt="b3a70b592a0ad5d3a4512f4e5a71fe5b" style="zoom:50%;" /><img src="/chunk.github.io/images/1360d8c44ca1be1f146017219815d44a.jpg" alt="1360d8c44ca1be1f146017219815d44a" style="zoom:50%;" /></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="公钥密码的缺点"><a href="#公钥密码的缺点" class="headerlink" title="公钥密码的缺点"></a>公钥密码的缺点</h5><ul><li>计算速度慢</li><li>密钥长（公钥密码的密钥分发并不简单）</li><li>应用历史短</li></ul><h5 id="关于公钥密码的错误认识"><a href="#关于公钥密码的错误认识" class="headerlink" title="关于公钥密码的错误认识"></a>关于公钥密码的错误认识</h5><ul><li>公钥密码更安全</li><li>对称密码体制已经过时<ul><li>RSA最快的情况也比DES慢上100倍，速度一直是公钥密码体制的缺陷。</li></ul></li><li>公钥分发十分简单</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析</title>
      <link href="/chunk.github.io/2025/04/07/%E7%BC%96%E7%A8%8B/%E7%AB%9E%E8%B5%9B%E9%A2%98%E9%A2%98%E5%B9%B2%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90/"/>
      <url>/chunk.github.io/2025/04/07/%E7%BC%96%E7%A8%8B/%E7%AB%9E%E8%B5%9B%E9%A2%98%E9%A2%98%E5%B9%B2%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="算法题目的分析过程"><a href="#算法题目的分析过程" class="headerlink" title="算法题目的分析过程"></a>算法题目的分析过程</h2><h4 id="算法题目的构成"><a href="#算法题目的构成" class="headerlink" title="算法题目的构成"></a>算法题目的构成</h4><p>大量的数据、处理数据的要求、时间及空间上的限制</p><h4 id="正确代码满足的要求"><a href="#正确代码满足的要求" class="headerlink" title="正确代码满足的要求"></a>正确代码满足的要求</h4><p>（1） 答案正确<br>（2） 不超过给定的时间与空间复杂度</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h6 id="前提——1s运算10-8-10-9-次"><a href="#前提——1s运算10-8-10-9-次" class="headerlink" title="前提——1s运算10^8^ - 10^9^次"></a>前提——1s运算10^8^ - 10^9^次</h6><h6 id="大O计算时间复杂度—-根据n的范围来判断要多少秒"><a href="#大O计算时间复杂度—-根据n的范围来判断要多少秒" class="headerlink" title="大O计算时间复杂度—-根据n的范围来判断要多少秒"></a>大O计算时间复杂度—-根据n的范围来判断要多少秒</h6><pre><code> a.只保留最高次项 b.最高次项系数默认为1</code></pre><h4 id="空间限制"><a href="#空间限制" class="headerlink" title="空间限制"></a>空间限制</h4><pre><code> 1MB=1024KB 1KB=1024B 1B=8bits</code></pre><h6 id="题目限制：a-MB"><a href="#题目限制：a-MB" class="headerlink" title="题目限制：a MB"></a>题目限制：a MB</h6><h6 id="分析：所占字节为-a-1024-1024-字节"><a href="#分析：所占字节为-a-1024-1024-字节" class="headerlink" title="分析：所占字节为 a * 1024 *1024 字节"></a>分析：所占字节为 a * 1024 *1024 字节</h6><h6 id="数组基本上能开到10-7-大小（二维时容易超过）-一般保证在10-8-以内即可"><a href="#数组基本上能开到10-7-大小（二维时容易超过）-一般保证在10-8-以内即可" class="headerlink" title="数组基本上能开到10^7^大小（二维时容易超过）,一般保证在10^8^以内即可"></a>数组基本上能开到10^7^大小（二维时容易超过）,<strong>一般保证在10^8^以内即可</strong></h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//加入代码使运行速度加快</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">cin.tie(0);</span><br><span class="line">//int型变量——10^9</span><br></pre></td></tr></table></figure><h5 id="如何根据题目所给内存来开辟数组空间"><a href="#如何根据题目所给内存来开辟数组空间" class="headerlink" title="如何根据题目所给内存来开辟数组空间"></a>如何根据题目所给内存来开辟数组空间</h5><ol><li>看数组元素个数 × 单个元素的大小（字节） ≈ 占用总内存</li><li>估算总内存（MB级别）<blockquote><p>总内存（MB） ≈ 元素个数 × 单个元素大小（字节） ÷ 1024 ÷ 1024</p></blockquote></li><li>常见的安全上限<blockquote><p>用全局变量比局部变量更能开大</p></blockquote></li></ol><table><thead><tr><th>分配方式</th><th>安全大小估计</th><th>说明</th></tr></thead><tbody><tr><td>全局变量</td><td>int a[1e8]</td><td>靠谱</td></tr><tr><td>局部变量</td><td>int a[1e5]</td><td>$ 10^5 $~$ 10^6 $</td></tr><tr><td>vector</td><td>vector&lt;<int>int&gt; a(1e8)</td><td>在堆上分配</td></tr><tr><td>new</td><td>int* a&#x3D;new int[1e8]</td><td>记得delete</td></tr></tbody></table><h5 id="如何根据时间限制选择合适的算法复杂度"><a href="#如何根据时间限制选择合适的算法复杂度" class="headerlink" title="如何根据时间限制选择合适的算法复杂度"></a>如何根据时间限制选择合适的算法复杂度</h5><blockquote><p>十个以内暴力嗨，百级以内三重开；<br>千级范围二重齐，万级上下快排来；<br>十万百万靠 log 带，千万以上看常态。</p></blockquote><table><thead><tr><th>数据范围（N）</th><th>建议的时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td>≤ 10</td><td>O(n!)、O(2^n)</td><td>枚举、全排列都能过</td></tr><tr><td>≤ 100</td><td>O(n³)</td><td>Floyd、三重循环没压力</td></tr><tr><td>≤ 1,000</td><td>O(n²)</td><td>暴力模拟、dp都能过</td></tr><tr><td>≤ 1e4</td><td>O(n·√n)、O(n log n)</td><td>优化算法、快速排序级别</td></tr><tr><td>≤ 1e5</td><td>O(nlog n)</td><td>排序、树状数组、线段树</td></tr><tr><td>≤ 1e6</td><td>O(n)</td><td>线性处理、桶排、哈希表</td></tr><tr><td>≤ 1e7 ~ 1e8</td><td>O(1)、O(log n)</td><td>只能做快速运算、查找等</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程，竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash函数</title>
      <link href="/chunk.github.io/2025/04/03/%E5%AF%86%E7%A0%81%E5%AD%A6/Hash%E5%87%BD%E6%95%B0/"/>
      <url>/chunk.github.io/2025/04/03/%E5%AF%86%E7%A0%81%E5%AD%A6/Hash%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h6 id="Hash函数的定义"><a href="#Hash函数的定义" class="headerlink" title="Hash函数的定义"></a>Hash函数的定义</h6><ul><li>是一个高效的确定性函数，将一个长消息映射成固定长度的输出</li><li>H:  M -&gt; Y  (|M| &gt;&gt; |Y|)</li><li>输入称为消息，输出称为散列值</li></ul><h6 id="碰撞的定义"><a href="#碰撞的定义" class="headerlink" title="碰撞的定义"></a>碰撞的定义</h6><img src="/chunk.github.io/images/e2c15ff3309e15af09a22730126e51ca.jpg" alt="e2c15ff3309e15af09a22730126e51ca" style="zoom:50%;" /><h6 id="Hash函数的安全性"><a href="#Hash函数的安全性" class="headerlink" title="Hash函数的安全性"></a>Hash函数的安全性</h6><ul><li>安全的Hash函数的性质<ul><li>原像稳固<ul><li>给定散列值 y ∈ Y ，要找到一个消息m ∈ M，使得 H(m)&#x3D;y 是计算上不可行的</li><li> 单向性</li></ul></li></ul><ul><li>第二原像稳固<ul><li>给定一个消息m ∈ M，要找到另一个消息m’ ∈ M (m !&#x3D; m’) ，使得H(m)&#x3D;H(m’) 是计算上不可行的</li><li>弱抗碰撞性</li></ul></li><li>碰撞稳固<ul><li>找到一对消息 m, m’ ∈ M (m !&#x3D; m’) ，使得 H(m)&#x3D;H(m’) 是计算上不可行的</li><li>最容易找到的——若Hash满足该性质，则称为强抗碰撞性</li></ul></li></ul></li><li>抗碰撞Hash函数<ul><li>设 H 是 Hash函数，如果所有高效的攻击者 A 能够找到碰撞的概率是可忽略的，则称 H 为 抗碰撞Hash函数 </li><li>具有的性质：碰撞稳固、第二原像稳固</li><li>在实际应用中会同时设计成原像稳固的</li></ul></li><li>若Hash函数设计的好，则不能绕过H算散列值</li></ul><img src="/chunk.github.io/images/913cd75c4986e285b7e1a3b2433936af.jpg" alt="913cd75c4986e285b7e1a3b2433936af" style="zoom:50%;" /><h6 id="全域Hash函数"><a href="#全域Hash函数" class="headerlink" title="全域Hash函数"></a>全域Hash函数</h6><pre><code> H：M-&gt;X（X为TDP的定义域）</code></pre><h4 id="生日攻击—找到两个碰撞"><a href="#生日攻击—找到两个碰撞" class="headerlink" title="生日攻击—找到两个碰撞"></a>生日攻击—找到两个碰撞</h4><ul><li>目的<blockquote><p>设散列值是n比特，构造两个不同的消息 m₀、m₁ ，使 m₀和m₁ 具有相同的散列值。</p></blockquote></li><li>攻击步骤<br>   1. 随机产生k个消息，计算他们的散列值<br>   2. 如果存在两个不同消息是碰撞，则输出这两个消息，攻击结束<br>   3. 否则继续步骤1</li><li>&#x3D;&#x3D;要达到 O(2ⁿ) 安全性，选择的Hash函数的散列值长度应该是2n比特&#x3D;&#x3D;</li></ul><h4 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h4><ol><li>MD5<ul><li>MD5不是加密算法！</li><li>不建议使用</li></ul></li><li>SHA系列<ul><li>不建议使用SHA-0,SHA-1</li><li>使用SHA2时，建议使用 SHA-512&#x2F;224、SHA-512&#x2F;256</li></ul></li></ol><h4 id="Merkle-Damgard-迭代技术"><a href="#Merkle-Damgard-迭代技术" class="headerlink" title="Merkle-Damgard 迭代技术"></a>Merkle-Damgard 迭代技术</h4><p><code>大多数实用的抗碰撞hash函数都是采用迭代技术构造的</code></p><h6 id="MD迭代"><a href="#MD迭代" class="headerlink" title="MD迭代"></a>MD迭代</h6><ul><li><p>定义</p><blockquote><p> 利用处理短消息的抗碰撞Hash函数，通过迭代技术，构造可以处理长消息的抗碰撞Hash函数。</p></blockquote></li><li><p>原理</p><img src="/chunk.github.io/images/250e6955e1a5e1959e1ddfe257e91876.jpg" alt="250e6955e1a5e1959e1ddfe257e91876" style="zoom:50%;" /><img src="/chunk.github.io/images/2130cb3262029735358924b7f1e9720f.jpg" alt="2130cb3262029735358924b7f1e9720f" style="zoom:50%;" /><img src="/chunk.github.io/images/2faec96dc25455e1687799cc9bf9f78d.jpg" alt="2faec96dc25455e1687799cc9bf9f78d" style="zoom:50%;" /></li><li><p>安全性</p><ul><li>如果压缩函数 h 是碰撞稳固的, MD迭代技术构造的 H 是抗碰撞Hash函数</li><li>只需考虑如何构造碰撞稳固的压缩函数 h: T × X ⟶ T</li></ul></li></ul><h6 id="Davies-Meyer压缩函数"><a href="#Davies-Meyer压缩函数" class="headerlink" title="Davies-Meyer压缩函数"></a>Davies-Meyer压缩函数</h6><ul><li>构造<img src="/chunk.github.io/images/8ee0406acd8c652573eb3346b742d1e5.jpg" alt="8ee0406acd8c652573eb3346b742d1e5" style="zoom:50%;" /></li><li>例题<br><code>如果 h(Hᵢ, mᵢ) = E(mᵢ,Hᵢ) ，那么h就不是碰撞稳固的。</code><br>        要找一对h的碰撞 (H₀, m₀) 和(H₁, m₁) ，可以选随机找 H₀, m₀和m₁ ，然后构造H₁ &#x3D; _______________________。<img src="/chunk.github.io/images/7db57374fd9c0ec297e4ef03c2eaa5a2.jpg" alt="7db57374fd9c0ec297e4ef03c2eaa5a2" style="zoom: 50%;" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分组密码</title>
      <link href="/chunk.github.io/2025/03/29/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"/>
      <url>/chunk.github.io/2025/03/29/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="分组密码（每次加密固定长度的明文）"><a href="#分组密码（每次加密固定长度的明文）" class="headerlink" title="分组密码（每次加密固定长度的明文）"></a>分组密码（每次加密固定长度的明文）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>   输入：一个定长的明文分组<br>   输出：一个等长的密文分组</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><p>   DES:   n&#x3D; 64 bits,    k &#x3D; 64 bits<br>   AES:   n&#x3D;128 bits,    k &#x3D; 128, 192, 256 bits</p><h4 id="设计分组密码的两种基本技术"><a href="#设计分组密码的两种基本技术" class="headerlink" title="设计分组密码的两种基本技术"></a>设计分组密码的两种基本技术</h4><p>   <code>混乱和扩散的思想由香农提出,目的是为了抵抗攻击者对密码系统的统计分析</code></p><ul><li>混乱<ul><li>目的：使明文和密文之间、密钥和密文之间的相关统计特性极小化，从而使攻击者无法找到密钥</li><li>方法：代换</li></ul></li><li>扩散<ul><li>目的：将明文及密钥的影响尽可能迅速地散布到较多个密文比特中</li><li>方法：置换</li></ul></li></ul><h4 id="分组密码的迭代构造"><a href="#分组密码的迭代构造" class="headerlink" title="分组密码的迭代构造"></a>分组密码的迭代构造</h4><p>   <code>目前，绝大多数的分组密码都是通过迭代技术构造的</code></p><img src="/chunk.github.io/images/ea5e5dd77984238841eaceb16d97fe76.jpg" alt="ea5e5dd77984238841eaceb16d97fe76" style="zoom:50%;" /><h3 id="数据加密标准（DES）"><a href="#数据加密标准（DES）" class="headerlink" title="数据加密标准（DES）"></a>数据加密标准（DES）</h3><h4 id="核心设计思想：Feistel-网络"><a href="#核心设计思想：Feistel-网络" class="headerlink" title="核心设计思想：Feistel 网络"></a>核心设计思想：Feistel 网络</h4>   <img src="/chunk.github.io/images/d60eb10b673e58e10453bc6acff8501c.jpg" alt="d60eb10b673e58e10453bc6acff8501c" style="zoom:50%;" />#### 为什么 Feistel 网络是可逆的？   <img src="/chunk.github.io/images/88e264039f4441cb13b3056499faab0d.jpg" alt="88e264039f4441cb13b3056499faab0d" style="zoom:50%;" />#### 求逆过程   <img src="/chunk.github.io/images/7ed6f4067415d94d81bde354174efd9d.jpg" alt="7ed6f4067415d94d81bde354174efd9d" style="zoom:50%;" />#### DES的结构<img src="/chunk.github.io/images/b9a7c0ef023c76a013b46eb3f7f55737.jpg" alt="b9a7c0ef023c76a013b46eb3f7f55737" style="zoom:50%;" /><img src="/chunk.github.io/images/1cce1c407b0f0f6ca72076e930c4bcd9.jpg" alt="1cce1c407b0f0f6ca72076e930c4bcd9" style="zoom:50%;" /><p>   乘积函数F有三个关键函数:</p><ul><li>E-box</li><li>S-box(DES里唯一的非线性部分)</li><li>P-box</li></ul><h4 id="DES的安全性"><a href="#DES的安全性" class="headerlink" title="DES的安全性"></a>DES的安全性</h4><ul><li>DES的最大问题: <ul><li>随着计算机技术的飞速发展，56 bits 的 有效密钥长度不足以抵抗穷举攻击</li><li>因为密钥空间大小只有 2[^56] ≈ 1017</li></ul></li><li>DES依靠S-box实现非线性变换，但NSA被指责在S-box设计上隐藏了“陷门”<ul><li>穷举密钥攻击可以攻破有效密钥长度的DES</li></ul></li></ul><h3 id="抵抗穷举攻击"><a href="#抵抗穷举攻击" class="headerlink" title="抵抗穷举攻击"></a>抵抗穷举攻击</h3><p><code>穷举攻击（已知明文攻击）：给定明密文对  (mᵢ, cᵢ = E(k, mᵢ))   i=1, 2, 3……找到密钥 k</code><br><code>如何抵抗DES的穷举攻击-&gt;增加密钥长度</code></p><h4 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h4><blockquote><p>使用两个或三个密钥，执行三次DES算法<br>使用3个密钥，有效密钥长度可达 168 bits<br>使用2个密钥，有效密钥长度可达 112 bits</p><img src="/chunk.github.io/images/7f78f90f6c06b256b034c960441bea96.jpg" alt="7f78f90f6c06b256b034c960441bea96" style="zoom:50%;" /><p>例：DES-EDE3，是以三个不同的密钥，以加密-解密-加密的方式依次处理</p></blockquote><h4 id="中间相遇攻击（Meet-in-the-middle-attack）"><a href="#中间相遇攻击（Meet-in-the-middle-attack）" class="headerlink" title="中间相遇攻击（Meet-in-the-middle attack）"></a>中间相遇攻击（Meet-in-the-middle attack）</h4><blockquote><p>当使用两重DES时，会遭受中间相遇攻击<br><img src="/chunk.github.io/images/5a899a21df281cd19450f5ab77525f1b.jpg" alt="5a899a21df281cd19450f5ab77525f1b" style="zoom:50%;" /></p></blockquote><h4 id="DESX"><a href="#DESX" class="headerlink" title="DESX"></a>DESX</h4><p>用3DES加密时，效率只有原DES的1&#x2F;3。R.Rivest提出DESX作为DES的扩充版本。希望以更少的效率损失增加密钥的长度及穷举攻击的难度。<br> <img src="/chunk.github.io/images/729ab86f90ad2888bb2282a71398077d.jpg" alt="729ab86f90ad2888bb2282a71398077d" style="zoom:50%;" /></p><h4 id="其他分组密码体制"><a href="#其他分组密码体制" class="headerlink" title="其他分组密码体制"></a>其他分组密码体制</h4><ul><li>AES（高级加密标准）<ul><li>DES的替代品</li><li>比3DES快且至少一样安全, 分组128 bits, 密钥128&#x2F;192&#x2F;256 bits</li></ul></li><li>IDEA<ul><li>分组长度 64 bits,  密钥长度 128 bits, 用于 PGP</li></ul></li></ul><h3 id="PRF和PRP"><a href="#PRF和PRP" class="headerlink" title="PRF和PRP"></a>PRF和PRP</h3><p><code>PRF和PRP是描述分组密码安全性的工具，是两种理想模型</code></p><h4 id="PRF（伪随机函数）"><a href="#PRF（伪随机函数）" class="headerlink" title="PRF（伪随机函数）"></a>PRF（伪随机函数）</h4><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><pre><code>  存在高效的算法计算  F(k,x),   F:  K × X -&gt;Y</code></pre><h6 id="直觉上的安全"><a href="#直觉上的安全" class="headerlink" title="直觉上的安全"></a>直觉上的安全</h6><img src="/chunk.github.io/images/bb03e26d2bf3581ac62fcc3bf0c511f8.jpg" alt="bb03e26d2bf3581ac62fcc3bf0c511f8" style="zoom:50%;" /><h6 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h6><img src="/chunk.github.io/images/39ace6d33edf532eccb77bf9a23b5f61.jpg" alt="39ace6d33edf532eccb77bf9a23b5f61" style="zoom:50%;" /><pre><code>如果对于所有高效的攻击者A，                   Adv  :=  |Pr[EXP(0)=1] – Pr[EXP(1)=1] |     是可忽略的，则F是安全的 PRF</code></pre><h4 id="PRP（伪随机置换）"><a href="#PRP（伪随机置换）" class="headerlink" title="PRP（伪随机置换）"></a>PRP（伪随机置换）</h4><p><code>存在逆置换，可以用来做加解密</code></p><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><pre><code>  存在高效的算法计算置换 E(k, x)(对应的逆置换为D(k, x)),   E:  K × X  -&gt;X</code></pre><h6 id="直觉上的安全-1"><a href="#直觉上的安全-1" class="headerlink" title="直觉上的安全"></a>直觉上的安全</h6><img src="/chunk.github.io/images/3780d774e12cd81d8a1d1be30382acf5.jpg" alt="3780d774e12cd81d8a1d1be30382acf5" style="zoom:50%;" /><h6 id="安全模型-1"><a href="#安全模型-1" class="headerlink" title="安全模型"></a>安全模型</h6><img src="/chunk.github.io/images/7d89ebe4df2c4ef507f932413605293c.jpg" alt="7d89ebe4df2c4ef507f932413605293c" style="zoom:50%;" /><pre><code>如果对于所有高效的攻击者A，         Adv  :=  |Pr[EXP(0)=1] – Pr[EXP(1)=1] |     是可忽略的，则E是安全的 PRP</code></pre><p>任何 PRP 也是 PRF，其中X &#x3D; Y，并且是高效可逆的！</p><h4 id="PRF-Switching-Lemma"><a href="#PRF-Switching-Lemma" class="headerlink" title="PRF Switching Lemma"></a>PRF Switching Lemma</h4><p><strong>当|X|足够大时，安全的 PRP 才是安全的 PRF</strong></p><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ul><li>实际应用中，认为这些分组密码是安全的PRP：AES（｜X｜足够大）</li><li>绝大多数情况下，PRF可以用AES等分组密码进行代替</li></ul><h3 id="CPA安全性"><a href="#CPA安全性" class="headerlink" title="CPA安全性"></a>CPA安全性</h3><p><code>密钥重复使用时，如何保证安全性？</code></p><h4 id="攻击形式"><a href="#攻击形式" class="headerlink" title="攻击形式"></a>攻击形式</h4><ul><li>密钥可以重复使用  ⇒  攻击者可以获得同一密钥加密的多个密文</li><li>攻击者攻击能力：<ul><li>选择明文攻击 (CPA, chosen-plaintext attack) (密钥可以重复使用)<br>可以获得他选择的一个或多个明文对应的密文</li><li>攻击者攻击目的：破坏语义安全性</li></ul></li></ul><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>选择明文攻击下的语义安全性 ，简称 CPA安全性。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><img src="/chunk.github.io/images/b8ec9efa2de2504127dceab92ef828a0.jpg" alt="b8ec9efa2de2504127dceab92ef828a0" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果一个对称加密体制是CPA安全的，它应满足以下条件：</span><br><span class="line">在上述安全模型中，对于所有高效的攻击者A,</span><br><span class="line">         Adv :=| Pr[EXP(0)=1] – Pr[EXP(1)=1] |</span><br><span class="line">是可忽略的。</span><br></pre></td></tr></table></figure><h4 id="确定性的加密对称体制不是CPA安全的"><a href="#确定性的加密对称体制不是CPA安全的" class="headerlink" title="确定性的加密对称体制不是CPA安全的"></a>确定性的加密对称体制不是CPA安全的</h4><blockquote><p>设 E 是确定性的（对相同的明文，总是输出相同的密文）</p><img src="/chunk.github.io/images/4fab9fde4933816371ac5acea434eb01.jpg" alt="4fab9fde4933816371ac5acea434eb01" style="zoom:50%;" /></blockquote><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>如何实现密钥的重复使用 (即满足CPA安全性)？<ul><li>加密体制必须是概率的 (对于相同密钥和明文，密文可以不相同)</li><li>加密相同的明文，得到相同密文的概率是可忽略的</li></ul></li></ul><h5 id="随机加密"><a href="#随机加密" class="headerlink" title="随机加密"></a>随机加密</h5><img src="/chunk.github.io/images/b1c0545ee707e20fee0fff3430185837.jpg" alt="b1c0545ee707e20fee0fff3430185837" style="zoom:50%;" /><h5 id="nonce-based加密"><a href="#nonce-based加密" class="headerlink" title="nonce-based加密"></a>nonce-based加密</h5><img src="/chunk.github.io/images/e1486df16d02f49dbc7b9a0ebc543deb.jpg" alt="e1486df16d02f49dbc7b9a0ebc543deb" style="zoom:50%;" /><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么需要工作模式？</span><br><span class="line">分组密码的输入是定长的。</span><br><span class="line">要加密的明文长度往往大于一个明文分组。</span><br><span class="line">需要采用适当的工作模式以保证明文整体的安全性</span><br></pre></td></tr></table></figure><img src="/chunk.github.io/images/712d604256a9614a8e6534249c0d13de.jpg" alt="712d604256a9614a8e6534249c0d13de" style="zoom:50%;" /><h4 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h4><p><code>不是语义安全的，不推荐使用</code></p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><img src="/chunk.github.io/images/489a252a576184f098ebc6fae5b9119c.jpg" alt="489a252a576184f098ebc6fae5b9119c" style="zoom:50%;" /><h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><blockquote><p>对于包含两个或两个以上分组的明文，ECB不是语义安全的</p><img src="/chunk.github.io/images/74323d13a12acddf17753785196895e4.jpg" alt="74323d13a12acddf17753785196895e4" style="zoom:50%;" /></blockquote><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>优点<ul><li>简单、高速</li><li>无差错传播：单个密文分组在传输或存储时出现错误，只会影响该分组的解密，不会影响到其他分组</li></ul></li><li>缺点<ul><li>安全性差，暴露明文数据的格式和统计特征</li></ul></li><li>适用于发送少量数据的场合，一般不推荐使用</li></ul><h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p><code>密钥可以重复使用，CPA安全的</code></p><h5 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h5><img src="/chunk.github.io/images/8f6673e9814da69919d37bde300ad124.jpg" alt="8f6673e9814da69919d37bde300ad124" style="zoom:50%;" /><h5 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h5><img src="/chunk.github.io/images/9cb9cc2e82b01304f3765bc0a5fd3452.jpg" alt="9cb9cc2e82b01304f3765bc0a5fd3452" style="zoom:50%;" /><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><ul><li>差错传播<br>单个密文分组在传输或存储过程中发生错误，会影响该分组和后面一个分组的解密。</li><li>可自同步<br>只要后面的分组没发生错误，便不会影响后续分组的解密<img src="/chunk.github.io/images/8fce40a89795c4cf13dfd79880574194.jpg" alt="8fce40a89795c4cf13dfd79880574194" style="zoom: 50%;" />如果IV是可预测的，则不是CPA安全的！！！</li></ul><h5 id="IV的选择"><a href="#IV的选择" class="headerlink" title="IV的选择"></a>IV的选择</h5><ul><li>CBC$：IV取随机数，与密文一起发送。<br>用安全的PRG产生随机数，以保证不可预测性</li><li>CBCC：IV取计数器（接收者不知道IV时，才需要发送）<br>计数器按照固定步长增加，所以是可预测的。<br>如果直接使用，会使CBC模式不安全。<br>(可以使用 CBC-ESSIV，即先加密计数器，再使用）</li><li>CBC-ESSIV:  先加密计数器，再使用。（k&#x3D;k ₁时不安全）<img src="/chunk.github.io/images/af702f27cd94f31ad99090c07f22a862.jpg" alt="af702f27cd94f31ad99090c07f22a862" style="zoom:50%;" /></li><li>举例：Crypto API    (OpenSSL)<br>调用者提供IV<br><code>当IV是计数器时，使用前需要先加密，否则不安全</code></li></ul><h5 id="填充（Padding）"><a href="#填充（Padding）" class="headerlink" title="填充（Padding）"></a>填充（Padding）</h5><blockquote><p>明文长度是不固定的，按固定长度分组时，如果最后一个分组长度不足时进行填充。</p><img src="/chunk.github.io/images/5ae4e8e9d12c618383f7b7de987bcda9.jpg" alt="5ae4e8e9d12c618383f7b7de987bcda9" style="zoom:50%;" /></blockquote><h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p><code>密钥可以重复使用，CPA安全的</code></p><h5 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h5><img src="/chunk.github.io/images/37b53daccf291329065a6ce78e30eda9.jpg" alt="37b53daccf291329065a6ce78e30eda9" style="zoom:50%;" /><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h5><ul><li>简单&#x2F;速度快<ul><li>实现简单（只需要加密算法）， 效率高&#x2F; 可预计算, 可并行，吞吐量仅受可并行数量的限制</li></ul></li><li>没有差错传播<ul><li>单个密文分组在传输或存储过程中发生错误，只影响该分组的解密，不影响其他分组。</li></ul></li></ul><h5 id="IV的选择-1"><a href="#IV的选择-1" class="headerlink" title="IV的选择"></a>IV的选择</h5><ul><li>CTR$<br>IV取随机数，与密文一起发送。<br>使用安全的PRG产生随机数，以保证不可预测性</li><li>CTRC<br>IV取计数器（接收者不知道IV时，才需要发送）<br>保证F(k, x)不会重复出现，例如可以计数器从0开始，每加密一个明文分组便加1</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th></th><th>CBC</th><th>CTR</th></tr></thead><tbody><tr><td>抽象工具</td><td>PRP</td><td>PRF</td></tr><tr><td>并行性</td><td>（加密）不行</td><td>可以</td></tr><tr><td>填充</td><td><strong>需要</strong></td><td>不需要</td></tr><tr><td>密文有扩张</td><td>有</td><td>没有</td></tr><tr><td>使用密文窃取填充技术时，不需要 dummy block</td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>密钥只能用一次</th><th>密钥可重复使用（CPA安全）</th></tr></thead><tbody><tr><td>语义安全性</td><td>流密码</td><td>CBC、CTR</td></tr></tbody></table><ul><li>两个重要安全性概念: (抵抗窃听者) <ul><li><p>语义安全性 (密钥只用一次时)</p></li><li><p>CPA安全性 (密钥重复使用时)</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对称密码</title>
      <link href="/chunk.github.io/2025/03/24/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/"/>
      <url>/chunk.github.io/2025/03/24/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h5 id="对称加密体制"><a href="#对称加密体制" class="headerlink" title="对称加密体制"></a>对称加密体制</h5><p>定义：对称加密体制是一对高效的算法 E 和 D，<br>              E:  K × M  -&gt;  C<br>              D:  K × C  -&gt;  M，<br>      满足 D(k, E(k, m)) &#x3D; m, ∀ m ∈ M，k ∈ K，<br>      M、C、K分别为明文空间、密文空间、密钥空间</p><h5 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h5><h6 id="随机性"><a href="#随机性" class="headerlink" title="随机性"></a>随机性</h6><ul><li>作用<ul><li>随机数可以作为密钥使用</li><li>在密码体制和安全协议的构造中得到广泛应用</li></ul></li><li>是否存在真正的随机性是一个<strong>哲学问题</strong><ul><li><strong>量子力学告诉我们：现实世界中存在随机性</strong></li><li>随机序列<ul><li> 性质：不能靠重复产生（完全相同的两个输入得到的是不相关的序列）</li><li>数学解释：概率服从均匀分布（产生每个比特的概率为1&#x2F;2）</li><li>产生方法：使用专门的设备，输入各种无法预测的信号，则输出也就不可重复</li></ul></li></ul></li><li><strong>电子计算机不能产生真正的随机序列</strong>（伪随机序列，产生的随机数是大周期的）<br>冯诺依曼（John von Neumann）<br><em>任何人考虑用数学的方法产生随机数，肯定是不合理的！</em></li></ul><h6 id="一次一密（OTP-one-time-pad）"><a href="#一次一密（OTP-one-time-pad）" class="headerlink" title="一次一密（OTP,one-time pad）"></a>一次一密（OTP,one-time pad）</h6><ul><li>原理<ul><li>加密：明文流与密钥流相异或</li><li>解密：密文流与密钥流相异或</li></ul></li><li>密钥流是随机序列，且不重复使用</li></ul><h6 id="完善保密性"><a href="#完善保密性" class="headerlink" title="完善保密性"></a>完善保密性</h6><p>   <code>一次一密是否安全？如何界定“安全”？</code><br>   香农 <em>唯密文攻击下，密文不能泄露明文的任何信息！</em></p><ul><li><p>提出完善保密性（考虑<strong>唯密文攻击</strong>）</p></li><li><p>定义</p><img src="/chunk.github.io/images/d45d6e789a8eb6410a2fc6bd0c248e0b.jpg" alt="d45d6e789a8eb6410a2fc6bd0c248e0b" style="zoom:50%;" /></li><li><p>例题<br> <code>一次一密中，给定明文m和其密文c，对应的密钥k有多少个？</code><br> $k&#x3D;m$^$c$</p></li></ul><p>   唯一一个密钥</p><ul><li><p>一次一密具有完善保密性(自行证明)</p></li><li><p>对称加密体制具有完善保密性</p></li><li><p>香农定理:完善保密性  ⇒  |K| ≥ |M|<br>即要满足完善保密性，所需<strong>密钥至少和明文一样长</strong></p></li><li><p>小结</p><img src="/chunk.github.io/images/749e6b676c6b262753f81b04ac5e2d04.jpg" alt="749e6b676c6b262753f81b04ac5e2d04" style="zoom:50%;" /></li></ul><h6 id="流密码-1"><a href="#流密码-1" class="headerlink" title="流密码"></a>流密码</h6><p>   <code>如何改造一次一密使它更实用   ⇒   缩短密钥长度</code></p><ul><li>基本思想<br>使用“<strong>伪随机”密钥流</strong> 代替 “随机”密钥流</li><li>使用工具<br>“<strong>伪随机生成器”（PRG）</strong></li><li>实现方法<br>利用一个<strong>短的随机密钥</strong>(称作“种子”) 作为PRG的输入，由PRG产生          <strong>伪随机密钥流</strong>，再与明文流&#x2F;密文流异或。<img src="/chunk.github.io/images/f7abf266e04636561d306c145a37d2ad.jpg" alt="f7abf266e04636561d306c145a37d2ad" style="zoom:50%;" /></li><li>PRG<ul><li>定义：G是一个高效的确定性函数，如果G是一个PRG，则它可以由一个长度很短的种子空间产生一个很长的输出。</li><li>安全性<br>设G是一个PRG，如果对于任何高效的算法，成功区分G的输出和等长的随机序列的概率都是可忽略的 (计算上不可区分)，则 G是一个安全的PRG</li><li>用途<ul><li>流密码（用于加密）</li><li>生成随机序列、随机数</li><li>生成密钥</li></ul></li><li>G是不可预测的 ⇒ G是安全的<br>不可预测性：给定输出的某些比特，高效预测其他任一比特的成功概率可忽略</li></ul></li></ul><ul><li>种子的收集<ul><li>攻击者可能尝试重构生成密钥流的种子<ul><li>攻击原理：由柯克霍夫斯原则可知攻击者知道你收集种子的方法，如果种子不够好可以被重构</li></ul></li><li>收集方法：<ul><li>毫秒计的时间</li><li>用户的输入</li><li>鼠标点击的位置</li><li>……</li></ul></li></ul></li></ul><ul><li>例题<br>流密码是否能达到完善保密性？<br>不能，因为密钥比明文短</li><li>小结<img src="/chunk.github.io/images/407335bb193bc82af970e7b8f53d094b.jpg" alt="407335bb193bc82af970e7b8f53d094b" style="zoom:50%;" /></li></ul><h6 id="语义安全性"><a href="#语义安全性" class="headerlink" title="语义安全性"></a>语义安全性</h6><p>   <code>流密码不具有完善保密性，那怎么衡量他的安全性   ⇒  语义安全性</code></p><ul><li><p>安全模型</p><img src="/chunk.github.io/images/a085db62826d3db33d4af98a21e1daf2.jpg" alt="a085db62826d3db33d4af98a21e1daf2" style="zoom:50%;" /></li><li><p>定义<br><code>如果一个对称加密体制是语义安全的，它应满足以下条件： 在上述安全模型中，对于所有高效的攻击者A,       Adv :=| Pr[ EXP(0)=1] −  Pr[ EXP(1)=1 ] | 是可忽略的，Pr[ EXP(b)=1] 表示 A 在 EXP(b) 中返回 1的概率   (b=0,1)</code></p></li><li><p>一次一密是语义安全的<img src="/chunk.github.io/images/08903dff11789c2d10c23e01e2f9f91a.jpg" alt="08903dff11789c2d10c23e01e2f9f91a" style="zoom:50%;" /></p></li><li><p>PRG是安全的 ⇒ 相应的流密码是语义安全的</p><img src="/chunk.github.io/images/a94c296e77fb52d3185bcd2f1e25f7f0.jpg" alt="a94c296e77fb52d3185bcd2f1e25f7f0" style="zoom:50%;" />经典算法</li></ul><ul><li><p>RC4</p></li><li><p>eStream 计划</p></li><li><p>LFSR-based stream ciphers<br> 流密码的密钥不能重复使用！</p> <img src="/chunk.github.io/images/81bc4c22415f6c4751f748d29c738d9d.jpg" alt="81bc4c22415f6c4751f748d29c738d9d" style="zoom:50%;" /> **想重复使用密钥时，不要“直接”使用流密码** 教训（two-time pad) ⇒    每帧使用一个伪随机密钥    小结</li></ul>   <img src="/chunk.github.io/images/72e842694e56ca35bb1832250c7ba746.jpg" alt="72e842694e56ca35bb1832250c7ba746" style="zoom:50%;" /><h3 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a><a href="./%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/">分组密码</a></h3><h3 id="对称密码的缺陷"><a href="#对称密码的缺陷" class="headerlink" title="对称密码的缺陷"></a>对称密码的缺陷</h3><ul><li>密钥管理困难<br>        多人相互通信时密钥爆炸</li><li>无法实现“非否认”<br>        通信双方有相同的密钥，无法区别该计算由谁做</li><li>共享密钥困难（密钥分发困难）<br>        密钥难以分发给对方</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>古典密码</title>
      <link href="/chunk.github.io/2025/03/18/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/"/>
      <url>/chunk.github.io/2025/03/18/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h4 id="置换密码典型代表—周期置换密码"><a href="#置换密码典型代表—周期置换密码" class="headerlink" title="置换密码典型代表—周期置换密码"></a>置换密码典型代表—周期置换密码</h4><img src="/chunk.github.io/images/8f0631d63ce267ec8ba81fb3401c9230.jpg" alt="8f0631d63ce267ec8ba81fb3401c9230" style="zoom:50%;" /><ul><li>工作原理<br>将明文按一定长度 n 进行分组，把每组的字符按位置变换规则 π 重排位置。</li><li>密钥：置换π</li><li>密钥空间大小：n！</li></ul><h4 id="移位密码"><a href="#移位密码" class="headerlink" title="移位密码"></a>移位密码</h4><ul><li>工作原理<ul><li>加密：明文字母代换为字母表中其后第k个字母</li><li>解密：密文字母代换为字母表中其前第k个字母（与加密相反）</li></ul></li><li>密钥信息<ul><li>密钥：k </li><li>密钥空间大小：26（0，1，…，25）</li></ul></li><li>典型例子<br>凯撒密码（k&#x3D;3的移位密码），<strong>没有密钥，不安全</strong></li></ul><h4 id="代换密码"><a href="#代换密码" class="headerlink" title="代换密码"></a>代换密码</h4><ul><li><h5 id="密钥—代换表"><a href="#密钥—代换表" class="headerlink" title="密钥—代换表"></a>密钥—代换表</h5></li><li><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5>根据使用代换表数量的不同，可分为单表代换密码与多表代换密码。</li><li><h5 id="单表代换密码"><a href="#单表代换密码" class="headerlink" title="单表代换密码"></a>单表代换密码</h5></li></ul><ul><li>典型代表：简单代换密码<ul><li>使用固定的代换表</li><li>代换表可以是字母表上的任意置换，明文字母到密文字母的对应关系不一定像移位密码那样有规律</li><li>密钥空间：26个字母的不同排列形成不同的密钥，共有26!个</li><li>虽然密钥空间很大，但简单代换密码并不安全<br><code>“密钥空间大”并不是密码体制安全的充分条件</code></li></ul></li></ul><ul><li>破译方法<ul><li>频率分析（阿尔·金迪 <em>Al-Kindi</em>）</li></ul><ul><li>原理：密文字母与对应的明文字母的出现频率完全一样。</li></ul></li></ul><ul><li>应对方法：<br>命名密码（对常用单词进行代换，隐藏字母频率）<br>同音密码</li></ul><h4 id="多表代换密码"><a href="#多表代换密码" class="headerlink" title="多表代换密码"></a>多表代换密码</h4><ul><li><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6>同时使用多张不同的代换表，就可以有效改变字母频率</li><li><h6 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h6> <img src="/chunk.github.io/images/d5e3d500fc60f826a844955aa3967269.jpg" alt="d5e3d500fc60f826a844955aa3967269" style="zoom:50%;" /></li><li>工作原理<ul><li><strong>密钥：长度为n的字符串</strong></li></ul><ul><li>将消息分为n位一组，依据不同的密钥字母每组分别使用代换表</li><li>密钥空间：26[^n]<br>密钥空间在n很大时已超出穷举攻击的能力范围，但不代表维吉尼亚密码不能用手工破译</li></ul></li><li>破译方法</li></ul><ul><li>在维吉尼亚密码的分析中，要&#x3D;&#x3D;先确定密钥长度，再确定具体密钥&#x3D;&#x3D;<br> <del>下面为两种确定密钥长度的常用方法</del>：</li></ul><ul><li>Kasiski测试法<ul><li>普鲁士退役军官 弗里德里希·卡西斯基(<em>Friedrich Kasiski</em>)</li><li>n为相同密文距密文开头距离的最大公约数的一个因子</li></ul></li><li>重合指数法<ul><li>美国著名密码学家 威廉.弗里德曼（<em>William F. Friedman</em>）</li><li>将维吉尼亚密文串y分割成n行，每行排成一列</li></ul><img src="/chunk.github.io/images/171435803b34dc57a1b920f2373ceeae.jpg" alt="171435803b34dc57a1b920f2373ceeae" style="zoom:50%;" /></li></ul><ul><li>计算每行的重合指数与&#x3D;&#x3D;0.065&#x3D;&#x3D;比较</li></ul><h4 id="轮转机密码"><a href="#轮转机密码" class="headerlink" title="轮转机密码"></a>轮转机密码</h4><p>   标志着加密机械化的开始</p><ul><li><h5 id="典型代表——Enigma"><a href="#典型代表——Enigma" class="headerlink" title="典型代表——Enigma"></a>典型代表——Enigma</h5><ul><li>组成<ul><li>转子（3个转动快慢不同的转子）——每个转子内部相当于一个单表代换密码</li><li>插线板——使任意两个被连接的字母的信号互换</li><li>反射器</li></ul></li><li>密钥空间<ul><li>转子初始位置  26x26x26 &#x3D; 17,576</li><li>转子相对位置  6</li><li>插线板连接方式  100,391,791,500</li></ul></li></ul></li><li><h5 id="其他密码机"><a href="#其他密码机" class="headerlink" title="其他密码机"></a>其他密码机</h5><ul><li>Lorenz (洛伦茨）</li><li>Colossus (科洛希斯)—–第一台计算机，可编程</li><li>Purple（日本，打字机）</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>大多数古典密码体制不能很好地隐藏明文的统计特征，可以用唯密文攻击攻破</li><li>只有采用科学的理念，才能设计出安全的密码体制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学基本知识</title>
      <link href="/chunk.github.io/2025/03/15/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/chunk.github.io/2025/03/15/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<ol><li>研究内容   —  保护系统安全</li><li><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul><li>密码编码学（设计密码）</li><li>密码分析学（破译密码）</li></ul></li><li><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>机密性<br>保证除了收发者没有其他人知道该信息</li><li>完整性<br>检查信息是否被篡改过</li><li>非否认<br>防范“否认干过的事”—–发消息的人不承认是他发的消息</li></ul></li><li><h4 id="信息安全三要素"><a href="#信息安全三要素" class="headerlink" title="&#x3D;&#x3D;信息安全三要素&#x3D;&#x3D;"></a>&#x3D;&#x3D;信息安全三要素&#x3D;&#x3D;</h4><ul><li>机密性<br>确保信息不被非法获取（窃听、盗窃文件、社会工程学）</li><li>完整性<br>确保能够发现信息是否被改动过（合法用户的失误、非法用户的篡改）</li><li>可用性<br>确保系统正常提供服务（设备故障、软件错误、环境因素、人为攻击）</li></ul></li><li><h4 id="攻击形式"><a href="#攻击形式" class="headerlink" title="攻击形式"></a>攻击形式</h4><ul><li>被动攻击<br>破坏机密性（窃听）</li><li>主动攻击<ul><li>破坏完整性（篡改或冒充）</li><li>破坏可用性</li></ul></li></ul></li><li><h4 id="密码学的基本原则"><a href="#密码学的基本原则" class="headerlink" title="密码学的基本原则"></a>密码学的基本原则</h4><strong>柯克霍夫斯原则</strong>：“<em>即使密码系统的任何细节已为人所知只要密钥没有泄漏它也应该是安全的。</em>”<br>意义：密码算法很难保密<br>（1）知道算法的人可能叛变<br>历史上这种事屡见不鲜<br>（2）设计者有个人喜好<br>喜欢使用一些固定结构，易被猜测<br>（3）频繁更换算法不现实，但更换密钥很容易<br>设计安全的密码算法很困难，而密钥只是一个串<br>启发：<br>（1）加解密是在<strong>密钥</strong>的控制下进行的<br>（2）加密函数必须是一个<strong>单射函数</strong></li><li><h4 id="两种技术"><a href="#两种技术" class="headerlink" title="两种技术"></a>两种技术</h4><ul><li>隐写术<br>保护的是信息本身（把信息隐藏起来），一旦发现隐藏的方法，信息就会暴露</li><li>加密术<br>保护的是信息内容，传递的是变换后的密文，而不是原来的明文，不知道密钥，很难恢复信息</li></ul></li><li><h4 id="加密常见技术"><a href="#加密常见技术" class="headerlink" title="加密常见技术"></a>加密常见技术</h4><ul><li>置换（易位）<br>特点：明文中字符与密文中相同，只是出现的位置发生变化<br>密钥：改变位置的规则</li><li>代换（替换、代替）<br>特点：明文中出现的字符不一定出现在密文中，但位置不变<br>密钥：代换规则</li></ul></li><li><h4 id="秘密通信模型（以对称密码体制为例）"><a href="#秘密通信模型（以对称密码体制为例）" class="headerlink" title="秘密通信模型（以对称密码体制为例）"></a>秘密通信模型（以对称密码体制为例）</h4><ul><li>加密：E(k,m)&#x3D;c</li><li>解密：D(k,c)&#x3D;m</li><li>D(k,E(k,m))&#x3D;m</li></ul></li><li><h4 id="攻击方式的分类"><a href="#攻击方式的分类" class="headerlink" title="攻击方式的分类"></a>攻击方式的分类</h4><ul><li>唯密文攻击</li><li>已知明文攻击</li><li>选择明文攻击</li><li>选择密文攻击</li></ul></li><li><h4 id="加密体制的安全性"><a href="#加密体制的安全性" class="headerlink" title="加密体制的安全性"></a>加密体制的安全性</h4><ul><li>攻击能力（攻击方式）<br>能抵抗攻击者什么类型的攻击</li><li>攻击目的<br>能阻止攻击者是实现什么样的目的<ul><li>找到密钥</li><li>回复特定明文</li><li>区分两个明文</li></ul></li></ul></li><li><h4 id="一些小tips"><a href="#一些小tips" class="headerlink" title="一些小tips"></a>一些小tips</h4><ul><li>通过密文推导出密钥的难度不能低于推导出明文的难度</li><li>密钥应该随机选择</li><li>密钥空间要足够大，以抵抗密钥穷举攻击<blockquote><p>各种分析方法的效率谁高谁低呢？常以穷举攻击的效率作为比较的标准</p></blockquote></li><li>并不一定恢复出整个明文才算成功破译，有时候，恢复出明文的部分信息，甚至几个关键单词，也算成功破译</li><li>安全都是相对的</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学史</title>
      <link href="/chunk.github.io/2025/03/13/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%B2/"/>
      <url>/chunk.github.io/2025/03/13/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h5 id="1-演变过程"><a href="#1-演变过程" class="headerlink" title="1. 演变过程"></a>1. 演变过程</h5><p>古代加密方法—–古典密码—-现代密码       后量子密码</p><h5 id="2-重要事件"><a href="#2-重要事件" class="headerlink" title="2. 重要事件"></a>2. 重要事件</h5><ul><li>1949年，香农（<em>Shannon’s theorem</em>）发表论文《保密系统的通信原理》，密码学的理论基础之一,发表30年后才显示出它的价值<br>拉开密码学从技术进化到科学的序幕</li><li>1976年，Diffie、Hellman发表论文《密码学的新方向》，开辟了&#x3D;&#x3D;公钥密码学&#x3D;&#x3D;的新领域<br><em>没有公钥密码的研究就没有现代密码学</em></li><li>1978年，RSA密码体制出现，公钥密码领域最杰出的代表，事实上的标准，&#x3D;&#x3D;密码学史上的里程碑&#x3D;&#x3D;</li><li>1978年，DES(数据加密标准)出现</li></ul><h5 id="3-发展历程"><a href="#3-发展历程" class="headerlink" title="3. 发展历程"></a>3. 发展历程</h5><ul><li>1949以前：密码学只是一门技术&#x2F;艺术</li><li>1949-1975：密码学形成一门科学</li><li>1976年以后：密码学新方向（公钥密码学）</li><li>密码技术源远流长，但真正形成学科还是20世纪40-70年代的事</li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学</title>
      <link href="/chunk.github.io/2025/03/11/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/chunk.github.io/2025/03/11/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="密码学史"><a href="#密码学史" class="headerlink" title="密码学史"></a><a href="./%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8F%B2/">密码学史</a></h3><h3 id="密码学基本知识"><a href="#密码学基本知识" class="headerlink" title="密码学基本知识"></a><a href="./%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">密码学基本知识</a></h3><h3 id="密码编码（保证机密性）"><a href="#密码编码（保证机密性）" class="headerlink" title="密码编码（保证机密性）"></a>密码编码（保证机密性）</h3><ol><li><a href="./%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81/">古典密码</a><ul><li>手工或机械方式对字符或单词进行处理</li><li>明文一般是有意义的自然语言文本</li></ul></li><li>现代密码<ul><li><a href="./%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/">对称密码</a></li><li><a href="./%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/">公钥密码学</a>（非对称密码）</li><li>总结<ul><li>面向计算机和芯片，对比特、字节或字进行处理</li><li>明文可以是任意比特串</li></ul></li></ul></li></ol><h3 id="Hash函数（工具）"><a href="#Hash函数（工具）" class="headerlink" title="Hash函数（工具）"></a><a href="./Hash%E5%87%BD%E6%95%B0/">Hash函数</a>（工具）</h3><h3 id="认证（防伪造）"><a href="#认证（防伪造）" class="headerlink" title="认证（防伪造）"></a>认证（防伪造）</h3><ol><li><a href="./%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81/">消息认证</a>：确认消息的来源</li><li><a href="./%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/">身份认证</a>：确认通信对方是谁、向对方证明你是谁</li></ol><h3 id="数据完整性技术"><a href="#数据完整性技术" class="headerlink" title="数据完整性技术"></a><a href="./%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8A%80%E6%9C%AF/">数据完整性技术</a></h3><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a><a href="./%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/">安全协议</a></h3><h3 id="量子密码"><a href="#量子密码" class="headerlink" title="量子密码"></a><a href="./%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/">量子密码</a></h3><h3 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h3><ul><li><a href="./%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81/">对称密码</a>学</li><li><a href="./%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/">公钥密码学</a>（传统公钥密码）<ul><li>RSA</li><li><a href="./%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6/">椭圆曲线密码学</a></li></ul></li><li><a href="./%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6/">基于身份的密码学</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学，笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
